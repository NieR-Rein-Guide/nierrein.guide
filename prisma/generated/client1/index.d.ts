
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model character
 * 
 */
export type character = {
  character_id: number
  slug: string | null
  name: string | null
  image_path: string | null
}

/**
 * Model character_rank_bonus
 * 
 */
export type character_rank_bonus = {
  rank_bonus_id: number
  rank_bonus_level: number
  character_id: number
  description: string | null
  stat: string | null
  type: string | null
  amount: number
}

/**
 * Model companion
 * 
 */
export type companion = {
  companion_id: number
  attribute: string | null
  type: string | null
  release_time: Date
  name: string | null
  story: string | null
  image_path_base: string | null
}

/**
 * Model companion_ability
 * 
 */
export type companion_ability = {
  ability_id: number
  ability_level: number
  name: string | null
  description: string | null
  image_path_base: string | null
}

/**
 * Model companion_ability_link
 * 
 */
export type companion_ability_link = {
  companion_id: number
  companion_level: number
  ability_id: number
  ability_level: number
}

/**
 * Model companion_skill
 * 
 */
export type companion_skill = {
  skill_id: number
  skill_level: number
  cooldown_time: number
  name: string | null
  description: string | null
  short_description: string | null
  image_path: string | null
}

/**
 * Model companion_skill_link
 * 
 */
export type companion_skill_link = {
  companion_id: number
  companion_level: number
  skill_id: number
  skill_level: number
}

/**
 * Model companion_stat
 * 
 */
export type companion_stat = {
  companion_id: number
  level: number
  atk: number
  hp: number
  vit: number
}

/**
 * Model costume
 * 
 */
export type costume = {
  costume_id: number
  character_id: number
  emblem_id: number | null
  weapon_type: string | null
  rarity: string | null
  release_time: Date
  is_ex_costume: boolean
  slug: string | null
  title: string | null
  description: string | null
  image_path_base: string | null
}

/**
 * Model costume_ability
 * 
 */
export type costume_ability = {
  ability_id: number
  ability_level: number
  name: string | null
  description: string | null
  image_path_base: string | null
}

/**
 * Model costume_ability_link
 * 
 */
export type costume_ability_link = {
  costume_id: number
  ability_slot: number
  ability_id: number
  ability_level: number
}

/**
 * Model costume_skill
 * 
 */
export type costume_skill = {
  skill_id: number
  skill_level: number
  gauge_rise_speed: string | null
  cooldown_time: number
  name: string | null
  description: string | null
  short_description: string | null
  image_path: string | null
}

/**
 * Model costume_skill_link
 * 
 */
export type costume_skill_link = {
  costume_id: number
  skill_id: number
  skill_level: number
}

/**
 * Model costume_stat
 * 
 */
export type costume_stat = {
  costume_id: number
  level: number
  agi: number
  atk: number
  crit_atk: number
  crit_rate: number
  eva_rate: number
  hp: number
  vit: number
}

/**
 * Model emblem
 * 
 */
export type emblem = {
  emblem_id: number
  name: string | null
  main_message: string | null
  small_messages: string | null
  image_path: string | null
}

/**
 * Model memoir
 * 
 */
export type memoir = {
  memoir_id: number
  lottery_id: number
  rarity: string | null
  release_time: Date
  name: string | null
  story: string | null
  image_path_base: string | null
  memoir_series_id: number | null
}

/**
 * Model memoir_series
 * 
 */
export type memoir_series = {
  memoir_series_id: number
  name: string | null
  small_set_description: string | null
  large_set_description: string | null
}

/**
 * Model weapon
 * 
 */
export type weapon = {
  weapon_id: number
  evolution_group_id: number
  evolution_order: number
  weapon_type: string | null
  rarity: string | null
  attribute: string | null
  is_ex_weapon: boolean
  release_time: Date | null
  slug: string | null
  name: string | null
  image_path: string | null
}

/**
 * Model weapon_ability
 * 
 */
export type weapon_ability = {
  ability_id: number
  ability_level: number
  name: string | null
  description: string | null
  image_path_base: string | null
}

/**
 * Model weapon_ability_link
 * 
 */
export type weapon_ability_link = {
  weapon_id: number
  slot_number: number
  ability_id: number
  ability_level: number
}

/**
 * Model weapon_skill
 * 
 */
export type weapon_skill = {
  skill_id: number
  skill_level: number
  cooldown_time: number
  name: string | null
  description: string | null
  short_description: string | null
  image_path: string | null
}

/**
 * Model weapon_skill_link
 * 
 */
export type weapon_skill_link = {
  weapon_id: number
  slot_number: number
  skill_id: number
  skill_level: number
}

/**
 * Model weapon_stat
 * 
 */
export type weapon_stat = {
  weapon_id: number
  level: number
  atk: number
  hp: number
  vit: number
}

/**
 * Model weapon_story
 * 
 */
export type weapon_story = {
  id: number
  story: string | null
}

/**
 * Model weapon_story_link
 * 
 */
export type weapon_story_link = {
  weapon_id: number
  weapon_story_id: number
}

/**
 * Model debris
 * 
 */
export type debris = {
  debris_id: number
  rarity: number
  release_time: Date
  name: string | null
  image_path_base: string | null
}

/**
 * Model notification
 * 
 */
export type notification = {
  notification_id: number
  information_type: string | null
  title: string | null
  body: string | null
  release_time: Date | null
  thumbnail_path: string | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Characters
 * const characters = await prisma.character.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Characters
   * const characters = await prisma.character.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.character`: Exposes CRUD operations for the **character** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.character.findMany()
    * ```
    */
  get character(): Prisma.characterDelegate<GlobalReject>;

  /**
   * `prisma.character_rank_bonus`: Exposes CRUD operations for the **character_rank_bonus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Character_rank_bonuses
    * const character_rank_bonuses = await prisma.character_rank_bonus.findMany()
    * ```
    */
  get character_rank_bonus(): Prisma.character_rank_bonusDelegate<GlobalReject>;

  /**
   * `prisma.companion`: Exposes CRUD operations for the **companion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companions
    * const companions = await prisma.companion.findMany()
    * ```
    */
  get companion(): Prisma.companionDelegate<GlobalReject>;

  /**
   * `prisma.companion_ability`: Exposes CRUD operations for the **companion_ability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companion_abilities
    * const companion_abilities = await prisma.companion_ability.findMany()
    * ```
    */
  get companion_ability(): Prisma.companion_abilityDelegate<GlobalReject>;

  /**
   * `prisma.companion_ability_link`: Exposes CRUD operations for the **companion_ability_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companion_ability_links
    * const companion_ability_links = await prisma.companion_ability_link.findMany()
    * ```
    */
  get companion_ability_link(): Prisma.companion_ability_linkDelegate<GlobalReject>;

  /**
   * `prisma.companion_skill`: Exposes CRUD operations for the **companion_skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companion_skills
    * const companion_skills = await prisma.companion_skill.findMany()
    * ```
    */
  get companion_skill(): Prisma.companion_skillDelegate<GlobalReject>;

  /**
   * `prisma.companion_skill_link`: Exposes CRUD operations for the **companion_skill_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companion_skill_links
    * const companion_skill_links = await prisma.companion_skill_link.findMany()
    * ```
    */
  get companion_skill_link(): Prisma.companion_skill_linkDelegate<GlobalReject>;

  /**
   * `prisma.companion_stat`: Exposes CRUD operations for the **companion_stat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companion_stats
    * const companion_stats = await prisma.companion_stat.findMany()
    * ```
    */
  get companion_stat(): Prisma.companion_statDelegate<GlobalReject>;

  /**
   * `prisma.costume`: Exposes CRUD operations for the **costume** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Costumes
    * const costumes = await prisma.costume.findMany()
    * ```
    */
  get costume(): Prisma.costumeDelegate<GlobalReject>;

  /**
   * `prisma.costume_ability`: Exposes CRUD operations for the **costume_ability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Costume_abilities
    * const costume_abilities = await prisma.costume_ability.findMany()
    * ```
    */
  get costume_ability(): Prisma.costume_abilityDelegate<GlobalReject>;

  /**
   * `prisma.costume_ability_link`: Exposes CRUD operations for the **costume_ability_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Costume_ability_links
    * const costume_ability_links = await prisma.costume_ability_link.findMany()
    * ```
    */
  get costume_ability_link(): Prisma.costume_ability_linkDelegate<GlobalReject>;

  /**
   * `prisma.costume_skill`: Exposes CRUD operations for the **costume_skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Costume_skills
    * const costume_skills = await prisma.costume_skill.findMany()
    * ```
    */
  get costume_skill(): Prisma.costume_skillDelegate<GlobalReject>;

  /**
   * `prisma.costume_skill_link`: Exposes CRUD operations for the **costume_skill_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Costume_skill_links
    * const costume_skill_links = await prisma.costume_skill_link.findMany()
    * ```
    */
  get costume_skill_link(): Prisma.costume_skill_linkDelegate<GlobalReject>;

  /**
   * `prisma.costume_stat`: Exposes CRUD operations for the **costume_stat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Costume_stats
    * const costume_stats = await prisma.costume_stat.findMany()
    * ```
    */
  get costume_stat(): Prisma.costume_statDelegate<GlobalReject>;

  /**
   * `prisma.emblem`: Exposes CRUD operations for the **emblem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emblems
    * const emblems = await prisma.emblem.findMany()
    * ```
    */
  get emblem(): Prisma.emblemDelegate<GlobalReject>;

  /**
   * `prisma.memoir`: Exposes CRUD operations for the **memoir** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Memoirs
    * const memoirs = await prisma.memoir.findMany()
    * ```
    */
  get memoir(): Prisma.memoirDelegate<GlobalReject>;

  /**
   * `prisma.memoir_series`: Exposes CRUD operations for the **memoir_series** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Memoir_series
    * const memoir_series = await prisma.memoir_series.findMany()
    * ```
    */
  get memoir_series(): Prisma.memoir_seriesDelegate<GlobalReject>;

  /**
   * `prisma.weapon`: Exposes CRUD operations for the **weapon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weapons
    * const weapons = await prisma.weapon.findMany()
    * ```
    */
  get weapon(): Prisma.weaponDelegate<GlobalReject>;

  /**
   * `prisma.weapon_ability`: Exposes CRUD operations for the **weapon_ability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weapon_abilities
    * const weapon_abilities = await prisma.weapon_ability.findMany()
    * ```
    */
  get weapon_ability(): Prisma.weapon_abilityDelegate<GlobalReject>;

  /**
   * `prisma.weapon_ability_link`: Exposes CRUD operations for the **weapon_ability_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weapon_ability_links
    * const weapon_ability_links = await prisma.weapon_ability_link.findMany()
    * ```
    */
  get weapon_ability_link(): Prisma.weapon_ability_linkDelegate<GlobalReject>;

  /**
   * `prisma.weapon_skill`: Exposes CRUD operations for the **weapon_skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weapon_skills
    * const weapon_skills = await prisma.weapon_skill.findMany()
    * ```
    */
  get weapon_skill(): Prisma.weapon_skillDelegate<GlobalReject>;

  /**
   * `prisma.weapon_skill_link`: Exposes CRUD operations for the **weapon_skill_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weapon_skill_links
    * const weapon_skill_links = await prisma.weapon_skill_link.findMany()
    * ```
    */
  get weapon_skill_link(): Prisma.weapon_skill_linkDelegate<GlobalReject>;

  /**
   * `prisma.weapon_stat`: Exposes CRUD operations for the **weapon_stat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weapon_stats
    * const weapon_stats = await prisma.weapon_stat.findMany()
    * ```
    */
  get weapon_stat(): Prisma.weapon_statDelegate<GlobalReject>;

  /**
   * `prisma.weapon_story`: Exposes CRUD operations for the **weapon_story** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weapon_stories
    * const weapon_stories = await prisma.weapon_story.findMany()
    * ```
    */
  get weapon_story(): Prisma.weapon_storyDelegate<GlobalReject>;

  /**
   * `prisma.weapon_story_link`: Exposes CRUD operations for the **weapon_story_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Weapon_story_links
    * const weapon_story_links = await prisma.weapon_story_link.findMany()
    * ```
    */
  get weapon_story_link(): Prisma.weapon_story_linkDelegate<GlobalReject>;

  /**
   * `prisma.debris`: Exposes CRUD operations for the **debris** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Debris
    * const debris = await prisma.debris.findMany()
    * ```
    */
  get debris(): Prisma.debrisDelegate<GlobalReject>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.notificationDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Prisma Client JS version: 3.15.2
   * Query Engine version: 461d6a05159055555eb7dfb337c9fb271cbd4d7e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    character: 'character',
    character_rank_bonus: 'character_rank_bonus',
    companion: 'companion',
    companion_ability: 'companion_ability',
    companion_ability_link: 'companion_ability_link',
    companion_skill: 'companion_skill',
    companion_skill_link: 'companion_skill_link',
    companion_stat: 'companion_stat',
    costume: 'costume',
    costume_ability: 'costume_ability',
    costume_ability_link: 'costume_ability_link',
    costume_skill: 'costume_skill',
    costume_skill_link: 'costume_skill_link',
    costume_stat: 'costume_stat',
    emblem: 'emblem',
    memoir: 'memoir',
    memoir_series: 'memoir_series',
    weapon: 'weapon',
    weapon_ability: 'weapon_ability',
    weapon_ability_link: 'weapon_ability_link',
    weapon_skill: 'weapon_skill',
    weapon_skill_link: 'weapon_skill_link',
    weapon_stat: 'weapon_stat',
    weapon_story: 'weapon_story',
    weapon_story_link: 'weapon_story_link',
    debris: 'debris',
    notification: 'notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CharacterCountOutputType
   */


  export type CharacterCountOutputType = {
    character_rank_bonus: number
    costume: number
  }

  export type CharacterCountOutputTypeSelect = {
    character_rank_bonus?: boolean
    costume?: boolean
  }

  export type CharacterCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CharacterCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CharacterCountOutputType
    : S extends undefined
    ? never
    : S extends CharacterCountOutputTypeArgs
    ?'include' extends U
    ? CharacterCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CharacterCountOutputType ? CharacterCountOutputType[P] : never
  } 
    : CharacterCountOutputType
  : CharacterCountOutputType




  // Custom InputTypes

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CharacterCountOutputType
     * 
    **/
    select?: CharacterCountOutputTypeSelect | null
  }



  /**
   * Count Type CompanionCountOutputType
   */


  export type CompanionCountOutputType = {
    companion_ability_link: number
    companion_skill_link: number
    companion_stat: number
  }

  export type CompanionCountOutputTypeSelect = {
    companion_ability_link?: boolean
    companion_skill_link?: boolean
    companion_stat?: boolean
  }

  export type CompanionCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CompanionCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CompanionCountOutputType
    : S extends undefined
    ? never
    : S extends CompanionCountOutputTypeArgs
    ?'include' extends U
    ? CompanionCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CompanionCountOutputType ? CompanionCountOutputType[P] : never
  } 
    : CompanionCountOutputType
  : CompanionCountOutputType




  // Custom InputTypes

  /**
   * CompanionCountOutputType without action
   */
  export type CompanionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CompanionCountOutputType
     * 
    **/
    select?: CompanionCountOutputTypeSelect | null
  }



  /**
   * Count Type Companion_abilityCountOutputType
   */


  export type Companion_abilityCountOutputType = {
    companion_ability_link: number
  }

  export type Companion_abilityCountOutputTypeSelect = {
    companion_ability_link?: boolean
  }

  export type Companion_abilityCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Companion_abilityCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Companion_abilityCountOutputType
    : S extends undefined
    ? never
    : S extends Companion_abilityCountOutputTypeArgs
    ?'include' extends U
    ? Companion_abilityCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Companion_abilityCountOutputType ? Companion_abilityCountOutputType[P] : never
  } 
    : Companion_abilityCountOutputType
  : Companion_abilityCountOutputType




  // Custom InputTypes

  /**
   * Companion_abilityCountOutputType without action
   */
  export type Companion_abilityCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Companion_abilityCountOutputType
     * 
    **/
    select?: Companion_abilityCountOutputTypeSelect | null
  }



  /**
   * Count Type Companion_skillCountOutputType
   */


  export type Companion_skillCountOutputType = {
    companion_skill_link: number
  }

  export type Companion_skillCountOutputTypeSelect = {
    companion_skill_link?: boolean
  }

  export type Companion_skillCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Companion_skillCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Companion_skillCountOutputType
    : S extends undefined
    ? never
    : S extends Companion_skillCountOutputTypeArgs
    ?'include' extends U
    ? Companion_skillCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Companion_skillCountOutputType ? Companion_skillCountOutputType[P] : never
  } 
    : Companion_skillCountOutputType
  : Companion_skillCountOutputType




  // Custom InputTypes

  /**
   * Companion_skillCountOutputType without action
   */
  export type Companion_skillCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Companion_skillCountOutputType
     * 
    **/
    select?: Companion_skillCountOutputTypeSelect | null
  }



  /**
   * Count Type CostumeCountOutputType
   */


  export type CostumeCountOutputType = {
    costume_ability_link: number
    costume_skill_link: number
    costume_stat: number
  }

  export type CostumeCountOutputTypeSelect = {
    costume_ability_link?: boolean
    costume_skill_link?: boolean
    costume_stat?: boolean
  }

  export type CostumeCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CostumeCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CostumeCountOutputType
    : S extends undefined
    ? never
    : S extends CostumeCountOutputTypeArgs
    ?'include' extends U
    ? CostumeCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CostumeCountOutputType ? CostumeCountOutputType[P] : never
  } 
    : CostumeCountOutputType
  : CostumeCountOutputType




  // Custom InputTypes

  /**
   * CostumeCountOutputType without action
   */
  export type CostumeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CostumeCountOutputType
     * 
    **/
    select?: CostumeCountOutputTypeSelect | null
  }



  /**
   * Count Type Costume_abilityCountOutputType
   */


  export type Costume_abilityCountOutputType = {
    costume_ability_link: number
  }

  export type Costume_abilityCountOutputTypeSelect = {
    costume_ability_link?: boolean
  }

  export type Costume_abilityCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Costume_abilityCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Costume_abilityCountOutputType
    : S extends undefined
    ? never
    : S extends Costume_abilityCountOutputTypeArgs
    ?'include' extends U
    ? Costume_abilityCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Costume_abilityCountOutputType ? Costume_abilityCountOutputType[P] : never
  } 
    : Costume_abilityCountOutputType
  : Costume_abilityCountOutputType




  // Custom InputTypes

  /**
   * Costume_abilityCountOutputType without action
   */
  export type Costume_abilityCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Costume_abilityCountOutputType
     * 
    **/
    select?: Costume_abilityCountOutputTypeSelect | null
  }



  /**
   * Count Type Costume_skillCountOutputType
   */


  export type Costume_skillCountOutputType = {
    costume_skill_link: number
  }

  export type Costume_skillCountOutputTypeSelect = {
    costume_skill_link?: boolean
  }

  export type Costume_skillCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Costume_skillCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Costume_skillCountOutputType
    : S extends undefined
    ? never
    : S extends Costume_skillCountOutputTypeArgs
    ?'include' extends U
    ? Costume_skillCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Costume_skillCountOutputType ? Costume_skillCountOutputType[P] : never
  } 
    : Costume_skillCountOutputType
  : Costume_skillCountOutputType




  // Custom InputTypes

  /**
   * Costume_skillCountOutputType without action
   */
  export type Costume_skillCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Costume_skillCountOutputType
     * 
    **/
    select?: Costume_skillCountOutputTypeSelect | null
  }



  /**
   * Count Type EmblemCountOutputType
   */


  export type EmblemCountOutputType = {
    costume: number
  }

  export type EmblemCountOutputTypeSelect = {
    costume?: boolean
  }

  export type EmblemCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EmblemCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EmblemCountOutputType
    : S extends undefined
    ? never
    : S extends EmblemCountOutputTypeArgs
    ?'include' extends U
    ? EmblemCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EmblemCountOutputType ? EmblemCountOutputType[P] : never
  } 
    : EmblemCountOutputType
  : EmblemCountOutputType




  // Custom InputTypes

  /**
   * EmblemCountOutputType without action
   */
  export type EmblemCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EmblemCountOutputType
     * 
    **/
    select?: EmblemCountOutputTypeSelect | null
  }



  /**
   * Count Type Memoir_seriesCountOutputType
   */


  export type Memoir_seriesCountOutputType = {
    memoir: number
  }

  export type Memoir_seriesCountOutputTypeSelect = {
    memoir?: boolean
  }

  export type Memoir_seriesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Memoir_seriesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Memoir_seriesCountOutputType
    : S extends undefined
    ? never
    : S extends Memoir_seriesCountOutputTypeArgs
    ?'include' extends U
    ? Memoir_seriesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Memoir_seriesCountOutputType ? Memoir_seriesCountOutputType[P] : never
  } 
    : Memoir_seriesCountOutputType
  : Memoir_seriesCountOutputType




  // Custom InputTypes

  /**
   * Memoir_seriesCountOutputType without action
   */
  export type Memoir_seriesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Memoir_seriesCountOutputType
     * 
    **/
    select?: Memoir_seriesCountOutputTypeSelect | null
  }



  /**
   * Count Type WeaponCountOutputType
   */


  export type WeaponCountOutputType = {
    weapon_ability_link: number
    weapon_skill_link: number
    weapon_stat: number
    weapon_story_link: number
  }

  export type WeaponCountOutputTypeSelect = {
    weapon_ability_link?: boolean
    weapon_skill_link?: boolean
    weapon_stat?: boolean
    weapon_story_link?: boolean
  }

  export type WeaponCountOutputTypeGetPayload<
    S extends boolean | null | undefined | WeaponCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? WeaponCountOutputType
    : S extends undefined
    ? never
    : S extends WeaponCountOutputTypeArgs
    ?'include' extends U
    ? WeaponCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof WeaponCountOutputType ? WeaponCountOutputType[P] : never
  } 
    : WeaponCountOutputType
  : WeaponCountOutputType




  // Custom InputTypes

  /**
   * WeaponCountOutputType without action
   */
  export type WeaponCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WeaponCountOutputType
     * 
    **/
    select?: WeaponCountOutputTypeSelect | null
  }



  /**
   * Count Type Weapon_abilityCountOutputType
   */


  export type Weapon_abilityCountOutputType = {
    weapon_ability_link: number
  }

  export type Weapon_abilityCountOutputTypeSelect = {
    weapon_ability_link?: boolean
  }

  export type Weapon_abilityCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Weapon_abilityCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Weapon_abilityCountOutputType
    : S extends undefined
    ? never
    : S extends Weapon_abilityCountOutputTypeArgs
    ?'include' extends U
    ? Weapon_abilityCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Weapon_abilityCountOutputType ? Weapon_abilityCountOutputType[P] : never
  } 
    : Weapon_abilityCountOutputType
  : Weapon_abilityCountOutputType




  // Custom InputTypes

  /**
   * Weapon_abilityCountOutputType without action
   */
  export type Weapon_abilityCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Weapon_abilityCountOutputType
     * 
    **/
    select?: Weapon_abilityCountOutputTypeSelect | null
  }



  /**
   * Count Type Weapon_skillCountOutputType
   */


  export type Weapon_skillCountOutputType = {
    weapon_skill_link: number
  }

  export type Weapon_skillCountOutputTypeSelect = {
    weapon_skill_link?: boolean
  }

  export type Weapon_skillCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Weapon_skillCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Weapon_skillCountOutputType
    : S extends undefined
    ? never
    : S extends Weapon_skillCountOutputTypeArgs
    ?'include' extends U
    ? Weapon_skillCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Weapon_skillCountOutputType ? Weapon_skillCountOutputType[P] : never
  } 
    : Weapon_skillCountOutputType
  : Weapon_skillCountOutputType




  // Custom InputTypes

  /**
   * Weapon_skillCountOutputType without action
   */
  export type Weapon_skillCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Weapon_skillCountOutputType
     * 
    **/
    select?: Weapon_skillCountOutputTypeSelect | null
  }



  /**
   * Count Type Weapon_storyCountOutputType
   */


  export type Weapon_storyCountOutputType = {
    weapon_story_link: number
  }

  export type Weapon_storyCountOutputTypeSelect = {
    weapon_story_link?: boolean
  }

  export type Weapon_storyCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Weapon_storyCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Weapon_storyCountOutputType
    : S extends undefined
    ? never
    : S extends Weapon_storyCountOutputTypeArgs
    ?'include' extends U
    ? Weapon_storyCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Weapon_storyCountOutputType ? Weapon_storyCountOutputType[P] : never
  } 
    : Weapon_storyCountOutputType
  : Weapon_storyCountOutputType




  // Custom InputTypes

  /**
   * Weapon_storyCountOutputType without action
   */
  export type Weapon_storyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Weapon_storyCountOutputType
     * 
    **/
    select?: Weapon_storyCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model character
   */


  export type AggregateCharacter = {
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  export type CharacterAvgAggregateOutputType = {
    character_id: number | null
  }

  export type CharacterSumAggregateOutputType = {
    character_id: number | null
  }

  export type CharacterMinAggregateOutputType = {
    character_id: number | null
    slug: string | null
    name: string | null
    image_path: string | null
  }

  export type CharacterMaxAggregateOutputType = {
    character_id: number | null
    slug: string | null
    name: string | null
    image_path: string | null
  }

  export type CharacterCountAggregateOutputType = {
    character_id: number
    slug: number
    name: number
    image_path: number
    _all: number
  }


  export type CharacterAvgAggregateInputType = {
    character_id?: true
  }

  export type CharacterSumAggregateInputType = {
    character_id?: true
  }

  export type CharacterMinAggregateInputType = {
    character_id?: true
    slug?: true
    name?: true
    image_path?: true
  }

  export type CharacterMaxAggregateInputType = {
    character_id?: true
    slug?: true
    name?: true
    image_path?: true
  }

  export type CharacterCountAggregateInputType = {
    character_id?: true
    slug?: true
    name?: true
    image_path?: true
    _all?: true
  }

  export type CharacterAggregateArgs = {
    /**
     * Filter which character to aggregate.
     * 
    **/
    where?: characterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characters to fetch.
     * 
    **/
    orderBy?: Enumerable<characterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: characterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned characters
    **/
    _count?: true | CharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterMaxAggregateInputType
  }

  export type GetCharacterAggregateType<T extends CharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter[P]>
      : GetScalarType<T[P], AggregateCharacter[P]>
  }




  export type CharacterGroupByArgs = {
    where?: characterWhereInput
    orderBy?: Enumerable<characterOrderByWithAggregationInput>
    by: Array<CharacterScalarFieldEnum>
    having?: characterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterCountAggregateInputType | true
    _avg?: CharacterAvgAggregateInputType
    _sum?: CharacterSumAggregateInputType
    _min?: CharacterMinAggregateInputType
    _max?: CharacterMaxAggregateInputType
  }


  export type CharacterGroupByOutputType = {
    character_id: number
    slug: string | null
    name: string | null
    image_path: string | null
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  type GetCharacterGroupByPayload<T extends CharacterGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterGroupByOutputType[P]>
        }
      >
    >


  export type characterSelect = {
    character_id?: boolean
    slug?: boolean
    name?: boolean
    image_path?: boolean
    character_rank_bonus?: boolean | character_rank_bonusFindManyArgs
    costume?: boolean | costumeFindManyArgs
    _count?: boolean | CharacterCountOutputTypeArgs
  }

  export type characterInclude = {
    character_rank_bonus?: boolean | character_rank_bonusFindManyArgs
    costume?: boolean | costumeFindManyArgs
    _count?: boolean | CharacterCountOutputTypeArgs
  }

  export type characterGetPayload<
    S extends boolean | null | undefined | characterArgs,
    U = keyof S
      > = S extends true
        ? character
    : S extends undefined
    ? never
    : S extends characterArgs | characterFindManyArgs
    ?'include' extends U
    ? character  & {
    [P in TrueKeys<S['include']>]:
        P extends 'character_rank_bonus' ? Array < character_rank_bonusGetPayload<S['include'][P]>>  :
        P extends 'costume' ? Array < costumeGetPayload<S['include'][P]>>  :
        P extends '_count' ? CharacterCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'character_rank_bonus' ? Array < character_rank_bonusGetPayload<S['select'][P]>>  :
        P extends 'costume' ? Array < costumeGetPayload<S['select'][P]>>  :
        P extends '_count' ? CharacterCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof character ? character[P] : never
  } 
    : character
  : character


  type characterCountArgs = Merge<
    Omit<characterFindManyArgs, 'select' | 'include'> & {
      select?: CharacterCountAggregateInputType | true
    }
  >

  export interface characterDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Character that matches the filter.
     * @param {characterFindUniqueArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends characterFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, characterFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'character'> extends True ? CheckSelect<T, Prisma__characterClient<character>, Prisma__characterClient<characterGetPayload<T>>> : CheckSelect<T, Prisma__characterClient<character | null >, Prisma__characterClient<characterGetPayload<T> | null >>

    /**
     * Find the first Character that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {characterFindFirstArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends characterFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, characterFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'character'> extends True ? CheckSelect<T, Prisma__characterClient<character>, Prisma__characterClient<characterGetPayload<T>>> : CheckSelect<T, Prisma__characterClient<character | null >, Prisma__characterClient<characterGetPayload<T> | null >>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {characterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.character.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.character.findMany({ take: 10 })
     * 
     * // Only select the `character_id`
     * const characterWithCharacter_idOnly = await prisma.character.findMany({ select: { character_id: true } })
     * 
    **/
    findMany<T extends characterFindManyArgs>(
      args?: SelectSubset<T, characterFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<character>>, PrismaPromise<Array<characterGetPayload<T>>>>

    /**
     * Create a Character.
     * @param {characterCreateArgs} args - Arguments to create a Character.
     * @example
     * // Create one Character
     * const Character = await prisma.character.create({
     *   data: {
     *     // ... data to create a Character
     *   }
     * })
     * 
    **/
    create<T extends characterCreateArgs>(
      args: SelectSubset<T, characterCreateArgs>
    ): CheckSelect<T, Prisma__characterClient<character>, Prisma__characterClient<characterGetPayload<T>>>

    /**
     * Create many Characters.
     *     @param {characterCreateManyArgs} args - Arguments to create many Characters.
     *     @example
     *     // Create many Characters
     *     const character = await prisma.character.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends characterCreateManyArgs>(
      args?: SelectSubset<T, characterCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Character.
     * @param {characterDeleteArgs} args - Arguments to delete one Character.
     * @example
     * // Delete one Character
     * const Character = await prisma.character.delete({
     *   where: {
     *     // ... filter to delete one Character
     *   }
     * })
     * 
    **/
    delete<T extends characterDeleteArgs>(
      args: SelectSubset<T, characterDeleteArgs>
    ): CheckSelect<T, Prisma__characterClient<character>, Prisma__characterClient<characterGetPayload<T>>>

    /**
     * Update one Character.
     * @param {characterUpdateArgs} args - Arguments to update one Character.
     * @example
     * // Update one Character
     * const character = await prisma.character.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends characterUpdateArgs>(
      args: SelectSubset<T, characterUpdateArgs>
    ): CheckSelect<T, Prisma__characterClient<character>, Prisma__characterClient<characterGetPayload<T>>>

    /**
     * Delete zero or more Characters.
     * @param {characterDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.character.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends characterDeleteManyArgs>(
      args?: SelectSubset<T, characterDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {characterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends characterUpdateManyArgs>(
      args: SelectSubset<T, characterUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Character.
     * @param {characterUpsertArgs} args - Arguments to update or create a Character.
     * @example
     * // Update or create a Character
     * const character = await prisma.character.upsert({
     *   create: {
     *     // ... data to create a Character
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character we want to update
     *   }
     * })
    **/
    upsert<T extends characterUpsertArgs>(
      args: SelectSubset<T, characterUpsertArgs>
    ): CheckSelect<T, Prisma__characterClient<character>, Prisma__characterClient<characterGetPayload<T>>>

    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {characterCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.character.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends characterCountArgs>(
      args?: Subset<T, characterCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterAggregateArgs>(args: Subset<T, CharacterAggregateArgs>): PrismaPromise<GetCharacterAggregateType<T>>

    /**
     * Group by Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterGroupByArgs['orderBy'] }
        : { orderBy?: CharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for character.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__characterClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    character_rank_bonus<T extends character_rank_bonusFindManyArgs = {}>(args?: Subset<T, character_rank_bonusFindManyArgs>): CheckSelect<T, PrismaPromise<Array<character_rank_bonus>>, PrismaPromise<Array<character_rank_bonusGetPayload<T>>>>;

    costume<T extends costumeFindManyArgs = {}>(args?: Subset<T, costumeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<costume>>, PrismaPromise<Array<costumeGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * character findUnique
   */
  export type characterFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the character
     * 
    **/
    select?: characterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: characterInclude | null
    /**
     * Throw an Error if a character can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which character to fetch.
     * 
    **/
    where: characterWhereUniqueInput
  }


  /**
   * character findFirst
   */
  export type characterFindFirstArgs = {
    /**
     * Select specific fields to fetch from the character
     * 
    **/
    select?: characterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: characterInclude | null
    /**
     * Throw an Error if a character can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which character to fetch.
     * 
    **/
    where?: characterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characters to fetch.
     * 
    **/
    orderBy?: Enumerable<characterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for characters.
     * 
    **/
    cursor?: characterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of characters.
     * 
    **/
    distinct?: Enumerable<CharacterScalarFieldEnum>
  }


  /**
   * character findMany
   */
  export type characterFindManyArgs = {
    /**
     * Select specific fields to fetch from the character
     * 
    **/
    select?: characterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: characterInclude | null
    /**
     * Filter, which characters to fetch.
     * 
    **/
    where?: characterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characters to fetch.
     * 
    **/
    orderBy?: Enumerable<characterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing characters.
     * 
    **/
    cursor?: characterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characters.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CharacterScalarFieldEnum>
  }


  /**
   * character create
   */
  export type characterCreateArgs = {
    /**
     * Select specific fields to fetch from the character
     * 
    **/
    select?: characterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: characterInclude | null
    /**
     * The data needed to create a character.
     * 
    **/
    data: XOR<characterCreateInput, characterUncheckedCreateInput>
  }


  /**
   * character createMany
   */
  export type characterCreateManyArgs = {
    /**
     * The data used to create many characters.
     * 
    **/
    data: Enumerable<characterCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * character update
   */
  export type characterUpdateArgs = {
    /**
     * Select specific fields to fetch from the character
     * 
    **/
    select?: characterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: characterInclude | null
    /**
     * The data needed to update a character.
     * 
    **/
    data: XOR<characterUpdateInput, characterUncheckedUpdateInput>
    /**
     * Choose, which character to update.
     * 
    **/
    where: characterWhereUniqueInput
  }


  /**
   * character updateMany
   */
  export type characterUpdateManyArgs = {
    /**
     * The data used to update characters.
     * 
    **/
    data: XOR<characterUpdateManyMutationInput, characterUncheckedUpdateManyInput>
    /**
     * Filter which characters to update
     * 
    **/
    where?: characterWhereInput
  }


  /**
   * character upsert
   */
  export type characterUpsertArgs = {
    /**
     * Select specific fields to fetch from the character
     * 
    **/
    select?: characterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: characterInclude | null
    /**
     * The filter to search for the character to update in case it exists.
     * 
    **/
    where: characterWhereUniqueInput
    /**
     * In case the character found by the `where` argument doesn't exist, create a new character with this data.
     * 
    **/
    create: XOR<characterCreateInput, characterUncheckedCreateInput>
    /**
     * In case the character was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<characterUpdateInput, characterUncheckedUpdateInput>
  }


  /**
   * character delete
   */
  export type characterDeleteArgs = {
    /**
     * Select specific fields to fetch from the character
     * 
    **/
    select?: characterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: characterInclude | null
    /**
     * Filter which character to delete.
     * 
    **/
    where: characterWhereUniqueInput
  }


  /**
   * character deleteMany
   */
  export type characterDeleteManyArgs = {
    /**
     * Filter which characters to delete
     * 
    **/
    where?: characterWhereInput
  }


  /**
   * character without action
   */
  export type characterArgs = {
    /**
     * Select specific fields to fetch from the character
     * 
    **/
    select?: characterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: characterInclude | null
  }



  /**
   * Model character_rank_bonus
   */


  export type AggregateCharacter_rank_bonus = {
    _count: Character_rank_bonusCountAggregateOutputType | null
    _avg: Character_rank_bonusAvgAggregateOutputType | null
    _sum: Character_rank_bonusSumAggregateOutputType | null
    _min: Character_rank_bonusMinAggregateOutputType | null
    _max: Character_rank_bonusMaxAggregateOutputType | null
  }

  export type Character_rank_bonusAvgAggregateOutputType = {
    rank_bonus_id: number | null
    rank_bonus_level: number | null
    character_id: number | null
    amount: number | null
  }

  export type Character_rank_bonusSumAggregateOutputType = {
    rank_bonus_id: number | null
    rank_bonus_level: number | null
    character_id: number | null
    amount: number | null
  }

  export type Character_rank_bonusMinAggregateOutputType = {
    rank_bonus_id: number | null
    rank_bonus_level: number | null
    character_id: number | null
    description: string | null
    stat: string | null
    type: string | null
    amount: number | null
  }

  export type Character_rank_bonusMaxAggregateOutputType = {
    rank_bonus_id: number | null
    rank_bonus_level: number | null
    character_id: number | null
    description: string | null
    stat: string | null
    type: string | null
    amount: number | null
  }

  export type Character_rank_bonusCountAggregateOutputType = {
    rank_bonus_id: number
    rank_bonus_level: number
    character_id: number
    description: number
    stat: number
    type: number
    amount: number
    _all: number
  }


  export type Character_rank_bonusAvgAggregateInputType = {
    rank_bonus_id?: true
    rank_bonus_level?: true
    character_id?: true
    amount?: true
  }

  export type Character_rank_bonusSumAggregateInputType = {
    rank_bonus_id?: true
    rank_bonus_level?: true
    character_id?: true
    amount?: true
  }

  export type Character_rank_bonusMinAggregateInputType = {
    rank_bonus_id?: true
    rank_bonus_level?: true
    character_id?: true
    description?: true
    stat?: true
    type?: true
    amount?: true
  }

  export type Character_rank_bonusMaxAggregateInputType = {
    rank_bonus_id?: true
    rank_bonus_level?: true
    character_id?: true
    description?: true
    stat?: true
    type?: true
    amount?: true
  }

  export type Character_rank_bonusCountAggregateInputType = {
    rank_bonus_id?: true
    rank_bonus_level?: true
    character_id?: true
    description?: true
    stat?: true
    type?: true
    amount?: true
    _all?: true
  }

  export type Character_rank_bonusAggregateArgs = {
    /**
     * Filter which character_rank_bonus to aggregate.
     * 
    **/
    where?: character_rank_bonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_rank_bonuses to fetch.
     * 
    **/
    orderBy?: Enumerable<character_rank_bonusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: character_rank_bonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_rank_bonuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_rank_bonuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned character_rank_bonuses
    **/
    _count?: true | Character_rank_bonusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Character_rank_bonusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Character_rank_bonusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Character_rank_bonusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Character_rank_bonusMaxAggregateInputType
  }

  export type GetCharacter_rank_bonusAggregateType<T extends Character_rank_bonusAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter_rank_bonus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter_rank_bonus[P]>
      : GetScalarType<T[P], AggregateCharacter_rank_bonus[P]>
  }




  export type Character_rank_bonusGroupByArgs = {
    where?: character_rank_bonusWhereInput
    orderBy?: Enumerable<character_rank_bonusOrderByWithAggregationInput>
    by: Array<Character_rank_bonusScalarFieldEnum>
    having?: character_rank_bonusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Character_rank_bonusCountAggregateInputType | true
    _avg?: Character_rank_bonusAvgAggregateInputType
    _sum?: Character_rank_bonusSumAggregateInputType
    _min?: Character_rank_bonusMinAggregateInputType
    _max?: Character_rank_bonusMaxAggregateInputType
  }


  export type Character_rank_bonusGroupByOutputType = {
    rank_bonus_id: number
    rank_bonus_level: number
    character_id: number
    description: string | null
    stat: string | null
    type: string | null
    amount: number
    _count: Character_rank_bonusCountAggregateOutputType | null
    _avg: Character_rank_bonusAvgAggregateOutputType | null
    _sum: Character_rank_bonusSumAggregateOutputType | null
    _min: Character_rank_bonusMinAggregateOutputType | null
    _max: Character_rank_bonusMaxAggregateOutputType | null
  }

  type GetCharacter_rank_bonusGroupByPayload<T extends Character_rank_bonusGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Character_rank_bonusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Character_rank_bonusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Character_rank_bonusGroupByOutputType[P]>
            : GetScalarType<T[P], Character_rank_bonusGroupByOutputType[P]>
        }
      >
    >


  export type character_rank_bonusSelect = {
    rank_bonus_id?: boolean
    rank_bonus_level?: boolean
    character_id?: boolean
    description?: boolean
    stat?: boolean
    type?: boolean
    amount?: boolean
    character?: boolean | characterArgs
  }

  export type character_rank_bonusInclude = {
    character?: boolean | characterArgs
  }

  export type character_rank_bonusGetPayload<
    S extends boolean | null | undefined | character_rank_bonusArgs,
    U = keyof S
      > = S extends true
        ? character_rank_bonus
    : S extends undefined
    ? never
    : S extends character_rank_bonusArgs | character_rank_bonusFindManyArgs
    ?'include' extends U
    ? character_rank_bonus  & {
    [P in TrueKeys<S['include']>]:
        P extends 'character' ? characterGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'character' ? characterGetPayload<S['select'][P]> :  P extends keyof character_rank_bonus ? character_rank_bonus[P] : never
  } 
    : character_rank_bonus
  : character_rank_bonus


  type character_rank_bonusCountArgs = Merge<
    Omit<character_rank_bonusFindManyArgs, 'select' | 'include'> & {
      select?: Character_rank_bonusCountAggregateInputType | true
    }
  >

  export interface character_rank_bonusDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Character_rank_bonus that matches the filter.
     * @param {character_rank_bonusFindUniqueArgs} args - Arguments to find a Character_rank_bonus
     * @example
     * // Get one Character_rank_bonus
     * const character_rank_bonus = await prisma.character_rank_bonus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends character_rank_bonusFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, character_rank_bonusFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'character_rank_bonus'> extends True ? CheckSelect<T, Prisma__character_rank_bonusClient<character_rank_bonus>, Prisma__character_rank_bonusClient<character_rank_bonusGetPayload<T>>> : CheckSelect<T, Prisma__character_rank_bonusClient<character_rank_bonus | null >, Prisma__character_rank_bonusClient<character_rank_bonusGetPayload<T> | null >>

    /**
     * Find the first Character_rank_bonus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_rank_bonusFindFirstArgs} args - Arguments to find a Character_rank_bonus
     * @example
     * // Get one Character_rank_bonus
     * const character_rank_bonus = await prisma.character_rank_bonus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends character_rank_bonusFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, character_rank_bonusFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'character_rank_bonus'> extends True ? CheckSelect<T, Prisma__character_rank_bonusClient<character_rank_bonus>, Prisma__character_rank_bonusClient<character_rank_bonusGetPayload<T>>> : CheckSelect<T, Prisma__character_rank_bonusClient<character_rank_bonus | null >, Prisma__character_rank_bonusClient<character_rank_bonusGetPayload<T> | null >>

    /**
     * Find zero or more Character_rank_bonuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_rank_bonusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Character_rank_bonuses
     * const character_rank_bonuses = await prisma.character_rank_bonus.findMany()
     * 
     * // Get first 10 Character_rank_bonuses
     * const character_rank_bonuses = await prisma.character_rank_bonus.findMany({ take: 10 })
     * 
     * // Only select the `rank_bonus_id`
     * const character_rank_bonusWithRank_bonus_idOnly = await prisma.character_rank_bonus.findMany({ select: { rank_bonus_id: true } })
     * 
    **/
    findMany<T extends character_rank_bonusFindManyArgs>(
      args?: SelectSubset<T, character_rank_bonusFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<character_rank_bonus>>, PrismaPromise<Array<character_rank_bonusGetPayload<T>>>>

    /**
     * Create a Character_rank_bonus.
     * @param {character_rank_bonusCreateArgs} args - Arguments to create a Character_rank_bonus.
     * @example
     * // Create one Character_rank_bonus
     * const Character_rank_bonus = await prisma.character_rank_bonus.create({
     *   data: {
     *     // ... data to create a Character_rank_bonus
     *   }
     * })
     * 
    **/
    create<T extends character_rank_bonusCreateArgs>(
      args: SelectSubset<T, character_rank_bonusCreateArgs>
    ): CheckSelect<T, Prisma__character_rank_bonusClient<character_rank_bonus>, Prisma__character_rank_bonusClient<character_rank_bonusGetPayload<T>>>

    /**
     * Create many Character_rank_bonuses.
     *     @param {character_rank_bonusCreateManyArgs} args - Arguments to create many Character_rank_bonuses.
     *     @example
     *     // Create many Character_rank_bonuses
     *     const character_rank_bonus = await prisma.character_rank_bonus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends character_rank_bonusCreateManyArgs>(
      args?: SelectSubset<T, character_rank_bonusCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Character_rank_bonus.
     * @param {character_rank_bonusDeleteArgs} args - Arguments to delete one Character_rank_bonus.
     * @example
     * // Delete one Character_rank_bonus
     * const Character_rank_bonus = await prisma.character_rank_bonus.delete({
     *   where: {
     *     // ... filter to delete one Character_rank_bonus
     *   }
     * })
     * 
    **/
    delete<T extends character_rank_bonusDeleteArgs>(
      args: SelectSubset<T, character_rank_bonusDeleteArgs>
    ): CheckSelect<T, Prisma__character_rank_bonusClient<character_rank_bonus>, Prisma__character_rank_bonusClient<character_rank_bonusGetPayload<T>>>

    /**
     * Update one Character_rank_bonus.
     * @param {character_rank_bonusUpdateArgs} args - Arguments to update one Character_rank_bonus.
     * @example
     * // Update one Character_rank_bonus
     * const character_rank_bonus = await prisma.character_rank_bonus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends character_rank_bonusUpdateArgs>(
      args: SelectSubset<T, character_rank_bonusUpdateArgs>
    ): CheckSelect<T, Prisma__character_rank_bonusClient<character_rank_bonus>, Prisma__character_rank_bonusClient<character_rank_bonusGetPayload<T>>>

    /**
     * Delete zero or more Character_rank_bonuses.
     * @param {character_rank_bonusDeleteManyArgs} args - Arguments to filter Character_rank_bonuses to delete.
     * @example
     * // Delete a few Character_rank_bonuses
     * const { count } = await prisma.character_rank_bonus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends character_rank_bonusDeleteManyArgs>(
      args?: SelectSubset<T, character_rank_bonusDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_rank_bonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_rank_bonusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Character_rank_bonuses
     * const character_rank_bonus = await prisma.character_rank_bonus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends character_rank_bonusUpdateManyArgs>(
      args: SelectSubset<T, character_rank_bonusUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Character_rank_bonus.
     * @param {character_rank_bonusUpsertArgs} args - Arguments to update or create a Character_rank_bonus.
     * @example
     * // Update or create a Character_rank_bonus
     * const character_rank_bonus = await prisma.character_rank_bonus.upsert({
     *   create: {
     *     // ... data to create a Character_rank_bonus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character_rank_bonus we want to update
     *   }
     * })
    **/
    upsert<T extends character_rank_bonusUpsertArgs>(
      args: SelectSubset<T, character_rank_bonusUpsertArgs>
    ): CheckSelect<T, Prisma__character_rank_bonusClient<character_rank_bonus>, Prisma__character_rank_bonusClient<character_rank_bonusGetPayload<T>>>

    /**
     * Count the number of Character_rank_bonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_rank_bonusCountArgs} args - Arguments to filter Character_rank_bonuses to count.
     * @example
     * // Count the number of Character_rank_bonuses
     * const count = await prisma.character_rank_bonus.count({
     *   where: {
     *     // ... the filter for the Character_rank_bonuses we want to count
     *   }
     * })
    **/
    count<T extends character_rank_bonusCountArgs>(
      args?: Subset<T, character_rank_bonusCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Character_rank_bonusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character_rank_bonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_rank_bonusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Character_rank_bonusAggregateArgs>(args: Subset<T, Character_rank_bonusAggregateArgs>): PrismaPromise<GetCharacter_rank_bonusAggregateType<T>>

    /**
     * Group by Character_rank_bonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_rank_bonusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Character_rank_bonusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Character_rank_bonusGroupByArgs['orderBy'] }
        : { orderBy?: Character_rank_bonusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Character_rank_bonusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacter_rank_bonusGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for character_rank_bonus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__character_rank_bonusClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    character<T extends characterArgs = {}>(args?: Subset<T, characterArgs>): CheckSelect<T, Prisma__characterClient<character | null >, Prisma__characterClient<characterGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * character_rank_bonus findUnique
   */
  export type character_rank_bonusFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the character_rank_bonus
     * 
    **/
    select?: character_rank_bonusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: character_rank_bonusInclude | null
    /**
     * Throw an Error if a character_rank_bonus can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which character_rank_bonus to fetch.
     * 
    **/
    where: character_rank_bonusWhereUniqueInput
  }


  /**
   * character_rank_bonus findFirst
   */
  export type character_rank_bonusFindFirstArgs = {
    /**
     * Select specific fields to fetch from the character_rank_bonus
     * 
    **/
    select?: character_rank_bonusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: character_rank_bonusInclude | null
    /**
     * Throw an Error if a character_rank_bonus can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which character_rank_bonus to fetch.
     * 
    **/
    where?: character_rank_bonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_rank_bonuses to fetch.
     * 
    **/
    orderBy?: Enumerable<character_rank_bonusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_rank_bonuses.
     * 
    **/
    cursor?: character_rank_bonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_rank_bonuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_rank_bonuses.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_rank_bonuses.
     * 
    **/
    distinct?: Enumerable<Character_rank_bonusScalarFieldEnum>
  }


  /**
   * character_rank_bonus findMany
   */
  export type character_rank_bonusFindManyArgs = {
    /**
     * Select specific fields to fetch from the character_rank_bonus
     * 
    **/
    select?: character_rank_bonusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: character_rank_bonusInclude | null
    /**
     * Filter, which character_rank_bonuses to fetch.
     * 
    **/
    where?: character_rank_bonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_rank_bonuses to fetch.
     * 
    **/
    orderBy?: Enumerable<character_rank_bonusOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing character_rank_bonuses.
     * 
    **/
    cursor?: character_rank_bonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_rank_bonuses from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_rank_bonuses.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Character_rank_bonusScalarFieldEnum>
  }


  /**
   * character_rank_bonus create
   */
  export type character_rank_bonusCreateArgs = {
    /**
     * Select specific fields to fetch from the character_rank_bonus
     * 
    **/
    select?: character_rank_bonusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: character_rank_bonusInclude | null
    /**
     * The data needed to create a character_rank_bonus.
     * 
    **/
    data: XOR<character_rank_bonusCreateInput, character_rank_bonusUncheckedCreateInput>
  }


  /**
   * character_rank_bonus createMany
   */
  export type character_rank_bonusCreateManyArgs = {
    /**
     * The data used to create many character_rank_bonuses.
     * 
    **/
    data: Enumerable<character_rank_bonusCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * character_rank_bonus update
   */
  export type character_rank_bonusUpdateArgs = {
    /**
     * Select specific fields to fetch from the character_rank_bonus
     * 
    **/
    select?: character_rank_bonusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: character_rank_bonusInclude | null
    /**
     * The data needed to update a character_rank_bonus.
     * 
    **/
    data: XOR<character_rank_bonusUpdateInput, character_rank_bonusUncheckedUpdateInput>
    /**
     * Choose, which character_rank_bonus to update.
     * 
    **/
    where: character_rank_bonusWhereUniqueInput
  }


  /**
   * character_rank_bonus updateMany
   */
  export type character_rank_bonusUpdateManyArgs = {
    /**
     * The data used to update character_rank_bonuses.
     * 
    **/
    data: XOR<character_rank_bonusUpdateManyMutationInput, character_rank_bonusUncheckedUpdateManyInput>
    /**
     * Filter which character_rank_bonuses to update
     * 
    **/
    where?: character_rank_bonusWhereInput
  }


  /**
   * character_rank_bonus upsert
   */
  export type character_rank_bonusUpsertArgs = {
    /**
     * Select specific fields to fetch from the character_rank_bonus
     * 
    **/
    select?: character_rank_bonusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: character_rank_bonusInclude | null
    /**
     * The filter to search for the character_rank_bonus to update in case it exists.
     * 
    **/
    where: character_rank_bonusWhereUniqueInput
    /**
     * In case the character_rank_bonus found by the `where` argument doesn't exist, create a new character_rank_bonus with this data.
     * 
    **/
    create: XOR<character_rank_bonusCreateInput, character_rank_bonusUncheckedCreateInput>
    /**
     * In case the character_rank_bonus was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<character_rank_bonusUpdateInput, character_rank_bonusUncheckedUpdateInput>
  }


  /**
   * character_rank_bonus delete
   */
  export type character_rank_bonusDeleteArgs = {
    /**
     * Select specific fields to fetch from the character_rank_bonus
     * 
    **/
    select?: character_rank_bonusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: character_rank_bonusInclude | null
    /**
     * Filter which character_rank_bonus to delete.
     * 
    **/
    where: character_rank_bonusWhereUniqueInput
  }


  /**
   * character_rank_bonus deleteMany
   */
  export type character_rank_bonusDeleteManyArgs = {
    /**
     * Filter which character_rank_bonuses to delete
     * 
    **/
    where?: character_rank_bonusWhereInput
  }


  /**
   * character_rank_bonus without action
   */
  export type character_rank_bonusArgs = {
    /**
     * Select specific fields to fetch from the character_rank_bonus
     * 
    **/
    select?: character_rank_bonusSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: character_rank_bonusInclude | null
  }



  /**
   * Model companion
   */


  export type AggregateCompanion = {
    _count: CompanionCountAggregateOutputType | null
    _avg: CompanionAvgAggregateOutputType | null
    _sum: CompanionSumAggregateOutputType | null
    _min: CompanionMinAggregateOutputType | null
    _max: CompanionMaxAggregateOutputType | null
  }

  export type CompanionAvgAggregateOutputType = {
    companion_id: number | null
  }

  export type CompanionSumAggregateOutputType = {
    companion_id: number | null
  }

  export type CompanionMinAggregateOutputType = {
    companion_id: number | null
    attribute: string | null
    type: string | null
    release_time: Date | null
    name: string | null
    story: string | null
    image_path_base: string | null
  }

  export type CompanionMaxAggregateOutputType = {
    companion_id: number | null
    attribute: string | null
    type: string | null
    release_time: Date | null
    name: string | null
    story: string | null
    image_path_base: string | null
  }

  export type CompanionCountAggregateOutputType = {
    companion_id: number
    attribute: number
    type: number
    release_time: number
    name: number
    story: number
    image_path_base: number
    _all: number
  }


  export type CompanionAvgAggregateInputType = {
    companion_id?: true
  }

  export type CompanionSumAggregateInputType = {
    companion_id?: true
  }

  export type CompanionMinAggregateInputType = {
    companion_id?: true
    attribute?: true
    type?: true
    release_time?: true
    name?: true
    story?: true
    image_path_base?: true
  }

  export type CompanionMaxAggregateInputType = {
    companion_id?: true
    attribute?: true
    type?: true
    release_time?: true
    name?: true
    story?: true
    image_path_base?: true
  }

  export type CompanionCountAggregateInputType = {
    companion_id?: true
    attribute?: true
    type?: true
    release_time?: true
    name?: true
    story?: true
    image_path_base?: true
    _all?: true
  }

  export type CompanionAggregateArgs = {
    /**
     * Filter which companion to aggregate.
     * 
    **/
    where?: companionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companions to fetch.
     * 
    **/
    orderBy?: Enumerable<companionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: companionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companions
    **/
    _count?: true | CompanionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanionMaxAggregateInputType
  }

  export type GetCompanionAggregateType<T extends CompanionAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanion[P]>
      : GetScalarType<T[P], AggregateCompanion[P]>
  }




  export type CompanionGroupByArgs = {
    where?: companionWhereInput
    orderBy?: Enumerable<companionOrderByWithAggregationInput>
    by: Array<CompanionScalarFieldEnum>
    having?: companionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanionCountAggregateInputType | true
    _avg?: CompanionAvgAggregateInputType
    _sum?: CompanionSumAggregateInputType
    _min?: CompanionMinAggregateInputType
    _max?: CompanionMaxAggregateInputType
  }


  export type CompanionGroupByOutputType = {
    companion_id: number
    attribute: string | null
    type: string | null
    release_time: Date
    name: string | null
    story: string | null
    image_path_base: string | null
    _count: CompanionCountAggregateOutputType | null
    _avg: CompanionAvgAggregateOutputType | null
    _sum: CompanionSumAggregateOutputType | null
    _min: CompanionMinAggregateOutputType | null
    _max: CompanionMaxAggregateOutputType | null
  }

  type GetCompanionGroupByPayload<T extends CompanionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CompanionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanionGroupByOutputType[P]>
            : GetScalarType<T[P], CompanionGroupByOutputType[P]>
        }
      >
    >


  export type companionSelect = {
    companion_id?: boolean
    attribute?: boolean
    type?: boolean
    release_time?: boolean
    name?: boolean
    story?: boolean
    image_path_base?: boolean
    companion_ability_link?: boolean | companion_ability_linkFindManyArgs
    companion_skill_link?: boolean | companion_skill_linkFindManyArgs
    companion_stat?: boolean | companion_statFindManyArgs
    _count?: boolean | CompanionCountOutputTypeArgs
  }

  export type companionInclude = {
    companion_ability_link?: boolean | companion_ability_linkFindManyArgs
    companion_skill_link?: boolean | companion_skill_linkFindManyArgs
    companion_stat?: boolean | companion_statFindManyArgs
    _count?: boolean | CompanionCountOutputTypeArgs
  }

  export type companionGetPayload<
    S extends boolean | null | undefined | companionArgs,
    U = keyof S
      > = S extends true
        ? companion
    : S extends undefined
    ? never
    : S extends companionArgs | companionFindManyArgs
    ?'include' extends U
    ? companion  & {
    [P in TrueKeys<S['include']>]:
        P extends 'companion_ability_link' ? Array < companion_ability_linkGetPayload<S['include'][P]>>  :
        P extends 'companion_skill_link' ? Array < companion_skill_linkGetPayload<S['include'][P]>>  :
        P extends 'companion_stat' ? Array < companion_statGetPayload<S['include'][P]>>  :
        P extends '_count' ? CompanionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'companion_ability_link' ? Array < companion_ability_linkGetPayload<S['select'][P]>>  :
        P extends 'companion_skill_link' ? Array < companion_skill_linkGetPayload<S['select'][P]>>  :
        P extends 'companion_stat' ? Array < companion_statGetPayload<S['select'][P]>>  :
        P extends '_count' ? CompanionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof companion ? companion[P] : never
  } 
    : companion
  : companion


  type companionCountArgs = Merge<
    Omit<companionFindManyArgs, 'select' | 'include'> & {
      select?: CompanionCountAggregateInputType | true
    }
  >

  export interface companionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Companion that matches the filter.
     * @param {companionFindUniqueArgs} args - Arguments to find a Companion
     * @example
     * // Get one Companion
     * const companion = await prisma.companion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends companionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, companionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'companion'> extends True ? CheckSelect<T, Prisma__companionClient<companion>, Prisma__companionClient<companionGetPayload<T>>> : CheckSelect<T, Prisma__companionClient<companion | null >, Prisma__companionClient<companionGetPayload<T> | null >>

    /**
     * Find the first Companion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companionFindFirstArgs} args - Arguments to find a Companion
     * @example
     * // Get one Companion
     * const companion = await prisma.companion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends companionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, companionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'companion'> extends True ? CheckSelect<T, Prisma__companionClient<companion>, Prisma__companionClient<companionGetPayload<T>>> : CheckSelect<T, Prisma__companionClient<companion | null >, Prisma__companionClient<companionGetPayload<T> | null >>

    /**
     * Find zero or more Companions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companions
     * const companions = await prisma.companion.findMany()
     * 
     * // Get first 10 Companions
     * const companions = await prisma.companion.findMany({ take: 10 })
     * 
     * // Only select the `companion_id`
     * const companionWithCompanion_idOnly = await prisma.companion.findMany({ select: { companion_id: true } })
     * 
    **/
    findMany<T extends companionFindManyArgs>(
      args?: SelectSubset<T, companionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<companion>>, PrismaPromise<Array<companionGetPayload<T>>>>

    /**
     * Create a Companion.
     * @param {companionCreateArgs} args - Arguments to create a Companion.
     * @example
     * // Create one Companion
     * const Companion = await prisma.companion.create({
     *   data: {
     *     // ... data to create a Companion
     *   }
     * })
     * 
    **/
    create<T extends companionCreateArgs>(
      args: SelectSubset<T, companionCreateArgs>
    ): CheckSelect<T, Prisma__companionClient<companion>, Prisma__companionClient<companionGetPayload<T>>>

    /**
     * Create many Companions.
     *     @param {companionCreateManyArgs} args - Arguments to create many Companions.
     *     @example
     *     // Create many Companions
     *     const companion = await prisma.companion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends companionCreateManyArgs>(
      args?: SelectSubset<T, companionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Companion.
     * @param {companionDeleteArgs} args - Arguments to delete one Companion.
     * @example
     * // Delete one Companion
     * const Companion = await prisma.companion.delete({
     *   where: {
     *     // ... filter to delete one Companion
     *   }
     * })
     * 
    **/
    delete<T extends companionDeleteArgs>(
      args: SelectSubset<T, companionDeleteArgs>
    ): CheckSelect<T, Prisma__companionClient<companion>, Prisma__companionClient<companionGetPayload<T>>>

    /**
     * Update one Companion.
     * @param {companionUpdateArgs} args - Arguments to update one Companion.
     * @example
     * // Update one Companion
     * const companion = await prisma.companion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends companionUpdateArgs>(
      args: SelectSubset<T, companionUpdateArgs>
    ): CheckSelect<T, Prisma__companionClient<companion>, Prisma__companionClient<companionGetPayload<T>>>

    /**
     * Delete zero or more Companions.
     * @param {companionDeleteManyArgs} args - Arguments to filter Companions to delete.
     * @example
     * // Delete a few Companions
     * const { count } = await prisma.companion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends companionDeleteManyArgs>(
      args?: SelectSubset<T, companionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companions
     * const companion = await prisma.companion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends companionUpdateManyArgs>(
      args: SelectSubset<T, companionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Companion.
     * @param {companionUpsertArgs} args - Arguments to update or create a Companion.
     * @example
     * // Update or create a Companion
     * const companion = await prisma.companion.upsert({
     *   create: {
     *     // ... data to create a Companion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companion we want to update
     *   }
     * })
    **/
    upsert<T extends companionUpsertArgs>(
      args: SelectSubset<T, companionUpsertArgs>
    ): CheckSelect<T, Prisma__companionClient<companion>, Prisma__companionClient<companionGetPayload<T>>>

    /**
     * Count the number of Companions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companionCountArgs} args - Arguments to filter Companions to count.
     * @example
     * // Count the number of Companions
     * const count = await prisma.companion.count({
     *   where: {
     *     // ... the filter for the Companions we want to count
     *   }
     * })
    **/
    count<T extends companionCountArgs>(
      args?: Subset<T, companionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanionAggregateArgs>(args: Subset<T, CompanionAggregateArgs>): PrismaPromise<GetCompanionAggregateType<T>>

    /**
     * Group by Companion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanionGroupByArgs['orderBy'] }
        : { orderBy?: CompanionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for companion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__companionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companion_ability_link<T extends companion_ability_linkFindManyArgs = {}>(args?: Subset<T, companion_ability_linkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<companion_ability_link>>, PrismaPromise<Array<companion_ability_linkGetPayload<T>>>>;

    companion_skill_link<T extends companion_skill_linkFindManyArgs = {}>(args?: Subset<T, companion_skill_linkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<companion_skill_link>>, PrismaPromise<Array<companion_skill_linkGetPayload<T>>>>;

    companion_stat<T extends companion_statFindManyArgs = {}>(args?: Subset<T, companion_statFindManyArgs>): CheckSelect<T, PrismaPromise<Array<companion_stat>>, PrismaPromise<Array<companion_statGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * companion findUnique
   */
  export type companionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the companion
     * 
    **/
    select?: companionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companionInclude | null
    /**
     * Throw an Error if a companion can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which companion to fetch.
     * 
    **/
    where: companionWhereUniqueInput
  }


  /**
   * companion findFirst
   */
  export type companionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the companion
     * 
    **/
    select?: companionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companionInclude | null
    /**
     * Throw an Error if a companion can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which companion to fetch.
     * 
    **/
    where?: companionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companions to fetch.
     * 
    **/
    orderBy?: Enumerable<companionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companions.
     * 
    **/
    cursor?: companionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companions.
     * 
    **/
    distinct?: Enumerable<CompanionScalarFieldEnum>
  }


  /**
   * companion findMany
   */
  export type companionFindManyArgs = {
    /**
     * Select specific fields to fetch from the companion
     * 
    **/
    select?: companionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companionInclude | null
    /**
     * Filter, which companions to fetch.
     * 
    **/
    where?: companionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companions to fetch.
     * 
    **/
    orderBy?: Enumerable<companionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companions.
     * 
    **/
    cursor?: companionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CompanionScalarFieldEnum>
  }


  /**
   * companion create
   */
  export type companionCreateArgs = {
    /**
     * Select specific fields to fetch from the companion
     * 
    **/
    select?: companionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companionInclude | null
    /**
     * The data needed to create a companion.
     * 
    **/
    data: XOR<companionCreateInput, companionUncheckedCreateInput>
  }


  /**
   * companion createMany
   */
  export type companionCreateManyArgs = {
    /**
     * The data used to create many companions.
     * 
    **/
    data: Enumerable<companionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * companion update
   */
  export type companionUpdateArgs = {
    /**
     * Select specific fields to fetch from the companion
     * 
    **/
    select?: companionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companionInclude | null
    /**
     * The data needed to update a companion.
     * 
    **/
    data: XOR<companionUpdateInput, companionUncheckedUpdateInput>
    /**
     * Choose, which companion to update.
     * 
    **/
    where: companionWhereUniqueInput
  }


  /**
   * companion updateMany
   */
  export type companionUpdateManyArgs = {
    /**
     * The data used to update companions.
     * 
    **/
    data: XOR<companionUpdateManyMutationInput, companionUncheckedUpdateManyInput>
    /**
     * Filter which companions to update
     * 
    **/
    where?: companionWhereInput
  }


  /**
   * companion upsert
   */
  export type companionUpsertArgs = {
    /**
     * Select specific fields to fetch from the companion
     * 
    **/
    select?: companionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companionInclude | null
    /**
     * The filter to search for the companion to update in case it exists.
     * 
    **/
    where: companionWhereUniqueInput
    /**
     * In case the companion found by the `where` argument doesn't exist, create a new companion with this data.
     * 
    **/
    create: XOR<companionCreateInput, companionUncheckedCreateInput>
    /**
     * In case the companion was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<companionUpdateInput, companionUncheckedUpdateInput>
  }


  /**
   * companion delete
   */
  export type companionDeleteArgs = {
    /**
     * Select specific fields to fetch from the companion
     * 
    **/
    select?: companionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companionInclude | null
    /**
     * Filter which companion to delete.
     * 
    **/
    where: companionWhereUniqueInput
  }


  /**
   * companion deleteMany
   */
  export type companionDeleteManyArgs = {
    /**
     * Filter which companions to delete
     * 
    **/
    where?: companionWhereInput
  }


  /**
   * companion without action
   */
  export type companionArgs = {
    /**
     * Select specific fields to fetch from the companion
     * 
    **/
    select?: companionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companionInclude | null
  }



  /**
   * Model companion_ability
   */


  export type AggregateCompanion_ability = {
    _count: Companion_abilityCountAggregateOutputType | null
    _avg: Companion_abilityAvgAggregateOutputType | null
    _sum: Companion_abilitySumAggregateOutputType | null
    _min: Companion_abilityMinAggregateOutputType | null
    _max: Companion_abilityMaxAggregateOutputType | null
  }

  export type Companion_abilityAvgAggregateOutputType = {
    ability_id: number | null
    ability_level: number | null
  }

  export type Companion_abilitySumAggregateOutputType = {
    ability_id: number | null
    ability_level: number | null
  }

  export type Companion_abilityMinAggregateOutputType = {
    ability_id: number | null
    ability_level: number | null
    name: string | null
    description: string | null
    image_path_base: string | null
  }

  export type Companion_abilityMaxAggregateOutputType = {
    ability_id: number | null
    ability_level: number | null
    name: string | null
    description: string | null
    image_path_base: string | null
  }

  export type Companion_abilityCountAggregateOutputType = {
    ability_id: number
    ability_level: number
    name: number
    description: number
    image_path_base: number
    _all: number
  }


  export type Companion_abilityAvgAggregateInputType = {
    ability_id?: true
    ability_level?: true
  }

  export type Companion_abilitySumAggregateInputType = {
    ability_id?: true
    ability_level?: true
  }

  export type Companion_abilityMinAggregateInputType = {
    ability_id?: true
    ability_level?: true
    name?: true
    description?: true
    image_path_base?: true
  }

  export type Companion_abilityMaxAggregateInputType = {
    ability_id?: true
    ability_level?: true
    name?: true
    description?: true
    image_path_base?: true
  }

  export type Companion_abilityCountAggregateInputType = {
    ability_id?: true
    ability_level?: true
    name?: true
    description?: true
    image_path_base?: true
    _all?: true
  }

  export type Companion_abilityAggregateArgs = {
    /**
     * Filter which companion_ability to aggregate.
     * 
    **/
    where?: companion_abilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companion_abilities to fetch.
     * 
    **/
    orderBy?: Enumerable<companion_abilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: companion_abilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companion_abilities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companion_abilities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companion_abilities
    **/
    _count?: true | Companion_abilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Companion_abilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Companion_abilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Companion_abilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Companion_abilityMaxAggregateInputType
  }

  export type GetCompanion_abilityAggregateType<T extends Companion_abilityAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanion_ability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanion_ability[P]>
      : GetScalarType<T[P], AggregateCompanion_ability[P]>
  }




  export type Companion_abilityGroupByArgs = {
    where?: companion_abilityWhereInput
    orderBy?: Enumerable<companion_abilityOrderByWithAggregationInput>
    by: Array<Companion_abilityScalarFieldEnum>
    having?: companion_abilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Companion_abilityCountAggregateInputType | true
    _avg?: Companion_abilityAvgAggregateInputType
    _sum?: Companion_abilitySumAggregateInputType
    _min?: Companion_abilityMinAggregateInputType
    _max?: Companion_abilityMaxAggregateInputType
  }


  export type Companion_abilityGroupByOutputType = {
    ability_id: number
    ability_level: number
    name: string | null
    description: string | null
    image_path_base: string | null
    _count: Companion_abilityCountAggregateOutputType | null
    _avg: Companion_abilityAvgAggregateOutputType | null
    _sum: Companion_abilitySumAggregateOutputType | null
    _min: Companion_abilityMinAggregateOutputType | null
    _max: Companion_abilityMaxAggregateOutputType | null
  }

  type GetCompanion_abilityGroupByPayload<T extends Companion_abilityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Companion_abilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Companion_abilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Companion_abilityGroupByOutputType[P]>
            : GetScalarType<T[P], Companion_abilityGroupByOutputType[P]>
        }
      >
    >


  export type companion_abilitySelect = {
    ability_id?: boolean
    ability_level?: boolean
    name?: boolean
    description?: boolean
    image_path_base?: boolean
    companion_ability_link?: boolean | companion_ability_linkFindManyArgs
    _count?: boolean | Companion_abilityCountOutputTypeArgs
  }

  export type companion_abilityInclude = {
    companion_ability_link?: boolean | companion_ability_linkFindManyArgs
    _count?: boolean | Companion_abilityCountOutputTypeArgs
  }

  export type companion_abilityGetPayload<
    S extends boolean | null | undefined | companion_abilityArgs,
    U = keyof S
      > = S extends true
        ? companion_ability
    : S extends undefined
    ? never
    : S extends companion_abilityArgs | companion_abilityFindManyArgs
    ?'include' extends U
    ? companion_ability  & {
    [P in TrueKeys<S['include']>]:
        P extends 'companion_ability_link' ? Array < companion_ability_linkGetPayload<S['include'][P]>>  :
        P extends '_count' ? Companion_abilityCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'companion_ability_link' ? Array < companion_ability_linkGetPayload<S['select'][P]>>  :
        P extends '_count' ? Companion_abilityCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof companion_ability ? companion_ability[P] : never
  } 
    : companion_ability
  : companion_ability


  type companion_abilityCountArgs = Merge<
    Omit<companion_abilityFindManyArgs, 'select' | 'include'> & {
      select?: Companion_abilityCountAggregateInputType | true
    }
  >

  export interface companion_abilityDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Companion_ability that matches the filter.
     * @param {companion_abilityFindUniqueArgs} args - Arguments to find a Companion_ability
     * @example
     * // Get one Companion_ability
     * const companion_ability = await prisma.companion_ability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends companion_abilityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, companion_abilityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'companion_ability'> extends True ? CheckSelect<T, Prisma__companion_abilityClient<companion_ability>, Prisma__companion_abilityClient<companion_abilityGetPayload<T>>> : CheckSelect<T, Prisma__companion_abilityClient<companion_ability | null >, Prisma__companion_abilityClient<companion_abilityGetPayload<T> | null >>

    /**
     * Find the first Companion_ability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_abilityFindFirstArgs} args - Arguments to find a Companion_ability
     * @example
     * // Get one Companion_ability
     * const companion_ability = await prisma.companion_ability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends companion_abilityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, companion_abilityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'companion_ability'> extends True ? CheckSelect<T, Prisma__companion_abilityClient<companion_ability>, Prisma__companion_abilityClient<companion_abilityGetPayload<T>>> : CheckSelect<T, Prisma__companion_abilityClient<companion_ability | null >, Prisma__companion_abilityClient<companion_abilityGetPayload<T> | null >>

    /**
     * Find zero or more Companion_abilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_abilityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companion_abilities
     * const companion_abilities = await prisma.companion_ability.findMany()
     * 
     * // Get first 10 Companion_abilities
     * const companion_abilities = await prisma.companion_ability.findMany({ take: 10 })
     * 
     * // Only select the `ability_id`
     * const companion_abilityWithAbility_idOnly = await prisma.companion_ability.findMany({ select: { ability_id: true } })
     * 
    **/
    findMany<T extends companion_abilityFindManyArgs>(
      args?: SelectSubset<T, companion_abilityFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<companion_ability>>, PrismaPromise<Array<companion_abilityGetPayload<T>>>>

    /**
     * Create a Companion_ability.
     * @param {companion_abilityCreateArgs} args - Arguments to create a Companion_ability.
     * @example
     * // Create one Companion_ability
     * const Companion_ability = await prisma.companion_ability.create({
     *   data: {
     *     // ... data to create a Companion_ability
     *   }
     * })
     * 
    **/
    create<T extends companion_abilityCreateArgs>(
      args: SelectSubset<T, companion_abilityCreateArgs>
    ): CheckSelect<T, Prisma__companion_abilityClient<companion_ability>, Prisma__companion_abilityClient<companion_abilityGetPayload<T>>>

    /**
     * Create many Companion_abilities.
     *     @param {companion_abilityCreateManyArgs} args - Arguments to create many Companion_abilities.
     *     @example
     *     // Create many Companion_abilities
     *     const companion_ability = await prisma.companion_ability.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends companion_abilityCreateManyArgs>(
      args?: SelectSubset<T, companion_abilityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Companion_ability.
     * @param {companion_abilityDeleteArgs} args - Arguments to delete one Companion_ability.
     * @example
     * // Delete one Companion_ability
     * const Companion_ability = await prisma.companion_ability.delete({
     *   where: {
     *     // ... filter to delete one Companion_ability
     *   }
     * })
     * 
    **/
    delete<T extends companion_abilityDeleteArgs>(
      args: SelectSubset<T, companion_abilityDeleteArgs>
    ): CheckSelect<T, Prisma__companion_abilityClient<companion_ability>, Prisma__companion_abilityClient<companion_abilityGetPayload<T>>>

    /**
     * Update one Companion_ability.
     * @param {companion_abilityUpdateArgs} args - Arguments to update one Companion_ability.
     * @example
     * // Update one Companion_ability
     * const companion_ability = await prisma.companion_ability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends companion_abilityUpdateArgs>(
      args: SelectSubset<T, companion_abilityUpdateArgs>
    ): CheckSelect<T, Prisma__companion_abilityClient<companion_ability>, Prisma__companion_abilityClient<companion_abilityGetPayload<T>>>

    /**
     * Delete zero or more Companion_abilities.
     * @param {companion_abilityDeleteManyArgs} args - Arguments to filter Companion_abilities to delete.
     * @example
     * // Delete a few Companion_abilities
     * const { count } = await prisma.companion_ability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends companion_abilityDeleteManyArgs>(
      args?: SelectSubset<T, companion_abilityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companion_abilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_abilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companion_abilities
     * const companion_ability = await prisma.companion_ability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends companion_abilityUpdateManyArgs>(
      args: SelectSubset<T, companion_abilityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Companion_ability.
     * @param {companion_abilityUpsertArgs} args - Arguments to update or create a Companion_ability.
     * @example
     * // Update or create a Companion_ability
     * const companion_ability = await prisma.companion_ability.upsert({
     *   create: {
     *     // ... data to create a Companion_ability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companion_ability we want to update
     *   }
     * })
    **/
    upsert<T extends companion_abilityUpsertArgs>(
      args: SelectSubset<T, companion_abilityUpsertArgs>
    ): CheckSelect<T, Prisma__companion_abilityClient<companion_ability>, Prisma__companion_abilityClient<companion_abilityGetPayload<T>>>

    /**
     * Count the number of Companion_abilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_abilityCountArgs} args - Arguments to filter Companion_abilities to count.
     * @example
     * // Count the number of Companion_abilities
     * const count = await prisma.companion_ability.count({
     *   where: {
     *     // ... the filter for the Companion_abilities we want to count
     *   }
     * })
    **/
    count<T extends companion_abilityCountArgs>(
      args?: Subset<T, companion_abilityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Companion_abilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companion_ability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Companion_abilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Companion_abilityAggregateArgs>(args: Subset<T, Companion_abilityAggregateArgs>): PrismaPromise<GetCompanion_abilityAggregateType<T>>

    /**
     * Group by Companion_ability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Companion_abilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Companion_abilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Companion_abilityGroupByArgs['orderBy'] }
        : { orderBy?: Companion_abilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Companion_abilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanion_abilityGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for companion_ability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__companion_abilityClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companion_ability_link<T extends companion_ability_linkFindManyArgs = {}>(args?: Subset<T, companion_ability_linkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<companion_ability_link>>, PrismaPromise<Array<companion_ability_linkGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * companion_ability findUnique
   */
  export type companion_abilityFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the companion_ability
     * 
    **/
    select?: companion_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_abilityInclude | null
    /**
     * Throw an Error if a companion_ability can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which companion_ability to fetch.
     * 
    **/
    where: companion_abilityWhereUniqueInput
  }


  /**
   * companion_ability findFirst
   */
  export type companion_abilityFindFirstArgs = {
    /**
     * Select specific fields to fetch from the companion_ability
     * 
    **/
    select?: companion_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_abilityInclude | null
    /**
     * Throw an Error if a companion_ability can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which companion_ability to fetch.
     * 
    **/
    where?: companion_abilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companion_abilities to fetch.
     * 
    **/
    orderBy?: Enumerable<companion_abilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companion_abilities.
     * 
    **/
    cursor?: companion_abilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companion_abilities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companion_abilities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companion_abilities.
     * 
    **/
    distinct?: Enumerable<Companion_abilityScalarFieldEnum>
  }


  /**
   * companion_ability findMany
   */
  export type companion_abilityFindManyArgs = {
    /**
     * Select specific fields to fetch from the companion_ability
     * 
    **/
    select?: companion_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_abilityInclude | null
    /**
     * Filter, which companion_abilities to fetch.
     * 
    **/
    where?: companion_abilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companion_abilities to fetch.
     * 
    **/
    orderBy?: Enumerable<companion_abilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companion_abilities.
     * 
    **/
    cursor?: companion_abilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companion_abilities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companion_abilities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Companion_abilityScalarFieldEnum>
  }


  /**
   * companion_ability create
   */
  export type companion_abilityCreateArgs = {
    /**
     * Select specific fields to fetch from the companion_ability
     * 
    **/
    select?: companion_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_abilityInclude | null
    /**
     * The data needed to create a companion_ability.
     * 
    **/
    data: XOR<companion_abilityCreateInput, companion_abilityUncheckedCreateInput>
  }


  /**
   * companion_ability createMany
   */
  export type companion_abilityCreateManyArgs = {
    /**
     * The data used to create many companion_abilities.
     * 
    **/
    data: Enumerable<companion_abilityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * companion_ability update
   */
  export type companion_abilityUpdateArgs = {
    /**
     * Select specific fields to fetch from the companion_ability
     * 
    **/
    select?: companion_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_abilityInclude | null
    /**
     * The data needed to update a companion_ability.
     * 
    **/
    data: XOR<companion_abilityUpdateInput, companion_abilityUncheckedUpdateInput>
    /**
     * Choose, which companion_ability to update.
     * 
    **/
    where: companion_abilityWhereUniqueInput
  }


  /**
   * companion_ability updateMany
   */
  export type companion_abilityUpdateManyArgs = {
    /**
     * The data used to update companion_abilities.
     * 
    **/
    data: XOR<companion_abilityUpdateManyMutationInput, companion_abilityUncheckedUpdateManyInput>
    /**
     * Filter which companion_abilities to update
     * 
    **/
    where?: companion_abilityWhereInput
  }


  /**
   * companion_ability upsert
   */
  export type companion_abilityUpsertArgs = {
    /**
     * Select specific fields to fetch from the companion_ability
     * 
    **/
    select?: companion_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_abilityInclude | null
    /**
     * The filter to search for the companion_ability to update in case it exists.
     * 
    **/
    where: companion_abilityWhereUniqueInput
    /**
     * In case the companion_ability found by the `where` argument doesn't exist, create a new companion_ability with this data.
     * 
    **/
    create: XOR<companion_abilityCreateInput, companion_abilityUncheckedCreateInput>
    /**
     * In case the companion_ability was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<companion_abilityUpdateInput, companion_abilityUncheckedUpdateInput>
  }


  /**
   * companion_ability delete
   */
  export type companion_abilityDeleteArgs = {
    /**
     * Select specific fields to fetch from the companion_ability
     * 
    **/
    select?: companion_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_abilityInclude | null
    /**
     * Filter which companion_ability to delete.
     * 
    **/
    where: companion_abilityWhereUniqueInput
  }


  /**
   * companion_ability deleteMany
   */
  export type companion_abilityDeleteManyArgs = {
    /**
     * Filter which companion_abilities to delete
     * 
    **/
    where?: companion_abilityWhereInput
  }


  /**
   * companion_ability without action
   */
  export type companion_abilityArgs = {
    /**
     * Select specific fields to fetch from the companion_ability
     * 
    **/
    select?: companion_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_abilityInclude | null
  }



  /**
   * Model companion_ability_link
   */


  export type AggregateCompanion_ability_link = {
    _count: Companion_ability_linkCountAggregateOutputType | null
    _avg: Companion_ability_linkAvgAggregateOutputType | null
    _sum: Companion_ability_linkSumAggregateOutputType | null
    _min: Companion_ability_linkMinAggregateOutputType | null
    _max: Companion_ability_linkMaxAggregateOutputType | null
  }

  export type Companion_ability_linkAvgAggregateOutputType = {
    companion_id: number | null
    companion_level: number | null
    ability_id: number | null
    ability_level: number | null
  }

  export type Companion_ability_linkSumAggregateOutputType = {
    companion_id: number | null
    companion_level: number | null
    ability_id: number | null
    ability_level: number | null
  }

  export type Companion_ability_linkMinAggregateOutputType = {
    companion_id: number | null
    companion_level: number | null
    ability_id: number | null
    ability_level: number | null
  }

  export type Companion_ability_linkMaxAggregateOutputType = {
    companion_id: number | null
    companion_level: number | null
    ability_id: number | null
    ability_level: number | null
  }

  export type Companion_ability_linkCountAggregateOutputType = {
    companion_id: number
    companion_level: number
    ability_id: number
    ability_level: number
    _all: number
  }


  export type Companion_ability_linkAvgAggregateInputType = {
    companion_id?: true
    companion_level?: true
    ability_id?: true
    ability_level?: true
  }

  export type Companion_ability_linkSumAggregateInputType = {
    companion_id?: true
    companion_level?: true
    ability_id?: true
    ability_level?: true
  }

  export type Companion_ability_linkMinAggregateInputType = {
    companion_id?: true
    companion_level?: true
    ability_id?: true
    ability_level?: true
  }

  export type Companion_ability_linkMaxAggregateInputType = {
    companion_id?: true
    companion_level?: true
    ability_id?: true
    ability_level?: true
  }

  export type Companion_ability_linkCountAggregateInputType = {
    companion_id?: true
    companion_level?: true
    ability_id?: true
    ability_level?: true
    _all?: true
  }

  export type Companion_ability_linkAggregateArgs = {
    /**
     * Filter which companion_ability_link to aggregate.
     * 
    **/
    where?: companion_ability_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companion_ability_links to fetch.
     * 
    **/
    orderBy?: Enumerable<companion_ability_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: companion_ability_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companion_ability_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companion_ability_links.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companion_ability_links
    **/
    _count?: true | Companion_ability_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Companion_ability_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Companion_ability_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Companion_ability_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Companion_ability_linkMaxAggregateInputType
  }

  export type GetCompanion_ability_linkAggregateType<T extends Companion_ability_linkAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanion_ability_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanion_ability_link[P]>
      : GetScalarType<T[P], AggregateCompanion_ability_link[P]>
  }




  export type Companion_ability_linkGroupByArgs = {
    where?: companion_ability_linkWhereInput
    orderBy?: Enumerable<companion_ability_linkOrderByWithAggregationInput>
    by: Array<Companion_ability_linkScalarFieldEnum>
    having?: companion_ability_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Companion_ability_linkCountAggregateInputType | true
    _avg?: Companion_ability_linkAvgAggregateInputType
    _sum?: Companion_ability_linkSumAggregateInputType
    _min?: Companion_ability_linkMinAggregateInputType
    _max?: Companion_ability_linkMaxAggregateInputType
  }


  export type Companion_ability_linkGroupByOutputType = {
    companion_id: number
    companion_level: number
    ability_id: number
    ability_level: number
    _count: Companion_ability_linkCountAggregateOutputType | null
    _avg: Companion_ability_linkAvgAggregateOutputType | null
    _sum: Companion_ability_linkSumAggregateOutputType | null
    _min: Companion_ability_linkMinAggregateOutputType | null
    _max: Companion_ability_linkMaxAggregateOutputType | null
  }

  type GetCompanion_ability_linkGroupByPayload<T extends Companion_ability_linkGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Companion_ability_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Companion_ability_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Companion_ability_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Companion_ability_linkGroupByOutputType[P]>
        }
      >
    >


  export type companion_ability_linkSelect = {
    companion_id?: boolean
    companion_level?: boolean
    ability_id?: boolean
    ability_level?: boolean
    companion_ability?: boolean | companion_abilityArgs
    companion?: boolean | companionArgs
  }

  export type companion_ability_linkInclude = {
    companion_ability?: boolean | companion_abilityArgs
    companion?: boolean | companionArgs
  }

  export type companion_ability_linkGetPayload<
    S extends boolean | null | undefined | companion_ability_linkArgs,
    U = keyof S
      > = S extends true
        ? companion_ability_link
    : S extends undefined
    ? never
    : S extends companion_ability_linkArgs | companion_ability_linkFindManyArgs
    ?'include' extends U
    ? companion_ability_link  & {
    [P in TrueKeys<S['include']>]:
        P extends 'companion_ability' ? companion_abilityGetPayload<S['include'][P]> :
        P extends 'companion' ? companionGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'companion_ability' ? companion_abilityGetPayload<S['select'][P]> :
        P extends 'companion' ? companionGetPayload<S['select'][P]> :  P extends keyof companion_ability_link ? companion_ability_link[P] : never
  } 
    : companion_ability_link
  : companion_ability_link


  type companion_ability_linkCountArgs = Merge<
    Omit<companion_ability_linkFindManyArgs, 'select' | 'include'> & {
      select?: Companion_ability_linkCountAggregateInputType | true
    }
  >

  export interface companion_ability_linkDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Companion_ability_link that matches the filter.
     * @param {companion_ability_linkFindUniqueArgs} args - Arguments to find a Companion_ability_link
     * @example
     * // Get one Companion_ability_link
     * const companion_ability_link = await prisma.companion_ability_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends companion_ability_linkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, companion_ability_linkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'companion_ability_link'> extends True ? CheckSelect<T, Prisma__companion_ability_linkClient<companion_ability_link>, Prisma__companion_ability_linkClient<companion_ability_linkGetPayload<T>>> : CheckSelect<T, Prisma__companion_ability_linkClient<companion_ability_link | null >, Prisma__companion_ability_linkClient<companion_ability_linkGetPayload<T> | null >>

    /**
     * Find the first Companion_ability_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_ability_linkFindFirstArgs} args - Arguments to find a Companion_ability_link
     * @example
     * // Get one Companion_ability_link
     * const companion_ability_link = await prisma.companion_ability_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends companion_ability_linkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, companion_ability_linkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'companion_ability_link'> extends True ? CheckSelect<T, Prisma__companion_ability_linkClient<companion_ability_link>, Prisma__companion_ability_linkClient<companion_ability_linkGetPayload<T>>> : CheckSelect<T, Prisma__companion_ability_linkClient<companion_ability_link | null >, Prisma__companion_ability_linkClient<companion_ability_linkGetPayload<T> | null >>

    /**
     * Find zero or more Companion_ability_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_ability_linkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companion_ability_links
     * const companion_ability_links = await prisma.companion_ability_link.findMany()
     * 
     * // Get first 10 Companion_ability_links
     * const companion_ability_links = await prisma.companion_ability_link.findMany({ take: 10 })
     * 
     * // Only select the `companion_id`
     * const companion_ability_linkWithCompanion_idOnly = await prisma.companion_ability_link.findMany({ select: { companion_id: true } })
     * 
    **/
    findMany<T extends companion_ability_linkFindManyArgs>(
      args?: SelectSubset<T, companion_ability_linkFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<companion_ability_link>>, PrismaPromise<Array<companion_ability_linkGetPayload<T>>>>

    /**
     * Create a Companion_ability_link.
     * @param {companion_ability_linkCreateArgs} args - Arguments to create a Companion_ability_link.
     * @example
     * // Create one Companion_ability_link
     * const Companion_ability_link = await prisma.companion_ability_link.create({
     *   data: {
     *     // ... data to create a Companion_ability_link
     *   }
     * })
     * 
    **/
    create<T extends companion_ability_linkCreateArgs>(
      args: SelectSubset<T, companion_ability_linkCreateArgs>
    ): CheckSelect<T, Prisma__companion_ability_linkClient<companion_ability_link>, Prisma__companion_ability_linkClient<companion_ability_linkGetPayload<T>>>

    /**
     * Create many Companion_ability_links.
     *     @param {companion_ability_linkCreateManyArgs} args - Arguments to create many Companion_ability_links.
     *     @example
     *     // Create many Companion_ability_links
     *     const companion_ability_link = await prisma.companion_ability_link.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends companion_ability_linkCreateManyArgs>(
      args?: SelectSubset<T, companion_ability_linkCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Companion_ability_link.
     * @param {companion_ability_linkDeleteArgs} args - Arguments to delete one Companion_ability_link.
     * @example
     * // Delete one Companion_ability_link
     * const Companion_ability_link = await prisma.companion_ability_link.delete({
     *   where: {
     *     // ... filter to delete one Companion_ability_link
     *   }
     * })
     * 
    **/
    delete<T extends companion_ability_linkDeleteArgs>(
      args: SelectSubset<T, companion_ability_linkDeleteArgs>
    ): CheckSelect<T, Prisma__companion_ability_linkClient<companion_ability_link>, Prisma__companion_ability_linkClient<companion_ability_linkGetPayload<T>>>

    /**
     * Update one Companion_ability_link.
     * @param {companion_ability_linkUpdateArgs} args - Arguments to update one Companion_ability_link.
     * @example
     * // Update one Companion_ability_link
     * const companion_ability_link = await prisma.companion_ability_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends companion_ability_linkUpdateArgs>(
      args: SelectSubset<T, companion_ability_linkUpdateArgs>
    ): CheckSelect<T, Prisma__companion_ability_linkClient<companion_ability_link>, Prisma__companion_ability_linkClient<companion_ability_linkGetPayload<T>>>

    /**
     * Delete zero or more Companion_ability_links.
     * @param {companion_ability_linkDeleteManyArgs} args - Arguments to filter Companion_ability_links to delete.
     * @example
     * // Delete a few Companion_ability_links
     * const { count } = await prisma.companion_ability_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends companion_ability_linkDeleteManyArgs>(
      args?: SelectSubset<T, companion_ability_linkDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companion_ability_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_ability_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companion_ability_links
     * const companion_ability_link = await prisma.companion_ability_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends companion_ability_linkUpdateManyArgs>(
      args: SelectSubset<T, companion_ability_linkUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Companion_ability_link.
     * @param {companion_ability_linkUpsertArgs} args - Arguments to update or create a Companion_ability_link.
     * @example
     * // Update or create a Companion_ability_link
     * const companion_ability_link = await prisma.companion_ability_link.upsert({
     *   create: {
     *     // ... data to create a Companion_ability_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companion_ability_link we want to update
     *   }
     * })
    **/
    upsert<T extends companion_ability_linkUpsertArgs>(
      args: SelectSubset<T, companion_ability_linkUpsertArgs>
    ): CheckSelect<T, Prisma__companion_ability_linkClient<companion_ability_link>, Prisma__companion_ability_linkClient<companion_ability_linkGetPayload<T>>>

    /**
     * Count the number of Companion_ability_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_ability_linkCountArgs} args - Arguments to filter Companion_ability_links to count.
     * @example
     * // Count the number of Companion_ability_links
     * const count = await prisma.companion_ability_link.count({
     *   where: {
     *     // ... the filter for the Companion_ability_links we want to count
     *   }
     * })
    **/
    count<T extends companion_ability_linkCountArgs>(
      args?: Subset<T, companion_ability_linkCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Companion_ability_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companion_ability_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Companion_ability_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Companion_ability_linkAggregateArgs>(args: Subset<T, Companion_ability_linkAggregateArgs>): PrismaPromise<GetCompanion_ability_linkAggregateType<T>>

    /**
     * Group by Companion_ability_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Companion_ability_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Companion_ability_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Companion_ability_linkGroupByArgs['orderBy'] }
        : { orderBy?: Companion_ability_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Companion_ability_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanion_ability_linkGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for companion_ability_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__companion_ability_linkClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companion_ability<T extends companion_abilityArgs = {}>(args?: Subset<T, companion_abilityArgs>): CheckSelect<T, Prisma__companion_abilityClient<companion_ability | null >, Prisma__companion_abilityClient<companion_abilityGetPayload<T> | null >>;

    companion<T extends companionArgs = {}>(args?: Subset<T, companionArgs>): CheckSelect<T, Prisma__companionClient<companion | null >, Prisma__companionClient<companionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * companion_ability_link findUnique
   */
  export type companion_ability_linkFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the companion_ability_link
     * 
    **/
    select?: companion_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_ability_linkInclude | null
    /**
     * Throw an Error if a companion_ability_link can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which companion_ability_link to fetch.
     * 
    **/
    where: companion_ability_linkWhereUniqueInput
  }


  /**
   * companion_ability_link findFirst
   */
  export type companion_ability_linkFindFirstArgs = {
    /**
     * Select specific fields to fetch from the companion_ability_link
     * 
    **/
    select?: companion_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_ability_linkInclude | null
    /**
     * Throw an Error if a companion_ability_link can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which companion_ability_link to fetch.
     * 
    **/
    where?: companion_ability_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companion_ability_links to fetch.
     * 
    **/
    orderBy?: Enumerable<companion_ability_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companion_ability_links.
     * 
    **/
    cursor?: companion_ability_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companion_ability_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companion_ability_links.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companion_ability_links.
     * 
    **/
    distinct?: Enumerable<Companion_ability_linkScalarFieldEnum>
  }


  /**
   * companion_ability_link findMany
   */
  export type companion_ability_linkFindManyArgs = {
    /**
     * Select specific fields to fetch from the companion_ability_link
     * 
    **/
    select?: companion_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_ability_linkInclude | null
    /**
     * Filter, which companion_ability_links to fetch.
     * 
    **/
    where?: companion_ability_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companion_ability_links to fetch.
     * 
    **/
    orderBy?: Enumerable<companion_ability_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companion_ability_links.
     * 
    **/
    cursor?: companion_ability_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companion_ability_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companion_ability_links.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Companion_ability_linkScalarFieldEnum>
  }


  /**
   * companion_ability_link create
   */
  export type companion_ability_linkCreateArgs = {
    /**
     * Select specific fields to fetch from the companion_ability_link
     * 
    **/
    select?: companion_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_ability_linkInclude | null
    /**
     * The data needed to create a companion_ability_link.
     * 
    **/
    data: XOR<companion_ability_linkCreateInput, companion_ability_linkUncheckedCreateInput>
  }


  /**
   * companion_ability_link createMany
   */
  export type companion_ability_linkCreateManyArgs = {
    /**
     * The data used to create many companion_ability_links.
     * 
    **/
    data: Enumerable<companion_ability_linkCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * companion_ability_link update
   */
  export type companion_ability_linkUpdateArgs = {
    /**
     * Select specific fields to fetch from the companion_ability_link
     * 
    **/
    select?: companion_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_ability_linkInclude | null
    /**
     * The data needed to update a companion_ability_link.
     * 
    **/
    data: XOR<companion_ability_linkUpdateInput, companion_ability_linkUncheckedUpdateInput>
    /**
     * Choose, which companion_ability_link to update.
     * 
    **/
    where: companion_ability_linkWhereUniqueInput
  }


  /**
   * companion_ability_link updateMany
   */
  export type companion_ability_linkUpdateManyArgs = {
    /**
     * The data used to update companion_ability_links.
     * 
    **/
    data: XOR<companion_ability_linkUpdateManyMutationInput, companion_ability_linkUncheckedUpdateManyInput>
    /**
     * Filter which companion_ability_links to update
     * 
    **/
    where?: companion_ability_linkWhereInput
  }


  /**
   * companion_ability_link upsert
   */
  export type companion_ability_linkUpsertArgs = {
    /**
     * Select specific fields to fetch from the companion_ability_link
     * 
    **/
    select?: companion_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_ability_linkInclude | null
    /**
     * The filter to search for the companion_ability_link to update in case it exists.
     * 
    **/
    where: companion_ability_linkWhereUniqueInput
    /**
     * In case the companion_ability_link found by the `where` argument doesn't exist, create a new companion_ability_link with this data.
     * 
    **/
    create: XOR<companion_ability_linkCreateInput, companion_ability_linkUncheckedCreateInput>
    /**
     * In case the companion_ability_link was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<companion_ability_linkUpdateInput, companion_ability_linkUncheckedUpdateInput>
  }


  /**
   * companion_ability_link delete
   */
  export type companion_ability_linkDeleteArgs = {
    /**
     * Select specific fields to fetch from the companion_ability_link
     * 
    **/
    select?: companion_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_ability_linkInclude | null
    /**
     * Filter which companion_ability_link to delete.
     * 
    **/
    where: companion_ability_linkWhereUniqueInput
  }


  /**
   * companion_ability_link deleteMany
   */
  export type companion_ability_linkDeleteManyArgs = {
    /**
     * Filter which companion_ability_links to delete
     * 
    **/
    where?: companion_ability_linkWhereInput
  }


  /**
   * companion_ability_link without action
   */
  export type companion_ability_linkArgs = {
    /**
     * Select specific fields to fetch from the companion_ability_link
     * 
    **/
    select?: companion_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_ability_linkInclude | null
  }



  /**
   * Model companion_skill
   */


  export type AggregateCompanion_skill = {
    _count: Companion_skillCountAggregateOutputType | null
    _avg: Companion_skillAvgAggregateOutputType | null
    _sum: Companion_skillSumAggregateOutputType | null
    _min: Companion_skillMinAggregateOutputType | null
    _max: Companion_skillMaxAggregateOutputType | null
  }

  export type Companion_skillAvgAggregateOutputType = {
    skill_id: number | null
    skill_level: number | null
    cooldown_time: number | null
  }

  export type Companion_skillSumAggregateOutputType = {
    skill_id: number | null
    skill_level: number | null
    cooldown_time: number | null
  }

  export type Companion_skillMinAggregateOutputType = {
    skill_id: number | null
    skill_level: number | null
    cooldown_time: number | null
    name: string | null
    description: string | null
    short_description: string | null
    image_path: string | null
  }

  export type Companion_skillMaxAggregateOutputType = {
    skill_id: number | null
    skill_level: number | null
    cooldown_time: number | null
    name: string | null
    description: string | null
    short_description: string | null
    image_path: string | null
  }

  export type Companion_skillCountAggregateOutputType = {
    skill_id: number
    skill_level: number
    cooldown_time: number
    name: number
    description: number
    short_description: number
    image_path: number
    _all: number
  }


  export type Companion_skillAvgAggregateInputType = {
    skill_id?: true
    skill_level?: true
    cooldown_time?: true
  }

  export type Companion_skillSumAggregateInputType = {
    skill_id?: true
    skill_level?: true
    cooldown_time?: true
  }

  export type Companion_skillMinAggregateInputType = {
    skill_id?: true
    skill_level?: true
    cooldown_time?: true
    name?: true
    description?: true
    short_description?: true
    image_path?: true
  }

  export type Companion_skillMaxAggregateInputType = {
    skill_id?: true
    skill_level?: true
    cooldown_time?: true
    name?: true
    description?: true
    short_description?: true
    image_path?: true
  }

  export type Companion_skillCountAggregateInputType = {
    skill_id?: true
    skill_level?: true
    cooldown_time?: true
    name?: true
    description?: true
    short_description?: true
    image_path?: true
    _all?: true
  }

  export type Companion_skillAggregateArgs = {
    /**
     * Filter which companion_skill to aggregate.
     * 
    **/
    where?: companion_skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companion_skills to fetch.
     * 
    **/
    orderBy?: Enumerable<companion_skillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: companion_skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companion_skills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companion_skills.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companion_skills
    **/
    _count?: true | Companion_skillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Companion_skillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Companion_skillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Companion_skillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Companion_skillMaxAggregateInputType
  }

  export type GetCompanion_skillAggregateType<T extends Companion_skillAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanion_skill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanion_skill[P]>
      : GetScalarType<T[P], AggregateCompanion_skill[P]>
  }




  export type Companion_skillGroupByArgs = {
    where?: companion_skillWhereInput
    orderBy?: Enumerable<companion_skillOrderByWithAggregationInput>
    by: Array<Companion_skillScalarFieldEnum>
    having?: companion_skillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Companion_skillCountAggregateInputType | true
    _avg?: Companion_skillAvgAggregateInputType
    _sum?: Companion_skillSumAggregateInputType
    _min?: Companion_skillMinAggregateInputType
    _max?: Companion_skillMaxAggregateInputType
  }


  export type Companion_skillGroupByOutputType = {
    skill_id: number
    skill_level: number
    cooldown_time: number
    name: string | null
    description: string | null
    short_description: string | null
    image_path: string | null
    _count: Companion_skillCountAggregateOutputType | null
    _avg: Companion_skillAvgAggregateOutputType | null
    _sum: Companion_skillSumAggregateOutputType | null
    _min: Companion_skillMinAggregateOutputType | null
    _max: Companion_skillMaxAggregateOutputType | null
  }

  type GetCompanion_skillGroupByPayload<T extends Companion_skillGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Companion_skillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Companion_skillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Companion_skillGroupByOutputType[P]>
            : GetScalarType<T[P], Companion_skillGroupByOutputType[P]>
        }
      >
    >


  export type companion_skillSelect = {
    skill_id?: boolean
    skill_level?: boolean
    cooldown_time?: boolean
    name?: boolean
    description?: boolean
    short_description?: boolean
    image_path?: boolean
    companion_skill_link?: boolean | companion_skill_linkFindManyArgs
    _count?: boolean | Companion_skillCountOutputTypeArgs
  }

  export type companion_skillInclude = {
    companion_skill_link?: boolean | companion_skill_linkFindManyArgs
    _count?: boolean | Companion_skillCountOutputTypeArgs
  }

  export type companion_skillGetPayload<
    S extends boolean | null | undefined | companion_skillArgs,
    U = keyof S
      > = S extends true
        ? companion_skill
    : S extends undefined
    ? never
    : S extends companion_skillArgs | companion_skillFindManyArgs
    ?'include' extends U
    ? companion_skill  & {
    [P in TrueKeys<S['include']>]:
        P extends 'companion_skill_link' ? Array < companion_skill_linkGetPayload<S['include'][P]>>  :
        P extends '_count' ? Companion_skillCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'companion_skill_link' ? Array < companion_skill_linkGetPayload<S['select'][P]>>  :
        P extends '_count' ? Companion_skillCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof companion_skill ? companion_skill[P] : never
  } 
    : companion_skill
  : companion_skill


  type companion_skillCountArgs = Merge<
    Omit<companion_skillFindManyArgs, 'select' | 'include'> & {
      select?: Companion_skillCountAggregateInputType | true
    }
  >

  export interface companion_skillDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Companion_skill that matches the filter.
     * @param {companion_skillFindUniqueArgs} args - Arguments to find a Companion_skill
     * @example
     * // Get one Companion_skill
     * const companion_skill = await prisma.companion_skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends companion_skillFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, companion_skillFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'companion_skill'> extends True ? CheckSelect<T, Prisma__companion_skillClient<companion_skill>, Prisma__companion_skillClient<companion_skillGetPayload<T>>> : CheckSelect<T, Prisma__companion_skillClient<companion_skill | null >, Prisma__companion_skillClient<companion_skillGetPayload<T> | null >>

    /**
     * Find the first Companion_skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_skillFindFirstArgs} args - Arguments to find a Companion_skill
     * @example
     * // Get one Companion_skill
     * const companion_skill = await prisma.companion_skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends companion_skillFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, companion_skillFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'companion_skill'> extends True ? CheckSelect<T, Prisma__companion_skillClient<companion_skill>, Prisma__companion_skillClient<companion_skillGetPayload<T>>> : CheckSelect<T, Prisma__companion_skillClient<companion_skill | null >, Prisma__companion_skillClient<companion_skillGetPayload<T> | null >>

    /**
     * Find zero or more Companion_skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_skillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companion_skills
     * const companion_skills = await prisma.companion_skill.findMany()
     * 
     * // Get first 10 Companion_skills
     * const companion_skills = await prisma.companion_skill.findMany({ take: 10 })
     * 
     * // Only select the `skill_id`
     * const companion_skillWithSkill_idOnly = await prisma.companion_skill.findMany({ select: { skill_id: true } })
     * 
    **/
    findMany<T extends companion_skillFindManyArgs>(
      args?: SelectSubset<T, companion_skillFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<companion_skill>>, PrismaPromise<Array<companion_skillGetPayload<T>>>>

    /**
     * Create a Companion_skill.
     * @param {companion_skillCreateArgs} args - Arguments to create a Companion_skill.
     * @example
     * // Create one Companion_skill
     * const Companion_skill = await prisma.companion_skill.create({
     *   data: {
     *     // ... data to create a Companion_skill
     *   }
     * })
     * 
    **/
    create<T extends companion_skillCreateArgs>(
      args: SelectSubset<T, companion_skillCreateArgs>
    ): CheckSelect<T, Prisma__companion_skillClient<companion_skill>, Prisma__companion_skillClient<companion_skillGetPayload<T>>>

    /**
     * Create many Companion_skills.
     *     @param {companion_skillCreateManyArgs} args - Arguments to create many Companion_skills.
     *     @example
     *     // Create many Companion_skills
     *     const companion_skill = await prisma.companion_skill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends companion_skillCreateManyArgs>(
      args?: SelectSubset<T, companion_skillCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Companion_skill.
     * @param {companion_skillDeleteArgs} args - Arguments to delete one Companion_skill.
     * @example
     * // Delete one Companion_skill
     * const Companion_skill = await prisma.companion_skill.delete({
     *   where: {
     *     // ... filter to delete one Companion_skill
     *   }
     * })
     * 
    **/
    delete<T extends companion_skillDeleteArgs>(
      args: SelectSubset<T, companion_skillDeleteArgs>
    ): CheckSelect<T, Prisma__companion_skillClient<companion_skill>, Prisma__companion_skillClient<companion_skillGetPayload<T>>>

    /**
     * Update one Companion_skill.
     * @param {companion_skillUpdateArgs} args - Arguments to update one Companion_skill.
     * @example
     * // Update one Companion_skill
     * const companion_skill = await prisma.companion_skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends companion_skillUpdateArgs>(
      args: SelectSubset<T, companion_skillUpdateArgs>
    ): CheckSelect<T, Prisma__companion_skillClient<companion_skill>, Prisma__companion_skillClient<companion_skillGetPayload<T>>>

    /**
     * Delete zero or more Companion_skills.
     * @param {companion_skillDeleteManyArgs} args - Arguments to filter Companion_skills to delete.
     * @example
     * // Delete a few Companion_skills
     * const { count } = await prisma.companion_skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends companion_skillDeleteManyArgs>(
      args?: SelectSubset<T, companion_skillDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companion_skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_skillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companion_skills
     * const companion_skill = await prisma.companion_skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends companion_skillUpdateManyArgs>(
      args: SelectSubset<T, companion_skillUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Companion_skill.
     * @param {companion_skillUpsertArgs} args - Arguments to update or create a Companion_skill.
     * @example
     * // Update or create a Companion_skill
     * const companion_skill = await prisma.companion_skill.upsert({
     *   create: {
     *     // ... data to create a Companion_skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companion_skill we want to update
     *   }
     * })
    **/
    upsert<T extends companion_skillUpsertArgs>(
      args: SelectSubset<T, companion_skillUpsertArgs>
    ): CheckSelect<T, Prisma__companion_skillClient<companion_skill>, Prisma__companion_skillClient<companion_skillGetPayload<T>>>

    /**
     * Count the number of Companion_skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_skillCountArgs} args - Arguments to filter Companion_skills to count.
     * @example
     * // Count the number of Companion_skills
     * const count = await prisma.companion_skill.count({
     *   where: {
     *     // ... the filter for the Companion_skills we want to count
     *   }
     * })
    **/
    count<T extends companion_skillCountArgs>(
      args?: Subset<T, companion_skillCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Companion_skillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companion_skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Companion_skillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Companion_skillAggregateArgs>(args: Subset<T, Companion_skillAggregateArgs>): PrismaPromise<GetCompanion_skillAggregateType<T>>

    /**
     * Group by Companion_skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Companion_skillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Companion_skillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Companion_skillGroupByArgs['orderBy'] }
        : { orderBy?: Companion_skillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Companion_skillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanion_skillGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for companion_skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__companion_skillClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companion_skill_link<T extends companion_skill_linkFindManyArgs = {}>(args?: Subset<T, companion_skill_linkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<companion_skill_link>>, PrismaPromise<Array<companion_skill_linkGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * companion_skill findUnique
   */
  export type companion_skillFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the companion_skill
     * 
    **/
    select?: companion_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_skillInclude | null
    /**
     * Throw an Error if a companion_skill can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which companion_skill to fetch.
     * 
    **/
    where: companion_skillWhereUniqueInput
  }


  /**
   * companion_skill findFirst
   */
  export type companion_skillFindFirstArgs = {
    /**
     * Select specific fields to fetch from the companion_skill
     * 
    **/
    select?: companion_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_skillInclude | null
    /**
     * Throw an Error if a companion_skill can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which companion_skill to fetch.
     * 
    **/
    where?: companion_skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companion_skills to fetch.
     * 
    **/
    orderBy?: Enumerable<companion_skillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companion_skills.
     * 
    **/
    cursor?: companion_skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companion_skills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companion_skills.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companion_skills.
     * 
    **/
    distinct?: Enumerable<Companion_skillScalarFieldEnum>
  }


  /**
   * companion_skill findMany
   */
  export type companion_skillFindManyArgs = {
    /**
     * Select specific fields to fetch from the companion_skill
     * 
    **/
    select?: companion_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_skillInclude | null
    /**
     * Filter, which companion_skills to fetch.
     * 
    **/
    where?: companion_skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companion_skills to fetch.
     * 
    **/
    orderBy?: Enumerable<companion_skillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companion_skills.
     * 
    **/
    cursor?: companion_skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companion_skills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companion_skills.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Companion_skillScalarFieldEnum>
  }


  /**
   * companion_skill create
   */
  export type companion_skillCreateArgs = {
    /**
     * Select specific fields to fetch from the companion_skill
     * 
    **/
    select?: companion_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_skillInclude | null
    /**
     * The data needed to create a companion_skill.
     * 
    **/
    data: XOR<companion_skillCreateInput, companion_skillUncheckedCreateInput>
  }


  /**
   * companion_skill createMany
   */
  export type companion_skillCreateManyArgs = {
    /**
     * The data used to create many companion_skills.
     * 
    **/
    data: Enumerable<companion_skillCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * companion_skill update
   */
  export type companion_skillUpdateArgs = {
    /**
     * Select specific fields to fetch from the companion_skill
     * 
    **/
    select?: companion_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_skillInclude | null
    /**
     * The data needed to update a companion_skill.
     * 
    **/
    data: XOR<companion_skillUpdateInput, companion_skillUncheckedUpdateInput>
    /**
     * Choose, which companion_skill to update.
     * 
    **/
    where: companion_skillWhereUniqueInput
  }


  /**
   * companion_skill updateMany
   */
  export type companion_skillUpdateManyArgs = {
    /**
     * The data used to update companion_skills.
     * 
    **/
    data: XOR<companion_skillUpdateManyMutationInput, companion_skillUncheckedUpdateManyInput>
    /**
     * Filter which companion_skills to update
     * 
    **/
    where?: companion_skillWhereInput
  }


  /**
   * companion_skill upsert
   */
  export type companion_skillUpsertArgs = {
    /**
     * Select specific fields to fetch from the companion_skill
     * 
    **/
    select?: companion_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_skillInclude | null
    /**
     * The filter to search for the companion_skill to update in case it exists.
     * 
    **/
    where: companion_skillWhereUniqueInput
    /**
     * In case the companion_skill found by the `where` argument doesn't exist, create a new companion_skill with this data.
     * 
    **/
    create: XOR<companion_skillCreateInput, companion_skillUncheckedCreateInput>
    /**
     * In case the companion_skill was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<companion_skillUpdateInput, companion_skillUncheckedUpdateInput>
  }


  /**
   * companion_skill delete
   */
  export type companion_skillDeleteArgs = {
    /**
     * Select specific fields to fetch from the companion_skill
     * 
    **/
    select?: companion_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_skillInclude | null
    /**
     * Filter which companion_skill to delete.
     * 
    **/
    where: companion_skillWhereUniqueInput
  }


  /**
   * companion_skill deleteMany
   */
  export type companion_skillDeleteManyArgs = {
    /**
     * Filter which companion_skills to delete
     * 
    **/
    where?: companion_skillWhereInput
  }


  /**
   * companion_skill without action
   */
  export type companion_skillArgs = {
    /**
     * Select specific fields to fetch from the companion_skill
     * 
    **/
    select?: companion_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_skillInclude | null
  }



  /**
   * Model companion_skill_link
   */


  export type AggregateCompanion_skill_link = {
    _count: Companion_skill_linkCountAggregateOutputType | null
    _avg: Companion_skill_linkAvgAggregateOutputType | null
    _sum: Companion_skill_linkSumAggregateOutputType | null
    _min: Companion_skill_linkMinAggregateOutputType | null
    _max: Companion_skill_linkMaxAggregateOutputType | null
  }

  export type Companion_skill_linkAvgAggregateOutputType = {
    companion_id: number | null
    companion_level: number | null
    skill_id: number | null
    skill_level: number | null
  }

  export type Companion_skill_linkSumAggregateOutputType = {
    companion_id: number | null
    companion_level: number | null
    skill_id: number | null
    skill_level: number | null
  }

  export type Companion_skill_linkMinAggregateOutputType = {
    companion_id: number | null
    companion_level: number | null
    skill_id: number | null
    skill_level: number | null
  }

  export type Companion_skill_linkMaxAggregateOutputType = {
    companion_id: number | null
    companion_level: number | null
    skill_id: number | null
    skill_level: number | null
  }

  export type Companion_skill_linkCountAggregateOutputType = {
    companion_id: number
    companion_level: number
    skill_id: number
    skill_level: number
    _all: number
  }


  export type Companion_skill_linkAvgAggregateInputType = {
    companion_id?: true
    companion_level?: true
    skill_id?: true
    skill_level?: true
  }

  export type Companion_skill_linkSumAggregateInputType = {
    companion_id?: true
    companion_level?: true
    skill_id?: true
    skill_level?: true
  }

  export type Companion_skill_linkMinAggregateInputType = {
    companion_id?: true
    companion_level?: true
    skill_id?: true
    skill_level?: true
  }

  export type Companion_skill_linkMaxAggregateInputType = {
    companion_id?: true
    companion_level?: true
    skill_id?: true
    skill_level?: true
  }

  export type Companion_skill_linkCountAggregateInputType = {
    companion_id?: true
    companion_level?: true
    skill_id?: true
    skill_level?: true
    _all?: true
  }

  export type Companion_skill_linkAggregateArgs = {
    /**
     * Filter which companion_skill_link to aggregate.
     * 
    **/
    where?: companion_skill_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companion_skill_links to fetch.
     * 
    **/
    orderBy?: Enumerable<companion_skill_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: companion_skill_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companion_skill_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companion_skill_links.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companion_skill_links
    **/
    _count?: true | Companion_skill_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Companion_skill_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Companion_skill_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Companion_skill_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Companion_skill_linkMaxAggregateInputType
  }

  export type GetCompanion_skill_linkAggregateType<T extends Companion_skill_linkAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanion_skill_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanion_skill_link[P]>
      : GetScalarType<T[P], AggregateCompanion_skill_link[P]>
  }




  export type Companion_skill_linkGroupByArgs = {
    where?: companion_skill_linkWhereInput
    orderBy?: Enumerable<companion_skill_linkOrderByWithAggregationInput>
    by: Array<Companion_skill_linkScalarFieldEnum>
    having?: companion_skill_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Companion_skill_linkCountAggregateInputType | true
    _avg?: Companion_skill_linkAvgAggregateInputType
    _sum?: Companion_skill_linkSumAggregateInputType
    _min?: Companion_skill_linkMinAggregateInputType
    _max?: Companion_skill_linkMaxAggregateInputType
  }


  export type Companion_skill_linkGroupByOutputType = {
    companion_id: number
    companion_level: number
    skill_id: number
    skill_level: number
    _count: Companion_skill_linkCountAggregateOutputType | null
    _avg: Companion_skill_linkAvgAggregateOutputType | null
    _sum: Companion_skill_linkSumAggregateOutputType | null
    _min: Companion_skill_linkMinAggregateOutputType | null
    _max: Companion_skill_linkMaxAggregateOutputType | null
  }

  type GetCompanion_skill_linkGroupByPayload<T extends Companion_skill_linkGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Companion_skill_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Companion_skill_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Companion_skill_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Companion_skill_linkGroupByOutputType[P]>
        }
      >
    >


  export type companion_skill_linkSelect = {
    companion_id?: boolean
    companion_level?: boolean
    skill_id?: boolean
    skill_level?: boolean
    companion?: boolean | companionArgs
    companion_skill?: boolean | companion_skillArgs
  }

  export type companion_skill_linkInclude = {
    companion?: boolean | companionArgs
    companion_skill?: boolean | companion_skillArgs
  }

  export type companion_skill_linkGetPayload<
    S extends boolean | null | undefined | companion_skill_linkArgs,
    U = keyof S
      > = S extends true
        ? companion_skill_link
    : S extends undefined
    ? never
    : S extends companion_skill_linkArgs | companion_skill_linkFindManyArgs
    ?'include' extends U
    ? companion_skill_link  & {
    [P in TrueKeys<S['include']>]:
        P extends 'companion' ? companionGetPayload<S['include'][P]> :
        P extends 'companion_skill' ? companion_skillGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'companion' ? companionGetPayload<S['select'][P]> :
        P extends 'companion_skill' ? companion_skillGetPayload<S['select'][P]> :  P extends keyof companion_skill_link ? companion_skill_link[P] : never
  } 
    : companion_skill_link
  : companion_skill_link


  type companion_skill_linkCountArgs = Merge<
    Omit<companion_skill_linkFindManyArgs, 'select' | 'include'> & {
      select?: Companion_skill_linkCountAggregateInputType | true
    }
  >

  export interface companion_skill_linkDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Companion_skill_link that matches the filter.
     * @param {companion_skill_linkFindUniqueArgs} args - Arguments to find a Companion_skill_link
     * @example
     * // Get one Companion_skill_link
     * const companion_skill_link = await prisma.companion_skill_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends companion_skill_linkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, companion_skill_linkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'companion_skill_link'> extends True ? CheckSelect<T, Prisma__companion_skill_linkClient<companion_skill_link>, Prisma__companion_skill_linkClient<companion_skill_linkGetPayload<T>>> : CheckSelect<T, Prisma__companion_skill_linkClient<companion_skill_link | null >, Prisma__companion_skill_linkClient<companion_skill_linkGetPayload<T> | null >>

    /**
     * Find the first Companion_skill_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_skill_linkFindFirstArgs} args - Arguments to find a Companion_skill_link
     * @example
     * // Get one Companion_skill_link
     * const companion_skill_link = await prisma.companion_skill_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends companion_skill_linkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, companion_skill_linkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'companion_skill_link'> extends True ? CheckSelect<T, Prisma__companion_skill_linkClient<companion_skill_link>, Prisma__companion_skill_linkClient<companion_skill_linkGetPayload<T>>> : CheckSelect<T, Prisma__companion_skill_linkClient<companion_skill_link | null >, Prisma__companion_skill_linkClient<companion_skill_linkGetPayload<T> | null >>

    /**
     * Find zero or more Companion_skill_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_skill_linkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companion_skill_links
     * const companion_skill_links = await prisma.companion_skill_link.findMany()
     * 
     * // Get first 10 Companion_skill_links
     * const companion_skill_links = await prisma.companion_skill_link.findMany({ take: 10 })
     * 
     * // Only select the `companion_id`
     * const companion_skill_linkWithCompanion_idOnly = await prisma.companion_skill_link.findMany({ select: { companion_id: true } })
     * 
    **/
    findMany<T extends companion_skill_linkFindManyArgs>(
      args?: SelectSubset<T, companion_skill_linkFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<companion_skill_link>>, PrismaPromise<Array<companion_skill_linkGetPayload<T>>>>

    /**
     * Create a Companion_skill_link.
     * @param {companion_skill_linkCreateArgs} args - Arguments to create a Companion_skill_link.
     * @example
     * // Create one Companion_skill_link
     * const Companion_skill_link = await prisma.companion_skill_link.create({
     *   data: {
     *     // ... data to create a Companion_skill_link
     *   }
     * })
     * 
    **/
    create<T extends companion_skill_linkCreateArgs>(
      args: SelectSubset<T, companion_skill_linkCreateArgs>
    ): CheckSelect<T, Prisma__companion_skill_linkClient<companion_skill_link>, Prisma__companion_skill_linkClient<companion_skill_linkGetPayload<T>>>

    /**
     * Create many Companion_skill_links.
     *     @param {companion_skill_linkCreateManyArgs} args - Arguments to create many Companion_skill_links.
     *     @example
     *     // Create many Companion_skill_links
     *     const companion_skill_link = await prisma.companion_skill_link.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends companion_skill_linkCreateManyArgs>(
      args?: SelectSubset<T, companion_skill_linkCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Companion_skill_link.
     * @param {companion_skill_linkDeleteArgs} args - Arguments to delete one Companion_skill_link.
     * @example
     * // Delete one Companion_skill_link
     * const Companion_skill_link = await prisma.companion_skill_link.delete({
     *   where: {
     *     // ... filter to delete one Companion_skill_link
     *   }
     * })
     * 
    **/
    delete<T extends companion_skill_linkDeleteArgs>(
      args: SelectSubset<T, companion_skill_linkDeleteArgs>
    ): CheckSelect<T, Prisma__companion_skill_linkClient<companion_skill_link>, Prisma__companion_skill_linkClient<companion_skill_linkGetPayload<T>>>

    /**
     * Update one Companion_skill_link.
     * @param {companion_skill_linkUpdateArgs} args - Arguments to update one Companion_skill_link.
     * @example
     * // Update one Companion_skill_link
     * const companion_skill_link = await prisma.companion_skill_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends companion_skill_linkUpdateArgs>(
      args: SelectSubset<T, companion_skill_linkUpdateArgs>
    ): CheckSelect<T, Prisma__companion_skill_linkClient<companion_skill_link>, Prisma__companion_skill_linkClient<companion_skill_linkGetPayload<T>>>

    /**
     * Delete zero or more Companion_skill_links.
     * @param {companion_skill_linkDeleteManyArgs} args - Arguments to filter Companion_skill_links to delete.
     * @example
     * // Delete a few Companion_skill_links
     * const { count } = await prisma.companion_skill_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends companion_skill_linkDeleteManyArgs>(
      args?: SelectSubset<T, companion_skill_linkDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companion_skill_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_skill_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companion_skill_links
     * const companion_skill_link = await prisma.companion_skill_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends companion_skill_linkUpdateManyArgs>(
      args: SelectSubset<T, companion_skill_linkUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Companion_skill_link.
     * @param {companion_skill_linkUpsertArgs} args - Arguments to update or create a Companion_skill_link.
     * @example
     * // Update or create a Companion_skill_link
     * const companion_skill_link = await prisma.companion_skill_link.upsert({
     *   create: {
     *     // ... data to create a Companion_skill_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companion_skill_link we want to update
     *   }
     * })
    **/
    upsert<T extends companion_skill_linkUpsertArgs>(
      args: SelectSubset<T, companion_skill_linkUpsertArgs>
    ): CheckSelect<T, Prisma__companion_skill_linkClient<companion_skill_link>, Prisma__companion_skill_linkClient<companion_skill_linkGetPayload<T>>>

    /**
     * Count the number of Companion_skill_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_skill_linkCountArgs} args - Arguments to filter Companion_skill_links to count.
     * @example
     * // Count the number of Companion_skill_links
     * const count = await prisma.companion_skill_link.count({
     *   where: {
     *     // ... the filter for the Companion_skill_links we want to count
     *   }
     * })
    **/
    count<T extends companion_skill_linkCountArgs>(
      args?: Subset<T, companion_skill_linkCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Companion_skill_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companion_skill_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Companion_skill_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Companion_skill_linkAggregateArgs>(args: Subset<T, Companion_skill_linkAggregateArgs>): PrismaPromise<GetCompanion_skill_linkAggregateType<T>>

    /**
     * Group by Companion_skill_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Companion_skill_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Companion_skill_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Companion_skill_linkGroupByArgs['orderBy'] }
        : { orderBy?: Companion_skill_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Companion_skill_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanion_skill_linkGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for companion_skill_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__companion_skill_linkClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companion<T extends companionArgs = {}>(args?: Subset<T, companionArgs>): CheckSelect<T, Prisma__companionClient<companion | null >, Prisma__companionClient<companionGetPayload<T> | null >>;

    companion_skill<T extends companion_skillArgs = {}>(args?: Subset<T, companion_skillArgs>): CheckSelect<T, Prisma__companion_skillClient<companion_skill | null >, Prisma__companion_skillClient<companion_skillGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * companion_skill_link findUnique
   */
  export type companion_skill_linkFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the companion_skill_link
     * 
    **/
    select?: companion_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_skill_linkInclude | null
    /**
     * Throw an Error if a companion_skill_link can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which companion_skill_link to fetch.
     * 
    **/
    where: companion_skill_linkWhereUniqueInput
  }


  /**
   * companion_skill_link findFirst
   */
  export type companion_skill_linkFindFirstArgs = {
    /**
     * Select specific fields to fetch from the companion_skill_link
     * 
    **/
    select?: companion_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_skill_linkInclude | null
    /**
     * Throw an Error if a companion_skill_link can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which companion_skill_link to fetch.
     * 
    **/
    where?: companion_skill_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companion_skill_links to fetch.
     * 
    **/
    orderBy?: Enumerable<companion_skill_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companion_skill_links.
     * 
    **/
    cursor?: companion_skill_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companion_skill_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companion_skill_links.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companion_skill_links.
     * 
    **/
    distinct?: Enumerable<Companion_skill_linkScalarFieldEnum>
  }


  /**
   * companion_skill_link findMany
   */
  export type companion_skill_linkFindManyArgs = {
    /**
     * Select specific fields to fetch from the companion_skill_link
     * 
    **/
    select?: companion_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_skill_linkInclude | null
    /**
     * Filter, which companion_skill_links to fetch.
     * 
    **/
    where?: companion_skill_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companion_skill_links to fetch.
     * 
    **/
    orderBy?: Enumerable<companion_skill_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companion_skill_links.
     * 
    **/
    cursor?: companion_skill_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companion_skill_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companion_skill_links.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Companion_skill_linkScalarFieldEnum>
  }


  /**
   * companion_skill_link create
   */
  export type companion_skill_linkCreateArgs = {
    /**
     * Select specific fields to fetch from the companion_skill_link
     * 
    **/
    select?: companion_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_skill_linkInclude | null
    /**
     * The data needed to create a companion_skill_link.
     * 
    **/
    data: XOR<companion_skill_linkCreateInput, companion_skill_linkUncheckedCreateInput>
  }


  /**
   * companion_skill_link createMany
   */
  export type companion_skill_linkCreateManyArgs = {
    /**
     * The data used to create many companion_skill_links.
     * 
    **/
    data: Enumerable<companion_skill_linkCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * companion_skill_link update
   */
  export type companion_skill_linkUpdateArgs = {
    /**
     * Select specific fields to fetch from the companion_skill_link
     * 
    **/
    select?: companion_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_skill_linkInclude | null
    /**
     * The data needed to update a companion_skill_link.
     * 
    **/
    data: XOR<companion_skill_linkUpdateInput, companion_skill_linkUncheckedUpdateInput>
    /**
     * Choose, which companion_skill_link to update.
     * 
    **/
    where: companion_skill_linkWhereUniqueInput
  }


  /**
   * companion_skill_link updateMany
   */
  export type companion_skill_linkUpdateManyArgs = {
    /**
     * The data used to update companion_skill_links.
     * 
    **/
    data: XOR<companion_skill_linkUpdateManyMutationInput, companion_skill_linkUncheckedUpdateManyInput>
    /**
     * Filter which companion_skill_links to update
     * 
    **/
    where?: companion_skill_linkWhereInput
  }


  /**
   * companion_skill_link upsert
   */
  export type companion_skill_linkUpsertArgs = {
    /**
     * Select specific fields to fetch from the companion_skill_link
     * 
    **/
    select?: companion_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_skill_linkInclude | null
    /**
     * The filter to search for the companion_skill_link to update in case it exists.
     * 
    **/
    where: companion_skill_linkWhereUniqueInput
    /**
     * In case the companion_skill_link found by the `where` argument doesn't exist, create a new companion_skill_link with this data.
     * 
    **/
    create: XOR<companion_skill_linkCreateInput, companion_skill_linkUncheckedCreateInput>
    /**
     * In case the companion_skill_link was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<companion_skill_linkUpdateInput, companion_skill_linkUncheckedUpdateInput>
  }


  /**
   * companion_skill_link delete
   */
  export type companion_skill_linkDeleteArgs = {
    /**
     * Select specific fields to fetch from the companion_skill_link
     * 
    **/
    select?: companion_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_skill_linkInclude | null
    /**
     * Filter which companion_skill_link to delete.
     * 
    **/
    where: companion_skill_linkWhereUniqueInput
  }


  /**
   * companion_skill_link deleteMany
   */
  export type companion_skill_linkDeleteManyArgs = {
    /**
     * Filter which companion_skill_links to delete
     * 
    **/
    where?: companion_skill_linkWhereInput
  }


  /**
   * companion_skill_link without action
   */
  export type companion_skill_linkArgs = {
    /**
     * Select specific fields to fetch from the companion_skill_link
     * 
    **/
    select?: companion_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_skill_linkInclude | null
  }



  /**
   * Model companion_stat
   */


  export type AggregateCompanion_stat = {
    _count: Companion_statCountAggregateOutputType | null
    _avg: Companion_statAvgAggregateOutputType | null
    _sum: Companion_statSumAggregateOutputType | null
    _min: Companion_statMinAggregateOutputType | null
    _max: Companion_statMaxAggregateOutputType | null
  }

  export type Companion_statAvgAggregateOutputType = {
    companion_id: number | null
    level: number | null
    atk: number | null
    hp: number | null
    vit: number | null
  }

  export type Companion_statSumAggregateOutputType = {
    companion_id: number | null
    level: number | null
    atk: number | null
    hp: number | null
    vit: number | null
  }

  export type Companion_statMinAggregateOutputType = {
    companion_id: number | null
    level: number | null
    atk: number | null
    hp: number | null
    vit: number | null
  }

  export type Companion_statMaxAggregateOutputType = {
    companion_id: number | null
    level: number | null
    atk: number | null
    hp: number | null
    vit: number | null
  }

  export type Companion_statCountAggregateOutputType = {
    companion_id: number
    level: number
    atk: number
    hp: number
    vit: number
    _all: number
  }


  export type Companion_statAvgAggregateInputType = {
    companion_id?: true
    level?: true
    atk?: true
    hp?: true
    vit?: true
  }

  export type Companion_statSumAggregateInputType = {
    companion_id?: true
    level?: true
    atk?: true
    hp?: true
    vit?: true
  }

  export type Companion_statMinAggregateInputType = {
    companion_id?: true
    level?: true
    atk?: true
    hp?: true
    vit?: true
  }

  export type Companion_statMaxAggregateInputType = {
    companion_id?: true
    level?: true
    atk?: true
    hp?: true
    vit?: true
  }

  export type Companion_statCountAggregateInputType = {
    companion_id?: true
    level?: true
    atk?: true
    hp?: true
    vit?: true
    _all?: true
  }

  export type Companion_statAggregateArgs = {
    /**
     * Filter which companion_stat to aggregate.
     * 
    **/
    where?: companion_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companion_stats to fetch.
     * 
    **/
    orderBy?: Enumerable<companion_statOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: companion_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companion_stats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companion_stats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companion_stats
    **/
    _count?: true | Companion_statCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Companion_statAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Companion_statSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Companion_statMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Companion_statMaxAggregateInputType
  }

  export type GetCompanion_statAggregateType<T extends Companion_statAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanion_stat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanion_stat[P]>
      : GetScalarType<T[P], AggregateCompanion_stat[P]>
  }




  export type Companion_statGroupByArgs = {
    where?: companion_statWhereInput
    orderBy?: Enumerable<companion_statOrderByWithAggregationInput>
    by: Array<Companion_statScalarFieldEnum>
    having?: companion_statScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Companion_statCountAggregateInputType | true
    _avg?: Companion_statAvgAggregateInputType
    _sum?: Companion_statSumAggregateInputType
    _min?: Companion_statMinAggregateInputType
    _max?: Companion_statMaxAggregateInputType
  }


  export type Companion_statGroupByOutputType = {
    companion_id: number
    level: number
    atk: number
    hp: number
    vit: number
    _count: Companion_statCountAggregateOutputType | null
    _avg: Companion_statAvgAggregateOutputType | null
    _sum: Companion_statSumAggregateOutputType | null
    _min: Companion_statMinAggregateOutputType | null
    _max: Companion_statMaxAggregateOutputType | null
  }

  type GetCompanion_statGroupByPayload<T extends Companion_statGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Companion_statGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Companion_statGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Companion_statGroupByOutputType[P]>
            : GetScalarType<T[P], Companion_statGroupByOutputType[P]>
        }
      >
    >


  export type companion_statSelect = {
    companion_id?: boolean
    level?: boolean
    atk?: boolean
    hp?: boolean
    vit?: boolean
    companion?: boolean | companionArgs
  }

  export type companion_statInclude = {
    companion?: boolean | companionArgs
  }

  export type companion_statGetPayload<
    S extends boolean | null | undefined | companion_statArgs,
    U = keyof S
      > = S extends true
        ? companion_stat
    : S extends undefined
    ? never
    : S extends companion_statArgs | companion_statFindManyArgs
    ?'include' extends U
    ? companion_stat  & {
    [P in TrueKeys<S['include']>]:
        P extends 'companion' ? companionGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'companion' ? companionGetPayload<S['select'][P]> :  P extends keyof companion_stat ? companion_stat[P] : never
  } 
    : companion_stat
  : companion_stat


  type companion_statCountArgs = Merge<
    Omit<companion_statFindManyArgs, 'select' | 'include'> & {
      select?: Companion_statCountAggregateInputType | true
    }
  >

  export interface companion_statDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Companion_stat that matches the filter.
     * @param {companion_statFindUniqueArgs} args - Arguments to find a Companion_stat
     * @example
     * // Get one Companion_stat
     * const companion_stat = await prisma.companion_stat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends companion_statFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, companion_statFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'companion_stat'> extends True ? CheckSelect<T, Prisma__companion_statClient<companion_stat>, Prisma__companion_statClient<companion_statGetPayload<T>>> : CheckSelect<T, Prisma__companion_statClient<companion_stat | null >, Prisma__companion_statClient<companion_statGetPayload<T> | null >>

    /**
     * Find the first Companion_stat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_statFindFirstArgs} args - Arguments to find a Companion_stat
     * @example
     * // Get one Companion_stat
     * const companion_stat = await prisma.companion_stat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends companion_statFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, companion_statFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'companion_stat'> extends True ? CheckSelect<T, Prisma__companion_statClient<companion_stat>, Prisma__companion_statClient<companion_statGetPayload<T>>> : CheckSelect<T, Prisma__companion_statClient<companion_stat | null >, Prisma__companion_statClient<companion_statGetPayload<T> | null >>

    /**
     * Find zero or more Companion_stats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_statFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companion_stats
     * const companion_stats = await prisma.companion_stat.findMany()
     * 
     * // Get first 10 Companion_stats
     * const companion_stats = await prisma.companion_stat.findMany({ take: 10 })
     * 
     * // Only select the `companion_id`
     * const companion_statWithCompanion_idOnly = await prisma.companion_stat.findMany({ select: { companion_id: true } })
     * 
    **/
    findMany<T extends companion_statFindManyArgs>(
      args?: SelectSubset<T, companion_statFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<companion_stat>>, PrismaPromise<Array<companion_statGetPayload<T>>>>

    /**
     * Create a Companion_stat.
     * @param {companion_statCreateArgs} args - Arguments to create a Companion_stat.
     * @example
     * // Create one Companion_stat
     * const Companion_stat = await prisma.companion_stat.create({
     *   data: {
     *     // ... data to create a Companion_stat
     *   }
     * })
     * 
    **/
    create<T extends companion_statCreateArgs>(
      args: SelectSubset<T, companion_statCreateArgs>
    ): CheckSelect<T, Prisma__companion_statClient<companion_stat>, Prisma__companion_statClient<companion_statGetPayload<T>>>

    /**
     * Create many Companion_stats.
     *     @param {companion_statCreateManyArgs} args - Arguments to create many Companion_stats.
     *     @example
     *     // Create many Companion_stats
     *     const companion_stat = await prisma.companion_stat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends companion_statCreateManyArgs>(
      args?: SelectSubset<T, companion_statCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Companion_stat.
     * @param {companion_statDeleteArgs} args - Arguments to delete one Companion_stat.
     * @example
     * // Delete one Companion_stat
     * const Companion_stat = await prisma.companion_stat.delete({
     *   where: {
     *     // ... filter to delete one Companion_stat
     *   }
     * })
     * 
    **/
    delete<T extends companion_statDeleteArgs>(
      args: SelectSubset<T, companion_statDeleteArgs>
    ): CheckSelect<T, Prisma__companion_statClient<companion_stat>, Prisma__companion_statClient<companion_statGetPayload<T>>>

    /**
     * Update one Companion_stat.
     * @param {companion_statUpdateArgs} args - Arguments to update one Companion_stat.
     * @example
     * // Update one Companion_stat
     * const companion_stat = await prisma.companion_stat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends companion_statUpdateArgs>(
      args: SelectSubset<T, companion_statUpdateArgs>
    ): CheckSelect<T, Prisma__companion_statClient<companion_stat>, Prisma__companion_statClient<companion_statGetPayload<T>>>

    /**
     * Delete zero or more Companion_stats.
     * @param {companion_statDeleteManyArgs} args - Arguments to filter Companion_stats to delete.
     * @example
     * // Delete a few Companion_stats
     * const { count } = await prisma.companion_stat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends companion_statDeleteManyArgs>(
      args?: SelectSubset<T, companion_statDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companion_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_statUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companion_stats
     * const companion_stat = await prisma.companion_stat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends companion_statUpdateManyArgs>(
      args: SelectSubset<T, companion_statUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Companion_stat.
     * @param {companion_statUpsertArgs} args - Arguments to update or create a Companion_stat.
     * @example
     * // Update or create a Companion_stat
     * const companion_stat = await prisma.companion_stat.upsert({
     *   create: {
     *     // ... data to create a Companion_stat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companion_stat we want to update
     *   }
     * })
    **/
    upsert<T extends companion_statUpsertArgs>(
      args: SelectSubset<T, companion_statUpsertArgs>
    ): CheckSelect<T, Prisma__companion_statClient<companion_stat>, Prisma__companion_statClient<companion_statGetPayload<T>>>

    /**
     * Count the number of Companion_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companion_statCountArgs} args - Arguments to filter Companion_stats to count.
     * @example
     * // Count the number of Companion_stats
     * const count = await prisma.companion_stat.count({
     *   where: {
     *     // ... the filter for the Companion_stats we want to count
     *   }
     * })
    **/
    count<T extends companion_statCountArgs>(
      args?: Subset<T, companion_statCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Companion_statCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companion_stat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Companion_statAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Companion_statAggregateArgs>(args: Subset<T, Companion_statAggregateArgs>): PrismaPromise<GetCompanion_statAggregateType<T>>

    /**
     * Group by Companion_stat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Companion_statGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Companion_statGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Companion_statGroupByArgs['orderBy'] }
        : { orderBy?: Companion_statGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Companion_statGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanion_statGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for companion_stat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__companion_statClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    companion<T extends companionArgs = {}>(args?: Subset<T, companionArgs>): CheckSelect<T, Prisma__companionClient<companion | null >, Prisma__companionClient<companionGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * companion_stat findUnique
   */
  export type companion_statFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the companion_stat
     * 
    **/
    select?: companion_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_statInclude | null
    /**
     * Throw an Error if a companion_stat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which companion_stat to fetch.
     * 
    **/
    where: companion_statWhereUniqueInput
  }


  /**
   * companion_stat findFirst
   */
  export type companion_statFindFirstArgs = {
    /**
     * Select specific fields to fetch from the companion_stat
     * 
    **/
    select?: companion_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_statInclude | null
    /**
     * Throw an Error if a companion_stat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which companion_stat to fetch.
     * 
    **/
    where?: companion_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companion_stats to fetch.
     * 
    **/
    orderBy?: Enumerable<companion_statOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companion_stats.
     * 
    **/
    cursor?: companion_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companion_stats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companion_stats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companion_stats.
     * 
    **/
    distinct?: Enumerable<Companion_statScalarFieldEnum>
  }


  /**
   * companion_stat findMany
   */
  export type companion_statFindManyArgs = {
    /**
     * Select specific fields to fetch from the companion_stat
     * 
    **/
    select?: companion_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_statInclude | null
    /**
     * Filter, which companion_stats to fetch.
     * 
    **/
    where?: companion_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companion_stats to fetch.
     * 
    **/
    orderBy?: Enumerable<companion_statOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companion_stats.
     * 
    **/
    cursor?: companion_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companion_stats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companion_stats.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Companion_statScalarFieldEnum>
  }


  /**
   * companion_stat create
   */
  export type companion_statCreateArgs = {
    /**
     * Select specific fields to fetch from the companion_stat
     * 
    **/
    select?: companion_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_statInclude | null
    /**
     * The data needed to create a companion_stat.
     * 
    **/
    data: XOR<companion_statCreateInput, companion_statUncheckedCreateInput>
  }


  /**
   * companion_stat createMany
   */
  export type companion_statCreateManyArgs = {
    /**
     * The data used to create many companion_stats.
     * 
    **/
    data: Enumerable<companion_statCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * companion_stat update
   */
  export type companion_statUpdateArgs = {
    /**
     * Select specific fields to fetch from the companion_stat
     * 
    **/
    select?: companion_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_statInclude | null
    /**
     * The data needed to update a companion_stat.
     * 
    **/
    data: XOR<companion_statUpdateInput, companion_statUncheckedUpdateInput>
    /**
     * Choose, which companion_stat to update.
     * 
    **/
    where: companion_statWhereUniqueInput
  }


  /**
   * companion_stat updateMany
   */
  export type companion_statUpdateManyArgs = {
    /**
     * The data used to update companion_stats.
     * 
    **/
    data: XOR<companion_statUpdateManyMutationInput, companion_statUncheckedUpdateManyInput>
    /**
     * Filter which companion_stats to update
     * 
    **/
    where?: companion_statWhereInput
  }


  /**
   * companion_stat upsert
   */
  export type companion_statUpsertArgs = {
    /**
     * Select specific fields to fetch from the companion_stat
     * 
    **/
    select?: companion_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_statInclude | null
    /**
     * The filter to search for the companion_stat to update in case it exists.
     * 
    **/
    where: companion_statWhereUniqueInput
    /**
     * In case the companion_stat found by the `where` argument doesn't exist, create a new companion_stat with this data.
     * 
    **/
    create: XOR<companion_statCreateInput, companion_statUncheckedCreateInput>
    /**
     * In case the companion_stat was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<companion_statUpdateInput, companion_statUncheckedUpdateInput>
  }


  /**
   * companion_stat delete
   */
  export type companion_statDeleteArgs = {
    /**
     * Select specific fields to fetch from the companion_stat
     * 
    **/
    select?: companion_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_statInclude | null
    /**
     * Filter which companion_stat to delete.
     * 
    **/
    where: companion_statWhereUniqueInput
  }


  /**
   * companion_stat deleteMany
   */
  export type companion_statDeleteManyArgs = {
    /**
     * Filter which companion_stats to delete
     * 
    **/
    where?: companion_statWhereInput
  }


  /**
   * companion_stat without action
   */
  export type companion_statArgs = {
    /**
     * Select specific fields to fetch from the companion_stat
     * 
    **/
    select?: companion_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: companion_statInclude | null
  }



  /**
   * Model costume
   */


  export type AggregateCostume = {
    _count: CostumeCountAggregateOutputType | null
    _avg: CostumeAvgAggregateOutputType | null
    _sum: CostumeSumAggregateOutputType | null
    _min: CostumeMinAggregateOutputType | null
    _max: CostumeMaxAggregateOutputType | null
  }

  export type CostumeAvgAggregateOutputType = {
    costume_id: number | null
    character_id: number | null
    emblem_id: number | null
  }

  export type CostumeSumAggregateOutputType = {
    costume_id: number | null
    character_id: number | null
    emblem_id: number | null
  }

  export type CostumeMinAggregateOutputType = {
    costume_id: number | null
    character_id: number | null
    emblem_id: number | null
    weapon_type: string | null
    rarity: string | null
    release_time: Date | null
    is_ex_costume: boolean | null
    slug: string | null
    title: string | null
    description: string | null
    image_path_base: string | null
  }

  export type CostumeMaxAggregateOutputType = {
    costume_id: number | null
    character_id: number | null
    emblem_id: number | null
    weapon_type: string | null
    rarity: string | null
    release_time: Date | null
    is_ex_costume: boolean | null
    slug: string | null
    title: string | null
    description: string | null
    image_path_base: string | null
  }

  export type CostumeCountAggregateOutputType = {
    costume_id: number
    character_id: number
    emblem_id: number
    weapon_type: number
    rarity: number
    release_time: number
    is_ex_costume: number
    slug: number
    title: number
    description: number
    image_path_base: number
    _all: number
  }


  export type CostumeAvgAggregateInputType = {
    costume_id?: true
    character_id?: true
    emblem_id?: true
  }

  export type CostumeSumAggregateInputType = {
    costume_id?: true
    character_id?: true
    emblem_id?: true
  }

  export type CostumeMinAggregateInputType = {
    costume_id?: true
    character_id?: true
    emblem_id?: true
    weapon_type?: true
    rarity?: true
    release_time?: true
    is_ex_costume?: true
    slug?: true
    title?: true
    description?: true
    image_path_base?: true
  }

  export type CostumeMaxAggregateInputType = {
    costume_id?: true
    character_id?: true
    emblem_id?: true
    weapon_type?: true
    rarity?: true
    release_time?: true
    is_ex_costume?: true
    slug?: true
    title?: true
    description?: true
    image_path_base?: true
  }

  export type CostumeCountAggregateInputType = {
    costume_id?: true
    character_id?: true
    emblem_id?: true
    weapon_type?: true
    rarity?: true
    release_time?: true
    is_ex_costume?: true
    slug?: true
    title?: true
    description?: true
    image_path_base?: true
    _all?: true
  }

  export type CostumeAggregateArgs = {
    /**
     * Filter which costume to aggregate.
     * 
    **/
    where?: costumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costumes to fetch.
     * 
    **/
    orderBy?: Enumerable<costumeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: costumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costumes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costumes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned costumes
    **/
    _count?: true | CostumeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostumeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostumeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostumeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostumeMaxAggregateInputType
  }

  export type GetCostumeAggregateType<T extends CostumeAggregateArgs> = {
        [P in keyof T & keyof AggregateCostume]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostume[P]>
      : GetScalarType<T[P], AggregateCostume[P]>
  }




  export type CostumeGroupByArgs = {
    where?: costumeWhereInput
    orderBy?: Enumerable<costumeOrderByWithAggregationInput>
    by: Array<CostumeScalarFieldEnum>
    having?: costumeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostumeCountAggregateInputType | true
    _avg?: CostumeAvgAggregateInputType
    _sum?: CostumeSumAggregateInputType
    _min?: CostumeMinAggregateInputType
    _max?: CostumeMaxAggregateInputType
  }


  export type CostumeGroupByOutputType = {
    costume_id: number
    character_id: number
    emblem_id: number | null
    weapon_type: string | null
    rarity: string | null
    release_time: Date
    is_ex_costume: boolean
    slug: string | null
    title: string | null
    description: string | null
    image_path_base: string | null
    _count: CostumeCountAggregateOutputType | null
    _avg: CostumeAvgAggregateOutputType | null
    _sum: CostumeSumAggregateOutputType | null
    _min: CostumeMinAggregateOutputType | null
    _max: CostumeMaxAggregateOutputType | null
  }

  type GetCostumeGroupByPayload<T extends CostumeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CostumeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostumeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostumeGroupByOutputType[P]>
            : GetScalarType<T[P], CostumeGroupByOutputType[P]>
        }
      >
    >


  export type costumeSelect = {
    costume_id?: boolean
    character_id?: boolean
    emblem_id?: boolean
    weapon_type?: boolean
    rarity?: boolean
    release_time?: boolean
    is_ex_costume?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    image_path_base?: boolean
    character?: boolean | characterArgs
    emblem?: boolean | emblemArgs
    costume_ability_link?: boolean | costume_ability_linkFindManyArgs
    costume_skill_link?: boolean | costume_skill_linkFindManyArgs
    costume_stat?: boolean | costume_statFindManyArgs
    _count?: boolean | CostumeCountOutputTypeArgs
  }

  export type costumeInclude = {
    character?: boolean | characterArgs
    emblem?: boolean | emblemArgs
    costume_ability_link?: boolean | costume_ability_linkFindManyArgs
    costume_skill_link?: boolean | costume_skill_linkFindManyArgs
    costume_stat?: boolean | costume_statFindManyArgs
    _count?: boolean | CostumeCountOutputTypeArgs
  }

  export type costumeGetPayload<
    S extends boolean | null | undefined | costumeArgs,
    U = keyof S
      > = S extends true
        ? costume
    : S extends undefined
    ? never
    : S extends costumeArgs | costumeFindManyArgs
    ?'include' extends U
    ? costume  & {
    [P in TrueKeys<S['include']>]:
        P extends 'character' ? characterGetPayload<S['include'][P]> :
        P extends 'emblem' ? emblemGetPayload<S['include'][P]> | null :
        P extends 'costume_ability_link' ? Array < costume_ability_linkGetPayload<S['include'][P]>>  :
        P extends 'costume_skill_link' ? Array < costume_skill_linkGetPayload<S['include'][P]>>  :
        P extends 'costume_stat' ? Array < costume_statGetPayload<S['include'][P]>>  :
        P extends '_count' ? CostumeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'character' ? characterGetPayload<S['select'][P]> :
        P extends 'emblem' ? emblemGetPayload<S['select'][P]> | null :
        P extends 'costume_ability_link' ? Array < costume_ability_linkGetPayload<S['select'][P]>>  :
        P extends 'costume_skill_link' ? Array < costume_skill_linkGetPayload<S['select'][P]>>  :
        P extends 'costume_stat' ? Array < costume_statGetPayload<S['select'][P]>>  :
        P extends '_count' ? CostumeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof costume ? costume[P] : never
  } 
    : costume
  : costume


  type costumeCountArgs = Merge<
    Omit<costumeFindManyArgs, 'select' | 'include'> & {
      select?: CostumeCountAggregateInputType | true
    }
  >

  export interface costumeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Costume that matches the filter.
     * @param {costumeFindUniqueArgs} args - Arguments to find a Costume
     * @example
     * // Get one Costume
     * const costume = await prisma.costume.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends costumeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, costumeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'costume'> extends True ? CheckSelect<T, Prisma__costumeClient<costume>, Prisma__costumeClient<costumeGetPayload<T>>> : CheckSelect<T, Prisma__costumeClient<costume | null >, Prisma__costumeClient<costumeGetPayload<T> | null >>

    /**
     * Find the first Costume that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costumeFindFirstArgs} args - Arguments to find a Costume
     * @example
     * // Get one Costume
     * const costume = await prisma.costume.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends costumeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, costumeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'costume'> extends True ? CheckSelect<T, Prisma__costumeClient<costume>, Prisma__costumeClient<costumeGetPayload<T>>> : CheckSelect<T, Prisma__costumeClient<costume | null >, Prisma__costumeClient<costumeGetPayload<T> | null >>

    /**
     * Find zero or more Costumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costumeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Costumes
     * const costumes = await prisma.costume.findMany()
     * 
     * // Get first 10 Costumes
     * const costumes = await prisma.costume.findMany({ take: 10 })
     * 
     * // Only select the `costume_id`
     * const costumeWithCostume_idOnly = await prisma.costume.findMany({ select: { costume_id: true } })
     * 
    **/
    findMany<T extends costumeFindManyArgs>(
      args?: SelectSubset<T, costumeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<costume>>, PrismaPromise<Array<costumeGetPayload<T>>>>

    /**
     * Create a Costume.
     * @param {costumeCreateArgs} args - Arguments to create a Costume.
     * @example
     * // Create one Costume
     * const Costume = await prisma.costume.create({
     *   data: {
     *     // ... data to create a Costume
     *   }
     * })
     * 
    **/
    create<T extends costumeCreateArgs>(
      args: SelectSubset<T, costumeCreateArgs>
    ): CheckSelect<T, Prisma__costumeClient<costume>, Prisma__costumeClient<costumeGetPayload<T>>>

    /**
     * Create many Costumes.
     *     @param {costumeCreateManyArgs} args - Arguments to create many Costumes.
     *     @example
     *     // Create many Costumes
     *     const costume = await prisma.costume.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends costumeCreateManyArgs>(
      args?: SelectSubset<T, costumeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Costume.
     * @param {costumeDeleteArgs} args - Arguments to delete one Costume.
     * @example
     * // Delete one Costume
     * const Costume = await prisma.costume.delete({
     *   where: {
     *     // ... filter to delete one Costume
     *   }
     * })
     * 
    **/
    delete<T extends costumeDeleteArgs>(
      args: SelectSubset<T, costumeDeleteArgs>
    ): CheckSelect<T, Prisma__costumeClient<costume>, Prisma__costumeClient<costumeGetPayload<T>>>

    /**
     * Update one Costume.
     * @param {costumeUpdateArgs} args - Arguments to update one Costume.
     * @example
     * // Update one Costume
     * const costume = await prisma.costume.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends costumeUpdateArgs>(
      args: SelectSubset<T, costumeUpdateArgs>
    ): CheckSelect<T, Prisma__costumeClient<costume>, Prisma__costumeClient<costumeGetPayload<T>>>

    /**
     * Delete zero or more Costumes.
     * @param {costumeDeleteManyArgs} args - Arguments to filter Costumes to delete.
     * @example
     * // Delete a few Costumes
     * const { count } = await prisma.costume.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends costumeDeleteManyArgs>(
      args?: SelectSubset<T, costumeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Costumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costumeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Costumes
     * const costume = await prisma.costume.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends costumeUpdateManyArgs>(
      args: SelectSubset<T, costumeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Costume.
     * @param {costumeUpsertArgs} args - Arguments to update or create a Costume.
     * @example
     * // Update or create a Costume
     * const costume = await prisma.costume.upsert({
     *   create: {
     *     // ... data to create a Costume
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Costume we want to update
     *   }
     * })
    **/
    upsert<T extends costumeUpsertArgs>(
      args: SelectSubset<T, costumeUpsertArgs>
    ): CheckSelect<T, Prisma__costumeClient<costume>, Prisma__costumeClient<costumeGetPayload<T>>>

    /**
     * Count the number of Costumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costumeCountArgs} args - Arguments to filter Costumes to count.
     * @example
     * // Count the number of Costumes
     * const count = await prisma.costume.count({
     *   where: {
     *     // ... the filter for the Costumes we want to count
     *   }
     * })
    **/
    count<T extends costumeCountArgs>(
      args?: Subset<T, costumeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostumeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Costume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostumeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostumeAggregateArgs>(args: Subset<T, CostumeAggregateArgs>): PrismaPromise<GetCostumeAggregateType<T>>

    /**
     * Group by Costume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostumeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostumeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostumeGroupByArgs['orderBy'] }
        : { orderBy?: CostumeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostumeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostumeGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for costume.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__costumeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    character<T extends characterArgs = {}>(args?: Subset<T, characterArgs>): CheckSelect<T, Prisma__characterClient<character | null >, Prisma__characterClient<characterGetPayload<T> | null >>;

    emblem<T extends emblemArgs = {}>(args?: Subset<T, emblemArgs>): CheckSelect<T, Prisma__emblemClient<emblem | null >, Prisma__emblemClient<emblemGetPayload<T> | null >>;

    costume_ability_link<T extends costume_ability_linkFindManyArgs = {}>(args?: Subset<T, costume_ability_linkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<costume_ability_link>>, PrismaPromise<Array<costume_ability_linkGetPayload<T>>>>;

    costume_skill_link<T extends costume_skill_linkFindManyArgs = {}>(args?: Subset<T, costume_skill_linkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<costume_skill_link>>, PrismaPromise<Array<costume_skill_linkGetPayload<T>>>>;

    costume_stat<T extends costume_statFindManyArgs = {}>(args?: Subset<T, costume_statFindManyArgs>): CheckSelect<T, PrismaPromise<Array<costume_stat>>, PrismaPromise<Array<costume_statGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * costume findUnique
   */
  export type costumeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the costume
     * 
    **/
    select?: costumeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costumeInclude | null
    /**
     * Throw an Error if a costume can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which costume to fetch.
     * 
    **/
    where: costumeWhereUniqueInput
  }


  /**
   * costume findFirst
   */
  export type costumeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the costume
     * 
    **/
    select?: costumeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costumeInclude | null
    /**
     * Throw an Error if a costume can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which costume to fetch.
     * 
    **/
    where?: costumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costumes to fetch.
     * 
    **/
    orderBy?: Enumerable<costumeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for costumes.
     * 
    **/
    cursor?: costumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costumes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costumes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of costumes.
     * 
    **/
    distinct?: Enumerable<CostumeScalarFieldEnum>
  }


  /**
   * costume findMany
   */
  export type costumeFindManyArgs = {
    /**
     * Select specific fields to fetch from the costume
     * 
    **/
    select?: costumeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costumeInclude | null
    /**
     * Filter, which costumes to fetch.
     * 
    **/
    where?: costumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costumes to fetch.
     * 
    **/
    orderBy?: Enumerable<costumeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing costumes.
     * 
    **/
    cursor?: costumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costumes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costumes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CostumeScalarFieldEnum>
  }


  /**
   * costume create
   */
  export type costumeCreateArgs = {
    /**
     * Select specific fields to fetch from the costume
     * 
    **/
    select?: costumeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costumeInclude | null
    /**
     * The data needed to create a costume.
     * 
    **/
    data: XOR<costumeCreateInput, costumeUncheckedCreateInput>
  }


  /**
   * costume createMany
   */
  export type costumeCreateManyArgs = {
    /**
     * The data used to create many costumes.
     * 
    **/
    data: Enumerable<costumeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * costume update
   */
  export type costumeUpdateArgs = {
    /**
     * Select specific fields to fetch from the costume
     * 
    **/
    select?: costumeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costumeInclude | null
    /**
     * The data needed to update a costume.
     * 
    **/
    data: XOR<costumeUpdateInput, costumeUncheckedUpdateInput>
    /**
     * Choose, which costume to update.
     * 
    **/
    where: costumeWhereUniqueInput
  }


  /**
   * costume updateMany
   */
  export type costumeUpdateManyArgs = {
    /**
     * The data used to update costumes.
     * 
    **/
    data: XOR<costumeUpdateManyMutationInput, costumeUncheckedUpdateManyInput>
    /**
     * Filter which costumes to update
     * 
    **/
    where?: costumeWhereInput
  }


  /**
   * costume upsert
   */
  export type costumeUpsertArgs = {
    /**
     * Select specific fields to fetch from the costume
     * 
    **/
    select?: costumeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costumeInclude | null
    /**
     * The filter to search for the costume to update in case it exists.
     * 
    **/
    where: costumeWhereUniqueInput
    /**
     * In case the costume found by the `where` argument doesn't exist, create a new costume with this data.
     * 
    **/
    create: XOR<costumeCreateInput, costumeUncheckedCreateInput>
    /**
     * In case the costume was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<costumeUpdateInput, costumeUncheckedUpdateInput>
  }


  /**
   * costume delete
   */
  export type costumeDeleteArgs = {
    /**
     * Select specific fields to fetch from the costume
     * 
    **/
    select?: costumeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costumeInclude | null
    /**
     * Filter which costume to delete.
     * 
    **/
    where: costumeWhereUniqueInput
  }


  /**
   * costume deleteMany
   */
  export type costumeDeleteManyArgs = {
    /**
     * Filter which costumes to delete
     * 
    **/
    where?: costumeWhereInput
  }


  /**
   * costume without action
   */
  export type costumeArgs = {
    /**
     * Select specific fields to fetch from the costume
     * 
    **/
    select?: costumeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costumeInclude | null
  }



  /**
   * Model costume_ability
   */


  export type AggregateCostume_ability = {
    _count: Costume_abilityCountAggregateOutputType | null
    _avg: Costume_abilityAvgAggregateOutputType | null
    _sum: Costume_abilitySumAggregateOutputType | null
    _min: Costume_abilityMinAggregateOutputType | null
    _max: Costume_abilityMaxAggregateOutputType | null
  }

  export type Costume_abilityAvgAggregateOutputType = {
    ability_id: number | null
    ability_level: number | null
  }

  export type Costume_abilitySumAggregateOutputType = {
    ability_id: number | null
    ability_level: number | null
  }

  export type Costume_abilityMinAggregateOutputType = {
    ability_id: number | null
    ability_level: number | null
    name: string | null
    description: string | null
    image_path_base: string | null
  }

  export type Costume_abilityMaxAggregateOutputType = {
    ability_id: number | null
    ability_level: number | null
    name: string | null
    description: string | null
    image_path_base: string | null
  }

  export type Costume_abilityCountAggregateOutputType = {
    ability_id: number
    ability_level: number
    name: number
    description: number
    image_path_base: number
    _all: number
  }


  export type Costume_abilityAvgAggregateInputType = {
    ability_id?: true
    ability_level?: true
  }

  export type Costume_abilitySumAggregateInputType = {
    ability_id?: true
    ability_level?: true
  }

  export type Costume_abilityMinAggregateInputType = {
    ability_id?: true
    ability_level?: true
    name?: true
    description?: true
    image_path_base?: true
  }

  export type Costume_abilityMaxAggregateInputType = {
    ability_id?: true
    ability_level?: true
    name?: true
    description?: true
    image_path_base?: true
  }

  export type Costume_abilityCountAggregateInputType = {
    ability_id?: true
    ability_level?: true
    name?: true
    description?: true
    image_path_base?: true
    _all?: true
  }

  export type Costume_abilityAggregateArgs = {
    /**
     * Filter which costume_ability to aggregate.
     * 
    **/
    where?: costume_abilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costume_abilities to fetch.
     * 
    **/
    orderBy?: Enumerable<costume_abilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: costume_abilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costume_abilities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costume_abilities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned costume_abilities
    **/
    _count?: true | Costume_abilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Costume_abilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Costume_abilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Costume_abilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Costume_abilityMaxAggregateInputType
  }

  export type GetCostume_abilityAggregateType<T extends Costume_abilityAggregateArgs> = {
        [P in keyof T & keyof AggregateCostume_ability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostume_ability[P]>
      : GetScalarType<T[P], AggregateCostume_ability[P]>
  }




  export type Costume_abilityGroupByArgs = {
    where?: costume_abilityWhereInput
    orderBy?: Enumerable<costume_abilityOrderByWithAggregationInput>
    by: Array<Costume_abilityScalarFieldEnum>
    having?: costume_abilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Costume_abilityCountAggregateInputType | true
    _avg?: Costume_abilityAvgAggregateInputType
    _sum?: Costume_abilitySumAggregateInputType
    _min?: Costume_abilityMinAggregateInputType
    _max?: Costume_abilityMaxAggregateInputType
  }


  export type Costume_abilityGroupByOutputType = {
    ability_id: number
    ability_level: number
    name: string | null
    description: string | null
    image_path_base: string | null
    _count: Costume_abilityCountAggregateOutputType | null
    _avg: Costume_abilityAvgAggregateOutputType | null
    _sum: Costume_abilitySumAggregateOutputType | null
    _min: Costume_abilityMinAggregateOutputType | null
    _max: Costume_abilityMaxAggregateOutputType | null
  }

  type GetCostume_abilityGroupByPayload<T extends Costume_abilityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Costume_abilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Costume_abilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Costume_abilityGroupByOutputType[P]>
            : GetScalarType<T[P], Costume_abilityGroupByOutputType[P]>
        }
      >
    >


  export type costume_abilitySelect = {
    ability_id?: boolean
    ability_level?: boolean
    name?: boolean
    description?: boolean
    image_path_base?: boolean
    costume_ability_link?: boolean | costume_ability_linkFindManyArgs
    _count?: boolean | Costume_abilityCountOutputTypeArgs
  }

  export type costume_abilityInclude = {
    costume_ability_link?: boolean | costume_ability_linkFindManyArgs
    _count?: boolean | Costume_abilityCountOutputTypeArgs
  }

  export type costume_abilityGetPayload<
    S extends boolean | null | undefined | costume_abilityArgs,
    U = keyof S
      > = S extends true
        ? costume_ability
    : S extends undefined
    ? never
    : S extends costume_abilityArgs | costume_abilityFindManyArgs
    ?'include' extends U
    ? costume_ability  & {
    [P in TrueKeys<S['include']>]:
        P extends 'costume_ability_link' ? Array < costume_ability_linkGetPayload<S['include'][P]>>  :
        P extends '_count' ? Costume_abilityCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'costume_ability_link' ? Array < costume_ability_linkGetPayload<S['select'][P]>>  :
        P extends '_count' ? Costume_abilityCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof costume_ability ? costume_ability[P] : never
  } 
    : costume_ability
  : costume_ability


  type costume_abilityCountArgs = Merge<
    Omit<costume_abilityFindManyArgs, 'select' | 'include'> & {
      select?: Costume_abilityCountAggregateInputType | true
    }
  >

  export interface costume_abilityDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Costume_ability that matches the filter.
     * @param {costume_abilityFindUniqueArgs} args - Arguments to find a Costume_ability
     * @example
     * // Get one Costume_ability
     * const costume_ability = await prisma.costume_ability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends costume_abilityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, costume_abilityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'costume_ability'> extends True ? CheckSelect<T, Prisma__costume_abilityClient<costume_ability>, Prisma__costume_abilityClient<costume_abilityGetPayload<T>>> : CheckSelect<T, Prisma__costume_abilityClient<costume_ability | null >, Prisma__costume_abilityClient<costume_abilityGetPayload<T> | null >>

    /**
     * Find the first Costume_ability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_abilityFindFirstArgs} args - Arguments to find a Costume_ability
     * @example
     * // Get one Costume_ability
     * const costume_ability = await prisma.costume_ability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends costume_abilityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, costume_abilityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'costume_ability'> extends True ? CheckSelect<T, Prisma__costume_abilityClient<costume_ability>, Prisma__costume_abilityClient<costume_abilityGetPayload<T>>> : CheckSelect<T, Prisma__costume_abilityClient<costume_ability | null >, Prisma__costume_abilityClient<costume_abilityGetPayload<T> | null >>

    /**
     * Find zero or more Costume_abilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_abilityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Costume_abilities
     * const costume_abilities = await prisma.costume_ability.findMany()
     * 
     * // Get first 10 Costume_abilities
     * const costume_abilities = await prisma.costume_ability.findMany({ take: 10 })
     * 
     * // Only select the `ability_id`
     * const costume_abilityWithAbility_idOnly = await prisma.costume_ability.findMany({ select: { ability_id: true } })
     * 
    **/
    findMany<T extends costume_abilityFindManyArgs>(
      args?: SelectSubset<T, costume_abilityFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<costume_ability>>, PrismaPromise<Array<costume_abilityGetPayload<T>>>>

    /**
     * Create a Costume_ability.
     * @param {costume_abilityCreateArgs} args - Arguments to create a Costume_ability.
     * @example
     * // Create one Costume_ability
     * const Costume_ability = await prisma.costume_ability.create({
     *   data: {
     *     // ... data to create a Costume_ability
     *   }
     * })
     * 
    **/
    create<T extends costume_abilityCreateArgs>(
      args: SelectSubset<T, costume_abilityCreateArgs>
    ): CheckSelect<T, Prisma__costume_abilityClient<costume_ability>, Prisma__costume_abilityClient<costume_abilityGetPayload<T>>>

    /**
     * Create many Costume_abilities.
     *     @param {costume_abilityCreateManyArgs} args - Arguments to create many Costume_abilities.
     *     @example
     *     // Create many Costume_abilities
     *     const costume_ability = await prisma.costume_ability.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends costume_abilityCreateManyArgs>(
      args?: SelectSubset<T, costume_abilityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Costume_ability.
     * @param {costume_abilityDeleteArgs} args - Arguments to delete one Costume_ability.
     * @example
     * // Delete one Costume_ability
     * const Costume_ability = await prisma.costume_ability.delete({
     *   where: {
     *     // ... filter to delete one Costume_ability
     *   }
     * })
     * 
    **/
    delete<T extends costume_abilityDeleteArgs>(
      args: SelectSubset<T, costume_abilityDeleteArgs>
    ): CheckSelect<T, Prisma__costume_abilityClient<costume_ability>, Prisma__costume_abilityClient<costume_abilityGetPayload<T>>>

    /**
     * Update one Costume_ability.
     * @param {costume_abilityUpdateArgs} args - Arguments to update one Costume_ability.
     * @example
     * // Update one Costume_ability
     * const costume_ability = await prisma.costume_ability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends costume_abilityUpdateArgs>(
      args: SelectSubset<T, costume_abilityUpdateArgs>
    ): CheckSelect<T, Prisma__costume_abilityClient<costume_ability>, Prisma__costume_abilityClient<costume_abilityGetPayload<T>>>

    /**
     * Delete zero or more Costume_abilities.
     * @param {costume_abilityDeleteManyArgs} args - Arguments to filter Costume_abilities to delete.
     * @example
     * // Delete a few Costume_abilities
     * const { count } = await prisma.costume_ability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends costume_abilityDeleteManyArgs>(
      args?: SelectSubset<T, costume_abilityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Costume_abilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_abilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Costume_abilities
     * const costume_ability = await prisma.costume_ability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends costume_abilityUpdateManyArgs>(
      args: SelectSubset<T, costume_abilityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Costume_ability.
     * @param {costume_abilityUpsertArgs} args - Arguments to update or create a Costume_ability.
     * @example
     * // Update or create a Costume_ability
     * const costume_ability = await prisma.costume_ability.upsert({
     *   create: {
     *     // ... data to create a Costume_ability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Costume_ability we want to update
     *   }
     * })
    **/
    upsert<T extends costume_abilityUpsertArgs>(
      args: SelectSubset<T, costume_abilityUpsertArgs>
    ): CheckSelect<T, Prisma__costume_abilityClient<costume_ability>, Prisma__costume_abilityClient<costume_abilityGetPayload<T>>>

    /**
     * Count the number of Costume_abilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_abilityCountArgs} args - Arguments to filter Costume_abilities to count.
     * @example
     * // Count the number of Costume_abilities
     * const count = await prisma.costume_ability.count({
     *   where: {
     *     // ... the filter for the Costume_abilities we want to count
     *   }
     * })
    **/
    count<T extends costume_abilityCountArgs>(
      args?: Subset<T, costume_abilityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Costume_abilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Costume_ability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Costume_abilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Costume_abilityAggregateArgs>(args: Subset<T, Costume_abilityAggregateArgs>): PrismaPromise<GetCostume_abilityAggregateType<T>>

    /**
     * Group by Costume_ability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Costume_abilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Costume_abilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Costume_abilityGroupByArgs['orderBy'] }
        : { orderBy?: Costume_abilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Costume_abilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostume_abilityGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for costume_ability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__costume_abilityClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    costume_ability_link<T extends costume_ability_linkFindManyArgs = {}>(args?: Subset<T, costume_ability_linkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<costume_ability_link>>, PrismaPromise<Array<costume_ability_linkGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * costume_ability findUnique
   */
  export type costume_abilityFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the costume_ability
     * 
    **/
    select?: costume_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_abilityInclude | null
    /**
     * Throw an Error if a costume_ability can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which costume_ability to fetch.
     * 
    **/
    where: costume_abilityWhereUniqueInput
  }


  /**
   * costume_ability findFirst
   */
  export type costume_abilityFindFirstArgs = {
    /**
     * Select specific fields to fetch from the costume_ability
     * 
    **/
    select?: costume_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_abilityInclude | null
    /**
     * Throw an Error if a costume_ability can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which costume_ability to fetch.
     * 
    **/
    where?: costume_abilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costume_abilities to fetch.
     * 
    **/
    orderBy?: Enumerable<costume_abilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for costume_abilities.
     * 
    **/
    cursor?: costume_abilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costume_abilities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costume_abilities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of costume_abilities.
     * 
    **/
    distinct?: Enumerable<Costume_abilityScalarFieldEnum>
  }


  /**
   * costume_ability findMany
   */
  export type costume_abilityFindManyArgs = {
    /**
     * Select specific fields to fetch from the costume_ability
     * 
    **/
    select?: costume_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_abilityInclude | null
    /**
     * Filter, which costume_abilities to fetch.
     * 
    **/
    where?: costume_abilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costume_abilities to fetch.
     * 
    **/
    orderBy?: Enumerable<costume_abilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing costume_abilities.
     * 
    **/
    cursor?: costume_abilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costume_abilities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costume_abilities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Costume_abilityScalarFieldEnum>
  }


  /**
   * costume_ability create
   */
  export type costume_abilityCreateArgs = {
    /**
     * Select specific fields to fetch from the costume_ability
     * 
    **/
    select?: costume_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_abilityInclude | null
    /**
     * The data needed to create a costume_ability.
     * 
    **/
    data: XOR<costume_abilityCreateInput, costume_abilityUncheckedCreateInput>
  }


  /**
   * costume_ability createMany
   */
  export type costume_abilityCreateManyArgs = {
    /**
     * The data used to create many costume_abilities.
     * 
    **/
    data: Enumerable<costume_abilityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * costume_ability update
   */
  export type costume_abilityUpdateArgs = {
    /**
     * Select specific fields to fetch from the costume_ability
     * 
    **/
    select?: costume_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_abilityInclude | null
    /**
     * The data needed to update a costume_ability.
     * 
    **/
    data: XOR<costume_abilityUpdateInput, costume_abilityUncheckedUpdateInput>
    /**
     * Choose, which costume_ability to update.
     * 
    **/
    where: costume_abilityWhereUniqueInput
  }


  /**
   * costume_ability updateMany
   */
  export type costume_abilityUpdateManyArgs = {
    /**
     * The data used to update costume_abilities.
     * 
    **/
    data: XOR<costume_abilityUpdateManyMutationInput, costume_abilityUncheckedUpdateManyInput>
    /**
     * Filter which costume_abilities to update
     * 
    **/
    where?: costume_abilityWhereInput
  }


  /**
   * costume_ability upsert
   */
  export type costume_abilityUpsertArgs = {
    /**
     * Select specific fields to fetch from the costume_ability
     * 
    **/
    select?: costume_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_abilityInclude | null
    /**
     * The filter to search for the costume_ability to update in case it exists.
     * 
    **/
    where: costume_abilityWhereUniqueInput
    /**
     * In case the costume_ability found by the `where` argument doesn't exist, create a new costume_ability with this data.
     * 
    **/
    create: XOR<costume_abilityCreateInput, costume_abilityUncheckedCreateInput>
    /**
     * In case the costume_ability was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<costume_abilityUpdateInput, costume_abilityUncheckedUpdateInput>
  }


  /**
   * costume_ability delete
   */
  export type costume_abilityDeleteArgs = {
    /**
     * Select specific fields to fetch from the costume_ability
     * 
    **/
    select?: costume_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_abilityInclude | null
    /**
     * Filter which costume_ability to delete.
     * 
    **/
    where: costume_abilityWhereUniqueInput
  }


  /**
   * costume_ability deleteMany
   */
  export type costume_abilityDeleteManyArgs = {
    /**
     * Filter which costume_abilities to delete
     * 
    **/
    where?: costume_abilityWhereInput
  }


  /**
   * costume_ability without action
   */
  export type costume_abilityArgs = {
    /**
     * Select specific fields to fetch from the costume_ability
     * 
    **/
    select?: costume_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_abilityInclude | null
  }



  /**
   * Model costume_ability_link
   */


  export type AggregateCostume_ability_link = {
    _count: Costume_ability_linkCountAggregateOutputType | null
    _avg: Costume_ability_linkAvgAggregateOutputType | null
    _sum: Costume_ability_linkSumAggregateOutputType | null
    _min: Costume_ability_linkMinAggregateOutputType | null
    _max: Costume_ability_linkMaxAggregateOutputType | null
  }

  export type Costume_ability_linkAvgAggregateOutputType = {
    costume_id: number | null
    ability_slot: number | null
    ability_id: number | null
    ability_level: number | null
  }

  export type Costume_ability_linkSumAggregateOutputType = {
    costume_id: number | null
    ability_slot: number | null
    ability_id: number | null
    ability_level: number | null
  }

  export type Costume_ability_linkMinAggregateOutputType = {
    costume_id: number | null
    ability_slot: number | null
    ability_id: number | null
    ability_level: number | null
  }

  export type Costume_ability_linkMaxAggregateOutputType = {
    costume_id: number | null
    ability_slot: number | null
    ability_id: number | null
    ability_level: number | null
  }

  export type Costume_ability_linkCountAggregateOutputType = {
    costume_id: number
    ability_slot: number
    ability_id: number
    ability_level: number
    _all: number
  }


  export type Costume_ability_linkAvgAggregateInputType = {
    costume_id?: true
    ability_slot?: true
    ability_id?: true
    ability_level?: true
  }

  export type Costume_ability_linkSumAggregateInputType = {
    costume_id?: true
    ability_slot?: true
    ability_id?: true
    ability_level?: true
  }

  export type Costume_ability_linkMinAggregateInputType = {
    costume_id?: true
    ability_slot?: true
    ability_id?: true
    ability_level?: true
  }

  export type Costume_ability_linkMaxAggregateInputType = {
    costume_id?: true
    ability_slot?: true
    ability_id?: true
    ability_level?: true
  }

  export type Costume_ability_linkCountAggregateInputType = {
    costume_id?: true
    ability_slot?: true
    ability_id?: true
    ability_level?: true
    _all?: true
  }

  export type Costume_ability_linkAggregateArgs = {
    /**
     * Filter which costume_ability_link to aggregate.
     * 
    **/
    where?: costume_ability_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costume_ability_links to fetch.
     * 
    **/
    orderBy?: Enumerable<costume_ability_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: costume_ability_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costume_ability_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costume_ability_links.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned costume_ability_links
    **/
    _count?: true | Costume_ability_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Costume_ability_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Costume_ability_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Costume_ability_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Costume_ability_linkMaxAggregateInputType
  }

  export type GetCostume_ability_linkAggregateType<T extends Costume_ability_linkAggregateArgs> = {
        [P in keyof T & keyof AggregateCostume_ability_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostume_ability_link[P]>
      : GetScalarType<T[P], AggregateCostume_ability_link[P]>
  }




  export type Costume_ability_linkGroupByArgs = {
    where?: costume_ability_linkWhereInput
    orderBy?: Enumerable<costume_ability_linkOrderByWithAggregationInput>
    by: Array<Costume_ability_linkScalarFieldEnum>
    having?: costume_ability_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Costume_ability_linkCountAggregateInputType | true
    _avg?: Costume_ability_linkAvgAggregateInputType
    _sum?: Costume_ability_linkSumAggregateInputType
    _min?: Costume_ability_linkMinAggregateInputType
    _max?: Costume_ability_linkMaxAggregateInputType
  }


  export type Costume_ability_linkGroupByOutputType = {
    costume_id: number
    ability_slot: number
    ability_id: number
    ability_level: number
    _count: Costume_ability_linkCountAggregateOutputType | null
    _avg: Costume_ability_linkAvgAggregateOutputType | null
    _sum: Costume_ability_linkSumAggregateOutputType | null
    _min: Costume_ability_linkMinAggregateOutputType | null
    _max: Costume_ability_linkMaxAggregateOutputType | null
  }

  type GetCostume_ability_linkGroupByPayload<T extends Costume_ability_linkGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Costume_ability_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Costume_ability_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Costume_ability_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Costume_ability_linkGroupByOutputType[P]>
        }
      >
    >


  export type costume_ability_linkSelect = {
    costume_id?: boolean
    ability_slot?: boolean
    ability_id?: boolean
    ability_level?: boolean
    costume_ability?: boolean | costume_abilityArgs
    costume?: boolean | costumeArgs
  }

  export type costume_ability_linkInclude = {
    costume_ability?: boolean | costume_abilityArgs
    costume?: boolean | costumeArgs
  }

  export type costume_ability_linkGetPayload<
    S extends boolean | null | undefined | costume_ability_linkArgs,
    U = keyof S
      > = S extends true
        ? costume_ability_link
    : S extends undefined
    ? never
    : S extends costume_ability_linkArgs | costume_ability_linkFindManyArgs
    ?'include' extends U
    ? costume_ability_link  & {
    [P in TrueKeys<S['include']>]:
        P extends 'costume_ability' ? costume_abilityGetPayload<S['include'][P]> :
        P extends 'costume' ? costumeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'costume_ability' ? costume_abilityGetPayload<S['select'][P]> :
        P extends 'costume' ? costumeGetPayload<S['select'][P]> :  P extends keyof costume_ability_link ? costume_ability_link[P] : never
  } 
    : costume_ability_link
  : costume_ability_link


  type costume_ability_linkCountArgs = Merge<
    Omit<costume_ability_linkFindManyArgs, 'select' | 'include'> & {
      select?: Costume_ability_linkCountAggregateInputType | true
    }
  >

  export interface costume_ability_linkDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Costume_ability_link that matches the filter.
     * @param {costume_ability_linkFindUniqueArgs} args - Arguments to find a Costume_ability_link
     * @example
     * // Get one Costume_ability_link
     * const costume_ability_link = await prisma.costume_ability_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends costume_ability_linkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, costume_ability_linkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'costume_ability_link'> extends True ? CheckSelect<T, Prisma__costume_ability_linkClient<costume_ability_link>, Prisma__costume_ability_linkClient<costume_ability_linkGetPayload<T>>> : CheckSelect<T, Prisma__costume_ability_linkClient<costume_ability_link | null >, Prisma__costume_ability_linkClient<costume_ability_linkGetPayload<T> | null >>

    /**
     * Find the first Costume_ability_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_ability_linkFindFirstArgs} args - Arguments to find a Costume_ability_link
     * @example
     * // Get one Costume_ability_link
     * const costume_ability_link = await prisma.costume_ability_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends costume_ability_linkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, costume_ability_linkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'costume_ability_link'> extends True ? CheckSelect<T, Prisma__costume_ability_linkClient<costume_ability_link>, Prisma__costume_ability_linkClient<costume_ability_linkGetPayload<T>>> : CheckSelect<T, Prisma__costume_ability_linkClient<costume_ability_link | null >, Prisma__costume_ability_linkClient<costume_ability_linkGetPayload<T> | null >>

    /**
     * Find zero or more Costume_ability_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_ability_linkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Costume_ability_links
     * const costume_ability_links = await prisma.costume_ability_link.findMany()
     * 
     * // Get first 10 Costume_ability_links
     * const costume_ability_links = await prisma.costume_ability_link.findMany({ take: 10 })
     * 
     * // Only select the `costume_id`
     * const costume_ability_linkWithCostume_idOnly = await prisma.costume_ability_link.findMany({ select: { costume_id: true } })
     * 
    **/
    findMany<T extends costume_ability_linkFindManyArgs>(
      args?: SelectSubset<T, costume_ability_linkFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<costume_ability_link>>, PrismaPromise<Array<costume_ability_linkGetPayload<T>>>>

    /**
     * Create a Costume_ability_link.
     * @param {costume_ability_linkCreateArgs} args - Arguments to create a Costume_ability_link.
     * @example
     * // Create one Costume_ability_link
     * const Costume_ability_link = await prisma.costume_ability_link.create({
     *   data: {
     *     // ... data to create a Costume_ability_link
     *   }
     * })
     * 
    **/
    create<T extends costume_ability_linkCreateArgs>(
      args: SelectSubset<T, costume_ability_linkCreateArgs>
    ): CheckSelect<T, Prisma__costume_ability_linkClient<costume_ability_link>, Prisma__costume_ability_linkClient<costume_ability_linkGetPayload<T>>>

    /**
     * Create many Costume_ability_links.
     *     @param {costume_ability_linkCreateManyArgs} args - Arguments to create many Costume_ability_links.
     *     @example
     *     // Create many Costume_ability_links
     *     const costume_ability_link = await prisma.costume_ability_link.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends costume_ability_linkCreateManyArgs>(
      args?: SelectSubset<T, costume_ability_linkCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Costume_ability_link.
     * @param {costume_ability_linkDeleteArgs} args - Arguments to delete one Costume_ability_link.
     * @example
     * // Delete one Costume_ability_link
     * const Costume_ability_link = await prisma.costume_ability_link.delete({
     *   where: {
     *     // ... filter to delete one Costume_ability_link
     *   }
     * })
     * 
    **/
    delete<T extends costume_ability_linkDeleteArgs>(
      args: SelectSubset<T, costume_ability_linkDeleteArgs>
    ): CheckSelect<T, Prisma__costume_ability_linkClient<costume_ability_link>, Prisma__costume_ability_linkClient<costume_ability_linkGetPayload<T>>>

    /**
     * Update one Costume_ability_link.
     * @param {costume_ability_linkUpdateArgs} args - Arguments to update one Costume_ability_link.
     * @example
     * // Update one Costume_ability_link
     * const costume_ability_link = await prisma.costume_ability_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends costume_ability_linkUpdateArgs>(
      args: SelectSubset<T, costume_ability_linkUpdateArgs>
    ): CheckSelect<T, Prisma__costume_ability_linkClient<costume_ability_link>, Prisma__costume_ability_linkClient<costume_ability_linkGetPayload<T>>>

    /**
     * Delete zero or more Costume_ability_links.
     * @param {costume_ability_linkDeleteManyArgs} args - Arguments to filter Costume_ability_links to delete.
     * @example
     * // Delete a few Costume_ability_links
     * const { count } = await prisma.costume_ability_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends costume_ability_linkDeleteManyArgs>(
      args?: SelectSubset<T, costume_ability_linkDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Costume_ability_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_ability_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Costume_ability_links
     * const costume_ability_link = await prisma.costume_ability_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends costume_ability_linkUpdateManyArgs>(
      args: SelectSubset<T, costume_ability_linkUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Costume_ability_link.
     * @param {costume_ability_linkUpsertArgs} args - Arguments to update or create a Costume_ability_link.
     * @example
     * // Update or create a Costume_ability_link
     * const costume_ability_link = await prisma.costume_ability_link.upsert({
     *   create: {
     *     // ... data to create a Costume_ability_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Costume_ability_link we want to update
     *   }
     * })
    **/
    upsert<T extends costume_ability_linkUpsertArgs>(
      args: SelectSubset<T, costume_ability_linkUpsertArgs>
    ): CheckSelect<T, Prisma__costume_ability_linkClient<costume_ability_link>, Prisma__costume_ability_linkClient<costume_ability_linkGetPayload<T>>>

    /**
     * Count the number of Costume_ability_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_ability_linkCountArgs} args - Arguments to filter Costume_ability_links to count.
     * @example
     * // Count the number of Costume_ability_links
     * const count = await prisma.costume_ability_link.count({
     *   where: {
     *     // ... the filter for the Costume_ability_links we want to count
     *   }
     * })
    **/
    count<T extends costume_ability_linkCountArgs>(
      args?: Subset<T, costume_ability_linkCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Costume_ability_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Costume_ability_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Costume_ability_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Costume_ability_linkAggregateArgs>(args: Subset<T, Costume_ability_linkAggregateArgs>): PrismaPromise<GetCostume_ability_linkAggregateType<T>>

    /**
     * Group by Costume_ability_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Costume_ability_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Costume_ability_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Costume_ability_linkGroupByArgs['orderBy'] }
        : { orderBy?: Costume_ability_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Costume_ability_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostume_ability_linkGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for costume_ability_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__costume_ability_linkClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    costume_ability<T extends costume_abilityArgs = {}>(args?: Subset<T, costume_abilityArgs>): CheckSelect<T, Prisma__costume_abilityClient<costume_ability | null >, Prisma__costume_abilityClient<costume_abilityGetPayload<T> | null >>;

    costume<T extends costumeArgs = {}>(args?: Subset<T, costumeArgs>): CheckSelect<T, Prisma__costumeClient<costume | null >, Prisma__costumeClient<costumeGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * costume_ability_link findUnique
   */
  export type costume_ability_linkFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the costume_ability_link
     * 
    **/
    select?: costume_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_ability_linkInclude | null
    /**
     * Throw an Error if a costume_ability_link can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which costume_ability_link to fetch.
     * 
    **/
    where: costume_ability_linkWhereUniqueInput
  }


  /**
   * costume_ability_link findFirst
   */
  export type costume_ability_linkFindFirstArgs = {
    /**
     * Select specific fields to fetch from the costume_ability_link
     * 
    **/
    select?: costume_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_ability_linkInclude | null
    /**
     * Throw an Error if a costume_ability_link can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which costume_ability_link to fetch.
     * 
    **/
    where?: costume_ability_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costume_ability_links to fetch.
     * 
    **/
    orderBy?: Enumerable<costume_ability_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for costume_ability_links.
     * 
    **/
    cursor?: costume_ability_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costume_ability_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costume_ability_links.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of costume_ability_links.
     * 
    **/
    distinct?: Enumerable<Costume_ability_linkScalarFieldEnum>
  }


  /**
   * costume_ability_link findMany
   */
  export type costume_ability_linkFindManyArgs = {
    /**
     * Select specific fields to fetch from the costume_ability_link
     * 
    **/
    select?: costume_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_ability_linkInclude | null
    /**
     * Filter, which costume_ability_links to fetch.
     * 
    **/
    where?: costume_ability_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costume_ability_links to fetch.
     * 
    **/
    orderBy?: Enumerable<costume_ability_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing costume_ability_links.
     * 
    **/
    cursor?: costume_ability_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costume_ability_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costume_ability_links.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Costume_ability_linkScalarFieldEnum>
  }


  /**
   * costume_ability_link create
   */
  export type costume_ability_linkCreateArgs = {
    /**
     * Select specific fields to fetch from the costume_ability_link
     * 
    **/
    select?: costume_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_ability_linkInclude | null
    /**
     * The data needed to create a costume_ability_link.
     * 
    **/
    data: XOR<costume_ability_linkCreateInput, costume_ability_linkUncheckedCreateInput>
  }


  /**
   * costume_ability_link createMany
   */
  export type costume_ability_linkCreateManyArgs = {
    /**
     * The data used to create many costume_ability_links.
     * 
    **/
    data: Enumerable<costume_ability_linkCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * costume_ability_link update
   */
  export type costume_ability_linkUpdateArgs = {
    /**
     * Select specific fields to fetch from the costume_ability_link
     * 
    **/
    select?: costume_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_ability_linkInclude | null
    /**
     * The data needed to update a costume_ability_link.
     * 
    **/
    data: XOR<costume_ability_linkUpdateInput, costume_ability_linkUncheckedUpdateInput>
    /**
     * Choose, which costume_ability_link to update.
     * 
    **/
    where: costume_ability_linkWhereUniqueInput
  }


  /**
   * costume_ability_link updateMany
   */
  export type costume_ability_linkUpdateManyArgs = {
    /**
     * The data used to update costume_ability_links.
     * 
    **/
    data: XOR<costume_ability_linkUpdateManyMutationInput, costume_ability_linkUncheckedUpdateManyInput>
    /**
     * Filter which costume_ability_links to update
     * 
    **/
    where?: costume_ability_linkWhereInput
  }


  /**
   * costume_ability_link upsert
   */
  export type costume_ability_linkUpsertArgs = {
    /**
     * Select specific fields to fetch from the costume_ability_link
     * 
    **/
    select?: costume_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_ability_linkInclude | null
    /**
     * The filter to search for the costume_ability_link to update in case it exists.
     * 
    **/
    where: costume_ability_linkWhereUniqueInput
    /**
     * In case the costume_ability_link found by the `where` argument doesn't exist, create a new costume_ability_link with this data.
     * 
    **/
    create: XOR<costume_ability_linkCreateInput, costume_ability_linkUncheckedCreateInput>
    /**
     * In case the costume_ability_link was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<costume_ability_linkUpdateInput, costume_ability_linkUncheckedUpdateInput>
  }


  /**
   * costume_ability_link delete
   */
  export type costume_ability_linkDeleteArgs = {
    /**
     * Select specific fields to fetch from the costume_ability_link
     * 
    **/
    select?: costume_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_ability_linkInclude | null
    /**
     * Filter which costume_ability_link to delete.
     * 
    **/
    where: costume_ability_linkWhereUniqueInput
  }


  /**
   * costume_ability_link deleteMany
   */
  export type costume_ability_linkDeleteManyArgs = {
    /**
     * Filter which costume_ability_links to delete
     * 
    **/
    where?: costume_ability_linkWhereInput
  }


  /**
   * costume_ability_link without action
   */
  export type costume_ability_linkArgs = {
    /**
     * Select specific fields to fetch from the costume_ability_link
     * 
    **/
    select?: costume_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_ability_linkInclude | null
  }



  /**
   * Model costume_skill
   */


  export type AggregateCostume_skill = {
    _count: Costume_skillCountAggregateOutputType | null
    _avg: Costume_skillAvgAggregateOutputType | null
    _sum: Costume_skillSumAggregateOutputType | null
    _min: Costume_skillMinAggregateOutputType | null
    _max: Costume_skillMaxAggregateOutputType | null
  }

  export type Costume_skillAvgAggregateOutputType = {
    skill_id: number | null
    skill_level: number | null
    cooldown_time: number | null
  }

  export type Costume_skillSumAggregateOutputType = {
    skill_id: number | null
    skill_level: number | null
    cooldown_time: number | null
  }

  export type Costume_skillMinAggregateOutputType = {
    skill_id: number | null
    skill_level: number | null
    gauge_rise_speed: string | null
    cooldown_time: number | null
    name: string | null
    description: string | null
    short_description: string | null
    image_path: string | null
  }

  export type Costume_skillMaxAggregateOutputType = {
    skill_id: number | null
    skill_level: number | null
    gauge_rise_speed: string | null
    cooldown_time: number | null
    name: string | null
    description: string | null
    short_description: string | null
    image_path: string | null
  }

  export type Costume_skillCountAggregateOutputType = {
    skill_id: number
    skill_level: number
    gauge_rise_speed: number
    cooldown_time: number
    name: number
    description: number
    short_description: number
    image_path: number
    _all: number
  }


  export type Costume_skillAvgAggregateInputType = {
    skill_id?: true
    skill_level?: true
    cooldown_time?: true
  }

  export type Costume_skillSumAggregateInputType = {
    skill_id?: true
    skill_level?: true
    cooldown_time?: true
  }

  export type Costume_skillMinAggregateInputType = {
    skill_id?: true
    skill_level?: true
    gauge_rise_speed?: true
    cooldown_time?: true
    name?: true
    description?: true
    short_description?: true
    image_path?: true
  }

  export type Costume_skillMaxAggregateInputType = {
    skill_id?: true
    skill_level?: true
    gauge_rise_speed?: true
    cooldown_time?: true
    name?: true
    description?: true
    short_description?: true
    image_path?: true
  }

  export type Costume_skillCountAggregateInputType = {
    skill_id?: true
    skill_level?: true
    gauge_rise_speed?: true
    cooldown_time?: true
    name?: true
    description?: true
    short_description?: true
    image_path?: true
    _all?: true
  }

  export type Costume_skillAggregateArgs = {
    /**
     * Filter which costume_skill to aggregate.
     * 
    **/
    where?: costume_skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costume_skills to fetch.
     * 
    **/
    orderBy?: Enumerable<costume_skillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: costume_skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costume_skills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costume_skills.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned costume_skills
    **/
    _count?: true | Costume_skillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Costume_skillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Costume_skillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Costume_skillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Costume_skillMaxAggregateInputType
  }

  export type GetCostume_skillAggregateType<T extends Costume_skillAggregateArgs> = {
        [P in keyof T & keyof AggregateCostume_skill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostume_skill[P]>
      : GetScalarType<T[P], AggregateCostume_skill[P]>
  }




  export type Costume_skillGroupByArgs = {
    where?: costume_skillWhereInput
    orderBy?: Enumerable<costume_skillOrderByWithAggregationInput>
    by: Array<Costume_skillScalarFieldEnum>
    having?: costume_skillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Costume_skillCountAggregateInputType | true
    _avg?: Costume_skillAvgAggregateInputType
    _sum?: Costume_skillSumAggregateInputType
    _min?: Costume_skillMinAggregateInputType
    _max?: Costume_skillMaxAggregateInputType
  }


  export type Costume_skillGroupByOutputType = {
    skill_id: number
    skill_level: number
    gauge_rise_speed: string | null
    cooldown_time: number
    name: string | null
    description: string | null
    short_description: string | null
    image_path: string | null
    _count: Costume_skillCountAggregateOutputType | null
    _avg: Costume_skillAvgAggregateOutputType | null
    _sum: Costume_skillSumAggregateOutputType | null
    _min: Costume_skillMinAggregateOutputType | null
    _max: Costume_skillMaxAggregateOutputType | null
  }

  type GetCostume_skillGroupByPayload<T extends Costume_skillGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Costume_skillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Costume_skillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Costume_skillGroupByOutputType[P]>
            : GetScalarType<T[P], Costume_skillGroupByOutputType[P]>
        }
      >
    >


  export type costume_skillSelect = {
    skill_id?: boolean
    skill_level?: boolean
    gauge_rise_speed?: boolean
    cooldown_time?: boolean
    name?: boolean
    description?: boolean
    short_description?: boolean
    image_path?: boolean
    costume_skill_link?: boolean | costume_skill_linkFindManyArgs
    _count?: boolean | Costume_skillCountOutputTypeArgs
  }

  export type costume_skillInclude = {
    costume_skill_link?: boolean | costume_skill_linkFindManyArgs
    _count?: boolean | Costume_skillCountOutputTypeArgs
  }

  export type costume_skillGetPayload<
    S extends boolean | null | undefined | costume_skillArgs,
    U = keyof S
      > = S extends true
        ? costume_skill
    : S extends undefined
    ? never
    : S extends costume_skillArgs | costume_skillFindManyArgs
    ?'include' extends U
    ? costume_skill  & {
    [P in TrueKeys<S['include']>]:
        P extends 'costume_skill_link' ? Array < costume_skill_linkGetPayload<S['include'][P]>>  :
        P extends '_count' ? Costume_skillCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'costume_skill_link' ? Array < costume_skill_linkGetPayload<S['select'][P]>>  :
        P extends '_count' ? Costume_skillCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof costume_skill ? costume_skill[P] : never
  } 
    : costume_skill
  : costume_skill


  type costume_skillCountArgs = Merge<
    Omit<costume_skillFindManyArgs, 'select' | 'include'> & {
      select?: Costume_skillCountAggregateInputType | true
    }
  >

  export interface costume_skillDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Costume_skill that matches the filter.
     * @param {costume_skillFindUniqueArgs} args - Arguments to find a Costume_skill
     * @example
     * // Get one Costume_skill
     * const costume_skill = await prisma.costume_skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends costume_skillFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, costume_skillFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'costume_skill'> extends True ? CheckSelect<T, Prisma__costume_skillClient<costume_skill>, Prisma__costume_skillClient<costume_skillGetPayload<T>>> : CheckSelect<T, Prisma__costume_skillClient<costume_skill | null >, Prisma__costume_skillClient<costume_skillGetPayload<T> | null >>

    /**
     * Find the first Costume_skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_skillFindFirstArgs} args - Arguments to find a Costume_skill
     * @example
     * // Get one Costume_skill
     * const costume_skill = await prisma.costume_skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends costume_skillFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, costume_skillFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'costume_skill'> extends True ? CheckSelect<T, Prisma__costume_skillClient<costume_skill>, Prisma__costume_skillClient<costume_skillGetPayload<T>>> : CheckSelect<T, Prisma__costume_skillClient<costume_skill | null >, Prisma__costume_skillClient<costume_skillGetPayload<T> | null >>

    /**
     * Find zero or more Costume_skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_skillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Costume_skills
     * const costume_skills = await prisma.costume_skill.findMany()
     * 
     * // Get first 10 Costume_skills
     * const costume_skills = await prisma.costume_skill.findMany({ take: 10 })
     * 
     * // Only select the `skill_id`
     * const costume_skillWithSkill_idOnly = await prisma.costume_skill.findMany({ select: { skill_id: true } })
     * 
    **/
    findMany<T extends costume_skillFindManyArgs>(
      args?: SelectSubset<T, costume_skillFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<costume_skill>>, PrismaPromise<Array<costume_skillGetPayload<T>>>>

    /**
     * Create a Costume_skill.
     * @param {costume_skillCreateArgs} args - Arguments to create a Costume_skill.
     * @example
     * // Create one Costume_skill
     * const Costume_skill = await prisma.costume_skill.create({
     *   data: {
     *     // ... data to create a Costume_skill
     *   }
     * })
     * 
    **/
    create<T extends costume_skillCreateArgs>(
      args: SelectSubset<T, costume_skillCreateArgs>
    ): CheckSelect<T, Prisma__costume_skillClient<costume_skill>, Prisma__costume_skillClient<costume_skillGetPayload<T>>>

    /**
     * Create many Costume_skills.
     *     @param {costume_skillCreateManyArgs} args - Arguments to create many Costume_skills.
     *     @example
     *     // Create many Costume_skills
     *     const costume_skill = await prisma.costume_skill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends costume_skillCreateManyArgs>(
      args?: SelectSubset<T, costume_skillCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Costume_skill.
     * @param {costume_skillDeleteArgs} args - Arguments to delete one Costume_skill.
     * @example
     * // Delete one Costume_skill
     * const Costume_skill = await prisma.costume_skill.delete({
     *   where: {
     *     // ... filter to delete one Costume_skill
     *   }
     * })
     * 
    **/
    delete<T extends costume_skillDeleteArgs>(
      args: SelectSubset<T, costume_skillDeleteArgs>
    ): CheckSelect<T, Prisma__costume_skillClient<costume_skill>, Prisma__costume_skillClient<costume_skillGetPayload<T>>>

    /**
     * Update one Costume_skill.
     * @param {costume_skillUpdateArgs} args - Arguments to update one Costume_skill.
     * @example
     * // Update one Costume_skill
     * const costume_skill = await prisma.costume_skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends costume_skillUpdateArgs>(
      args: SelectSubset<T, costume_skillUpdateArgs>
    ): CheckSelect<T, Prisma__costume_skillClient<costume_skill>, Prisma__costume_skillClient<costume_skillGetPayload<T>>>

    /**
     * Delete zero or more Costume_skills.
     * @param {costume_skillDeleteManyArgs} args - Arguments to filter Costume_skills to delete.
     * @example
     * // Delete a few Costume_skills
     * const { count } = await prisma.costume_skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends costume_skillDeleteManyArgs>(
      args?: SelectSubset<T, costume_skillDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Costume_skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_skillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Costume_skills
     * const costume_skill = await prisma.costume_skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends costume_skillUpdateManyArgs>(
      args: SelectSubset<T, costume_skillUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Costume_skill.
     * @param {costume_skillUpsertArgs} args - Arguments to update or create a Costume_skill.
     * @example
     * // Update or create a Costume_skill
     * const costume_skill = await prisma.costume_skill.upsert({
     *   create: {
     *     // ... data to create a Costume_skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Costume_skill we want to update
     *   }
     * })
    **/
    upsert<T extends costume_skillUpsertArgs>(
      args: SelectSubset<T, costume_skillUpsertArgs>
    ): CheckSelect<T, Prisma__costume_skillClient<costume_skill>, Prisma__costume_skillClient<costume_skillGetPayload<T>>>

    /**
     * Count the number of Costume_skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_skillCountArgs} args - Arguments to filter Costume_skills to count.
     * @example
     * // Count the number of Costume_skills
     * const count = await prisma.costume_skill.count({
     *   where: {
     *     // ... the filter for the Costume_skills we want to count
     *   }
     * })
    **/
    count<T extends costume_skillCountArgs>(
      args?: Subset<T, costume_skillCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Costume_skillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Costume_skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Costume_skillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Costume_skillAggregateArgs>(args: Subset<T, Costume_skillAggregateArgs>): PrismaPromise<GetCostume_skillAggregateType<T>>

    /**
     * Group by Costume_skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Costume_skillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Costume_skillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Costume_skillGroupByArgs['orderBy'] }
        : { orderBy?: Costume_skillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Costume_skillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostume_skillGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for costume_skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__costume_skillClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    costume_skill_link<T extends costume_skill_linkFindManyArgs = {}>(args?: Subset<T, costume_skill_linkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<costume_skill_link>>, PrismaPromise<Array<costume_skill_linkGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * costume_skill findUnique
   */
  export type costume_skillFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the costume_skill
     * 
    **/
    select?: costume_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_skillInclude | null
    /**
     * Throw an Error if a costume_skill can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which costume_skill to fetch.
     * 
    **/
    where: costume_skillWhereUniqueInput
  }


  /**
   * costume_skill findFirst
   */
  export type costume_skillFindFirstArgs = {
    /**
     * Select specific fields to fetch from the costume_skill
     * 
    **/
    select?: costume_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_skillInclude | null
    /**
     * Throw an Error if a costume_skill can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which costume_skill to fetch.
     * 
    **/
    where?: costume_skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costume_skills to fetch.
     * 
    **/
    orderBy?: Enumerable<costume_skillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for costume_skills.
     * 
    **/
    cursor?: costume_skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costume_skills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costume_skills.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of costume_skills.
     * 
    **/
    distinct?: Enumerable<Costume_skillScalarFieldEnum>
  }


  /**
   * costume_skill findMany
   */
  export type costume_skillFindManyArgs = {
    /**
     * Select specific fields to fetch from the costume_skill
     * 
    **/
    select?: costume_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_skillInclude | null
    /**
     * Filter, which costume_skills to fetch.
     * 
    **/
    where?: costume_skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costume_skills to fetch.
     * 
    **/
    orderBy?: Enumerable<costume_skillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing costume_skills.
     * 
    **/
    cursor?: costume_skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costume_skills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costume_skills.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Costume_skillScalarFieldEnum>
  }


  /**
   * costume_skill create
   */
  export type costume_skillCreateArgs = {
    /**
     * Select specific fields to fetch from the costume_skill
     * 
    **/
    select?: costume_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_skillInclude | null
    /**
     * The data needed to create a costume_skill.
     * 
    **/
    data: XOR<costume_skillCreateInput, costume_skillUncheckedCreateInput>
  }


  /**
   * costume_skill createMany
   */
  export type costume_skillCreateManyArgs = {
    /**
     * The data used to create many costume_skills.
     * 
    **/
    data: Enumerable<costume_skillCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * costume_skill update
   */
  export type costume_skillUpdateArgs = {
    /**
     * Select specific fields to fetch from the costume_skill
     * 
    **/
    select?: costume_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_skillInclude | null
    /**
     * The data needed to update a costume_skill.
     * 
    **/
    data: XOR<costume_skillUpdateInput, costume_skillUncheckedUpdateInput>
    /**
     * Choose, which costume_skill to update.
     * 
    **/
    where: costume_skillWhereUniqueInput
  }


  /**
   * costume_skill updateMany
   */
  export type costume_skillUpdateManyArgs = {
    /**
     * The data used to update costume_skills.
     * 
    **/
    data: XOR<costume_skillUpdateManyMutationInput, costume_skillUncheckedUpdateManyInput>
    /**
     * Filter which costume_skills to update
     * 
    **/
    where?: costume_skillWhereInput
  }


  /**
   * costume_skill upsert
   */
  export type costume_skillUpsertArgs = {
    /**
     * Select specific fields to fetch from the costume_skill
     * 
    **/
    select?: costume_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_skillInclude | null
    /**
     * The filter to search for the costume_skill to update in case it exists.
     * 
    **/
    where: costume_skillWhereUniqueInput
    /**
     * In case the costume_skill found by the `where` argument doesn't exist, create a new costume_skill with this data.
     * 
    **/
    create: XOR<costume_skillCreateInput, costume_skillUncheckedCreateInput>
    /**
     * In case the costume_skill was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<costume_skillUpdateInput, costume_skillUncheckedUpdateInput>
  }


  /**
   * costume_skill delete
   */
  export type costume_skillDeleteArgs = {
    /**
     * Select specific fields to fetch from the costume_skill
     * 
    **/
    select?: costume_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_skillInclude | null
    /**
     * Filter which costume_skill to delete.
     * 
    **/
    where: costume_skillWhereUniqueInput
  }


  /**
   * costume_skill deleteMany
   */
  export type costume_skillDeleteManyArgs = {
    /**
     * Filter which costume_skills to delete
     * 
    **/
    where?: costume_skillWhereInput
  }


  /**
   * costume_skill without action
   */
  export type costume_skillArgs = {
    /**
     * Select specific fields to fetch from the costume_skill
     * 
    **/
    select?: costume_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_skillInclude | null
  }



  /**
   * Model costume_skill_link
   */


  export type AggregateCostume_skill_link = {
    _count: Costume_skill_linkCountAggregateOutputType | null
    _avg: Costume_skill_linkAvgAggregateOutputType | null
    _sum: Costume_skill_linkSumAggregateOutputType | null
    _min: Costume_skill_linkMinAggregateOutputType | null
    _max: Costume_skill_linkMaxAggregateOutputType | null
  }

  export type Costume_skill_linkAvgAggregateOutputType = {
    costume_id: number | null
    skill_id: number | null
    skill_level: number | null
  }

  export type Costume_skill_linkSumAggregateOutputType = {
    costume_id: number | null
    skill_id: number | null
    skill_level: number | null
  }

  export type Costume_skill_linkMinAggregateOutputType = {
    costume_id: number | null
    skill_id: number | null
    skill_level: number | null
  }

  export type Costume_skill_linkMaxAggregateOutputType = {
    costume_id: number | null
    skill_id: number | null
    skill_level: number | null
  }

  export type Costume_skill_linkCountAggregateOutputType = {
    costume_id: number
    skill_id: number
    skill_level: number
    _all: number
  }


  export type Costume_skill_linkAvgAggregateInputType = {
    costume_id?: true
    skill_id?: true
    skill_level?: true
  }

  export type Costume_skill_linkSumAggregateInputType = {
    costume_id?: true
    skill_id?: true
    skill_level?: true
  }

  export type Costume_skill_linkMinAggregateInputType = {
    costume_id?: true
    skill_id?: true
    skill_level?: true
  }

  export type Costume_skill_linkMaxAggregateInputType = {
    costume_id?: true
    skill_id?: true
    skill_level?: true
  }

  export type Costume_skill_linkCountAggregateInputType = {
    costume_id?: true
    skill_id?: true
    skill_level?: true
    _all?: true
  }

  export type Costume_skill_linkAggregateArgs = {
    /**
     * Filter which costume_skill_link to aggregate.
     * 
    **/
    where?: costume_skill_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costume_skill_links to fetch.
     * 
    **/
    orderBy?: Enumerable<costume_skill_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: costume_skill_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costume_skill_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costume_skill_links.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned costume_skill_links
    **/
    _count?: true | Costume_skill_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Costume_skill_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Costume_skill_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Costume_skill_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Costume_skill_linkMaxAggregateInputType
  }

  export type GetCostume_skill_linkAggregateType<T extends Costume_skill_linkAggregateArgs> = {
        [P in keyof T & keyof AggregateCostume_skill_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostume_skill_link[P]>
      : GetScalarType<T[P], AggregateCostume_skill_link[P]>
  }




  export type Costume_skill_linkGroupByArgs = {
    where?: costume_skill_linkWhereInput
    orderBy?: Enumerable<costume_skill_linkOrderByWithAggregationInput>
    by: Array<Costume_skill_linkScalarFieldEnum>
    having?: costume_skill_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Costume_skill_linkCountAggregateInputType | true
    _avg?: Costume_skill_linkAvgAggregateInputType
    _sum?: Costume_skill_linkSumAggregateInputType
    _min?: Costume_skill_linkMinAggregateInputType
    _max?: Costume_skill_linkMaxAggregateInputType
  }


  export type Costume_skill_linkGroupByOutputType = {
    costume_id: number
    skill_id: number
    skill_level: number
    _count: Costume_skill_linkCountAggregateOutputType | null
    _avg: Costume_skill_linkAvgAggregateOutputType | null
    _sum: Costume_skill_linkSumAggregateOutputType | null
    _min: Costume_skill_linkMinAggregateOutputType | null
    _max: Costume_skill_linkMaxAggregateOutputType | null
  }

  type GetCostume_skill_linkGroupByPayload<T extends Costume_skill_linkGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Costume_skill_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Costume_skill_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Costume_skill_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Costume_skill_linkGroupByOutputType[P]>
        }
      >
    >


  export type costume_skill_linkSelect = {
    costume_id?: boolean
    skill_id?: boolean
    skill_level?: boolean
    costume?: boolean | costumeArgs
    costume_skill?: boolean | costume_skillArgs
  }

  export type costume_skill_linkInclude = {
    costume?: boolean | costumeArgs
    costume_skill?: boolean | costume_skillArgs
  }

  export type costume_skill_linkGetPayload<
    S extends boolean | null | undefined | costume_skill_linkArgs,
    U = keyof S
      > = S extends true
        ? costume_skill_link
    : S extends undefined
    ? never
    : S extends costume_skill_linkArgs | costume_skill_linkFindManyArgs
    ?'include' extends U
    ? costume_skill_link  & {
    [P in TrueKeys<S['include']>]:
        P extends 'costume' ? costumeGetPayload<S['include'][P]> :
        P extends 'costume_skill' ? costume_skillGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'costume' ? costumeGetPayload<S['select'][P]> :
        P extends 'costume_skill' ? costume_skillGetPayload<S['select'][P]> :  P extends keyof costume_skill_link ? costume_skill_link[P] : never
  } 
    : costume_skill_link
  : costume_skill_link


  type costume_skill_linkCountArgs = Merge<
    Omit<costume_skill_linkFindManyArgs, 'select' | 'include'> & {
      select?: Costume_skill_linkCountAggregateInputType | true
    }
  >

  export interface costume_skill_linkDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Costume_skill_link that matches the filter.
     * @param {costume_skill_linkFindUniqueArgs} args - Arguments to find a Costume_skill_link
     * @example
     * // Get one Costume_skill_link
     * const costume_skill_link = await prisma.costume_skill_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends costume_skill_linkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, costume_skill_linkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'costume_skill_link'> extends True ? CheckSelect<T, Prisma__costume_skill_linkClient<costume_skill_link>, Prisma__costume_skill_linkClient<costume_skill_linkGetPayload<T>>> : CheckSelect<T, Prisma__costume_skill_linkClient<costume_skill_link | null >, Prisma__costume_skill_linkClient<costume_skill_linkGetPayload<T> | null >>

    /**
     * Find the first Costume_skill_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_skill_linkFindFirstArgs} args - Arguments to find a Costume_skill_link
     * @example
     * // Get one Costume_skill_link
     * const costume_skill_link = await prisma.costume_skill_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends costume_skill_linkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, costume_skill_linkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'costume_skill_link'> extends True ? CheckSelect<T, Prisma__costume_skill_linkClient<costume_skill_link>, Prisma__costume_skill_linkClient<costume_skill_linkGetPayload<T>>> : CheckSelect<T, Prisma__costume_skill_linkClient<costume_skill_link | null >, Prisma__costume_skill_linkClient<costume_skill_linkGetPayload<T> | null >>

    /**
     * Find zero or more Costume_skill_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_skill_linkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Costume_skill_links
     * const costume_skill_links = await prisma.costume_skill_link.findMany()
     * 
     * // Get first 10 Costume_skill_links
     * const costume_skill_links = await prisma.costume_skill_link.findMany({ take: 10 })
     * 
     * // Only select the `costume_id`
     * const costume_skill_linkWithCostume_idOnly = await prisma.costume_skill_link.findMany({ select: { costume_id: true } })
     * 
    **/
    findMany<T extends costume_skill_linkFindManyArgs>(
      args?: SelectSubset<T, costume_skill_linkFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<costume_skill_link>>, PrismaPromise<Array<costume_skill_linkGetPayload<T>>>>

    /**
     * Create a Costume_skill_link.
     * @param {costume_skill_linkCreateArgs} args - Arguments to create a Costume_skill_link.
     * @example
     * // Create one Costume_skill_link
     * const Costume_skill_link = await prisma.costume_skill_link.create({
     *   data: {
     *     // ... data to create a Costume_skill_link
     *   }
     * })
     * 
    **/
    create<T extends costume_skill_linkCreateArgs>(
      args: SelectSubset<T, costume_skill_linkCreateArgs>
    ): CheckSelect<T, Prisma__costume_skill_linkClient<costume_skill_link>, Prisma__costume_skill_linkClient<costume_skill_linkGetPayload<T>>>

    /**
     * Create many Costume_skill_links.
     *     @param {costume_skill_linkCreateManyArgs} args - Arguments to create many Costume_skill_links.
     *     @example
     *     // Create many Costume_skill_links
     *     const costume_skill_link = await prisma.costume_skill_link.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends costume_skill_linkCreateManyArgs>(
      args?: SelectSubset<T, costume_skill_linkCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Costume_skill_link.
     * @param {costume_skill_linkDeleteArgs} args - Arguments to delete one Costume_skill_link.
     * @example
     * // Delete one Costume_skill_link
     * const Costume_skill_link = await prisma.costume_skill_link.delete({
     *   where: {
     *     // ... filter to delete one Costume_skill_link
     *   }
     * })
     * 
    **/
    delete<T extends costume_skill_linkDeleteArgs>(
      args: SelectSubset<T, costume_skill_linkDeleteArgs>
    ): CheckSelect<T, Prisma__costume_skill_linkClient<costume_skill_link>, Prisma__costume_skill_linkClient<costume_skill_linkGetPayload<T>>>

    /**
     * Update one Costume_skill_link.
     * @param {costume_skill_linkUpdateArgs} args - Arguments to update one Costume_skill_link.
     * @example
     * // Update one Costume_skill_link
     * const costume_skill_link = await prisma.costume_skill_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends costume_skill_linkUpdateArgs>(
      args: SelectSubset<T, costume_skill_linkUpdateArgs>
    ): CheckSelect<T, Prisma__costume_skill_linkClient<costume_skill_link>, Prisma__costume_skill_linkClient<costume_skill_linkGetPayload<T>>>

    /**
     * Delete zero or more Costume_skill_links.
     * @param {costume_skill_linkDeleteManyArgs} args - Arguments to filter Costume_skill_links to delete.
     * @example
     * // Delete a few Costume_skill_links
     * const { count } = await prisma.costume_skill_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends costume_skill_linkDeleteManyArgs>(
      args?: SelectSubset<T, costume_skill_linkDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Costume_skill_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_skill_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Costume_skill_links
     * const costume_skill_link = await prisma.costume_skill_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends costume_skill_linkUpdateManyArgs>(
      args: SelectSubset<T, costume_skill_linkUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Costume_skill_link.
     * @param {costume_skill_linkUpsertArgs} args - Arguments to update or create a Costume_skill_link.
     * @example
     * // Update or create a Costume_skill_link
     * const costume_skill_link = await prisma.costume_skill_link.upsert({
     *   create: {
     *     // ... data to create a Costume_skill_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Costume_skill_link we want to update
     *   }
     * })
    **/
    upsert<T extends costume_skill_linkUpsertArgs>(
      args: SelectSubset<T, costume_skill_linkUpsertArgs>
    ): CheckSelect<T, Prisma__costume_skill_linkClient<costume_skill_link>, Prisma__costume_skill_linkClient<costume_skill_linkGetPayload<T>>>

    /**
     * Count the number of Costume_skill_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_skill_linkCountArgs} args - Arguments to filter Costume_skill_links to count.
     * @example
     * // Count the number of Costume_skill_links
     * const count = await prisma.costume_skill_link.count({
     *   where: {
     *     // ... the filter for the Costume_skill_links we want to count
     *   }
     * })
    **/
    count<T extends costume_skill_linkCountArgs>(
      args?: Subset<T, costume_skill_linkCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Costume_skill_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Costume_skill_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Costume_skill_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Costume_skill_linkAggregateArgs>(args: Subset<T, Costume_skill_linkAggregateArgs>): PrismaPromise<GetCostume_skill_linkAggregateType<T>>

    /**
     * Group by Costume_skill_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Costume_skill_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Costume_skill_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Costume_skill_linkGroupByArgs['orderBy'] }
        : { orderBy?: Costume_skill_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Costume_skill_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostume_skill_linkGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for costume_skill_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__costume_skill_linkClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    costume<T extends costumeArgs = {}>(args?: Subset<T, costumeArgs>): CheckSelect<T, Prisma__costumeClient<costume | null >, Prisma__costumeClient<costumeGetPayload<T> | null >>;

    costume_skill<T extends costume_skillArgs = {}>(args?: Subset<T, costume_skillArgs>): CheckSelect<T, Prisma__costume_skillClient<costume_skill | null >, Prisma__costume_skillClient<costume_skillGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * costume_skill_link findUnique
   */
  export type costume_skill_linkFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the costume_skill_link
     * 
    **/
    select?: costume_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_skill_linkInclude | null
    /**
     * Throw an Error if a costume_skill_link can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which costume_skill_link to fetch.
     * 
    **/
    where: costume_skill_linkWhereUniqueInput
  }


  /**
   * costume_skill_link findFirst
   */
  export type costume_skill_linkFindFirstArgs = {
    /**
     * Select specific fields to fetch from the costume_skill_link
     * 
    **/
    select?: costume_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_skill_linkInclude | null
    /**
     * Throw an Error if a costume_skill_link can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which costume_skill_link to fetch.
     * 
    **/
    where?: costume_skill_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costume_skill_links to fetch.
     * 
    **/
    orderBy?: Enumerable<costume_skill_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for costume_skill_links.
     * 
    **/
    cursor?: costume_skill_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costume_skill_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costume_skill_links.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of costume_skill_links.
     * 
    **/
    distinct?: Enumerable<Costume_skill_linkScalarFieldEnum>
  }


  /**
   * costume_skill_link findMany
   */
  export type costume_skill_linkFindManyArgs = {
    /**
     * Select specific fields to fetch from the costume_skill_link
     * 
    **/
    select?: costume_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_skill_linkInclude | null
    /**
     * Filter, which costume_skill_links to fetch.
     * 
    **/
    where?: costume_skill_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costume_skill_links to fetch.
     * 
    **/
    orderBy?: Enumerable<costume_skill_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing costume_skill_links.
     * 
    **/
    cursor?: costume_skill_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costume_skill_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costume_skill_links.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Costume_skill_linkScalarFieldEnum>
  }


  /**
   * costume_skill_link create
   */
  export type costume_skill_linkCreateArgs = {
    /**
     * Select specific fields to fetch from the costume_skill_link
     * 
    **/
    select?: costume_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_skill_linkInclude | null
    /**
     * The data needed to create a costume_skill_link.
     * 
    **/
    data: XOR<costume_skill_linkCreateInput, costume_skill_linkUncheckedCreateInput>
  }


  /**
   * costume_skill_link createMany
   */
  export type costume_skill_linkCreateManyArgs = {
    /**
     * The data used to create many costume_skill_links.
     * 
    **/
    data: Enumerable<costume_skill_linkCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * costume_skill_link update
   */
  export type costume_skill_linkUpdateArgs = {
    /**
     * Select specific fields to fetch from the costume_skill_link
     * 
    **/
    select?: costume_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_skill_linkInclude | null
    /**
     * The data needed to update a costume_skill_link.
     * 
    **/
    data: XOR<costume_skill_linkUpdateInput, costume_skill_linkUncheckedUpdateInput>
    /**
     * Choose, which costume_skill_link to update.
     * 
    **/
    where: costume_skill_linkWhereUniqueInput
  }


  /**
   * costume_skill_link updateMany
   */
  export type costume_skill_linkUpdateManyArgs = {
    /**
     * The data used to update costume_skill_links.
     * 
    **/
    data: XOR<costume_skill_linkUpdateManyMutationInput, costume_skill_linkUncheckedUpdateManyInput>
    /**
     * Filter which costume_skill_links to update
     * 
    **/
    where?: costume_skill_linkWhereInput
  }


  /**
   * costume_skill_link upsert
   */
  export type costume_skill_linkUpsertArgs = {
    /**
     * Select specific fields to fetch from the costume_skill_link
     * 
    **/
    select?: costume_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_skill_linkInclude | null
    /**
     * The filter to search for the costume_skill_link to update in case it exists.
     * 
    **/
    where: costume_skill_linkWhereUniqueInput
    /**
     * In case the costume_skill_link found by the `where` argument doesn't exist, create a new costume_skill_link with this data.
     * 
    **/
    create: XOR<costume_skill_linkCreateInput, costume_skill_linkUncheckedCreateInput>
    /**
     * In case the costume_skill_link was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<costume_skill_linkUpdateInput, costume_skill_linkUncheckedUpdateInput>
  }


  /**
   * costume_skill_link delete
   */
  export type costume_skill_linkDeleteArgs = {
    /**
     * Select specific fields to fetch from the costume_skill_link
     * 
    **/
    select?: costume_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_skill_linkInclude | null
    /**
     * Filter which costume_skill_link to delete.
     * 
    **/
    where: costume_skill_linkWhereUniqueInput
  }


  /**
   * costume_skill_link deleteMany
   */
  export type costume_skill_linkDeleteManyArgs = {
    /**
     * Filter which costume_skill_links to delete
     * 
    **/
    where?: costume_skill_linkWhereInput
  }


  /**
   * costume_skill_link without action
   */
  export type costume_skill_linkArgs = {
    /**
     * Select specific fields to fetch from the costume_skill_link
     * 
    **/
    select?: costume_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_skill_linkInclude | null
  }



  /**
   * Model costume_stat
   */


  export type AggregateCostume_stat = {
    _count: Costume_statCountAggregateOutputType | null
    _avg: Costume_statAvgAggregateOutputType | null
    _sum: Costume_statSumAggregateOutputType | null
    _min: Costume_statMinAggregateOutputType | null
    _max: Costume_statMaxAggregateOutputType | null
  }

  export type Costume_statAvgAggregateOutputType = {
    costume_id: number | null
    level: number | null
    agi: number | null
    atk: number | null
    crit_atk: number | null
    crit_rate: number | null
    eva_rate: number | null
    hp: number | null
    vit: number | null
  }

  export type Costume_statSumAggregateOutputType = {
    costume_id: number | null
    level: number | null
    agi: number | null
    atk: number | null
    crit_atk: number | null
    crit_rate: number | null
    eva_rate: number | null
    hp: number | null
    vit: number | null
  }

  export type Costume_statMinAggregateOutputType = {
    costume_id: number | null
    level: number | null
    agi: number | null
    atk: number | null
    crit_atk: number | null
    crit_rate: number | null
    eva_rate: number | null
    hp: number | null
    vit: number | null
  }

  export type Costume_statMaxAggregateOutputType = {
    costume_id: number | null
    level: number | null
    agi: number | null
    atk: number | null
    crit_atk: number | null
    crit_rate: number | null
    eva_rate: number | null
    hp: number | null
    vit: number | null
  }

  export type Costume_statCountAggregateOutputType = {
    costume_id: number
    level: number
    agi: number
    atk: number
    crit_atk: number
    crit_rate: number
    eva_rate: number
    hp: number
    vit: number
    _all: number
  }


  export type Costume_statAvgAggregateInputType = {
    costume_id?: true
    level?: true
    agi?: true
    atk?: true
    crit_atk?: true
    crit_rate?: true
    eva_rate?: true
    hp?: true
    vit?: true
  }

  export type Costume_statSumAggregateInputType = {
    costume_id?: true
    level?: true
    agi?: true
    atk?: true
    crit_atk?: true
    crit_rate?: true
    eva_rate?: true
    hp?: true
    vit?: true
  }

  export type Costume_statMinAggregateInputType = {
    costume_id?: true
    level?: true
    agi?: true
    atk?: true
    crit_atk?: true
    crit_rate?: true
    eva_rate?: true
    hp?: true
    vit?: true
  }

  export type Costume_statMaxAggregateInputType = {
    costume_id?: true
    level?: true
    agi?: true
    atk?: true
    crit_atk?: true
    crit_rate?: true
    eva_rate?: true
    hp?: true
    vit?: true
  }

  export type Costume_statCountAggregateInputType = {
    costume_id?: true
    level?: true
    agi?: true
    atk?: true
    crit_atk?: true
    crit_rate?: true
    eva_rate?: true
    hp?: true
    vit?: true
    _all?: true
  }

  export type Costume_statAggregateArgs = {
    /**
     * Filter which costume_stat to aggregate.
     * 
    **/
    where?: costume_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costume_stats to fetch.
     * 
    **/
    orderBy?: Enumerable<costume_statOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: costume_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costume_stats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costume_stats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned costume_stats
    **/
    _count?: true | Costume_statCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Costume_statAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Costume_statSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Costume_statMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Costume_statMaxAggregateInputType
  }

  export type GetCostume_statAggregateType<T extends Costume_statAggregateArgs> = {
        [P in keyof T & keyof AggregateCostume_stat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostume_stat[P]>
      : GetScalarType<T[P], AggregateCostume_stat[P]>
  }




  export type Costume_statGroupByArgs = {
    where?: costume_statWhereInput
    orderBy?: Enumerable<costume_statOrderByWithAggregationInput>
    by: Array<Costume_statScalarFieldEnum>
    having?: costume_statScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Costume_statCountAggregateInputType | true
    _avg?: Costume_statAvgAggregateInputType
    _sum?: Costume_statSumAggregateInputType
    _min?: Costume_statMinAggregateInputType
    _max?: Costume_statMaxAggregateInputType
  }


  export type Costume_statGroupByOutputType = {
    costume_id: number
    level: number
    agi: number
    atk: number
    crit_atk: number
    crit_rate: number
    eva_rate: number
    hp: number
    vit: number
    _count: Costume_statCountAggregateOutputType | null
    _avg: Costume_statAvgAggregateOutputType | null
    _sum: Costume_statSumAggregateOutputType | null
    _min: Costume_statMinAggregateOutputType | null
    _max: Costume_statMaxAggregateOutputType | null
  }

  type GetCostume_statGroupByPayload<T extends Costume_statGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Costume_statGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Costume_statGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Costume_statGroupByOutputType[P]>
            : GetScalarType<T[P], Costume_statGroupByOutputType[P]>
        }
      >
    >


  export type costume_statSelect = {
    costume_id?: boolean
    level?: boolean
    agi?: boolean
    atk?: boolean
    crit_atk?: boolean
    crit_rate?: boolean
    eva_rate?: boolean
    hp?: boolean
    vit?: boolean
    costume?: boolean | costumeArgs
  }

  export type costume_statInclude = {
    costume?: boolean | costumeArgs
  }

  export type costume_statGetPayload<
    S extends boolean | null | undefined | costume_statArgs,
    U = keyof S
      > = S extends true
        ? costume_stat
    : S extends undefined
    ? never
    : S extends costume_statArgs | costume_statFindManyArgs
    ?'include' extends U
    ? costume_stat  & {
    [P in TrueKeys<S['include']>]:
        P extends 'costume' ? costumeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'costume' ? costumeGetPayload<S['select'][P]> :  P extends keyof costume_stat ? costume_stat[P] : never
  } 
    : costume_stat
  : costume_stat


  type costume_statCountArgs = Merge<
    Omit<costume_statFindManyArgs, 'select' | 'include'> & {
      select?: Costume_statCountAggregateInputType | true
    }
  >

  export interface costume_statDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Costume_stat that matches the filter.
     * @param {costume_statFindUniqueArgs} args - Arguments to find a Costume_stat
     * @example
     * // Get one Costume_stat
     * const costume_stat = await prisma.costume_stat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends costume_statFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, costume_statFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'costume_stat'> extends True ? CheckSelect<T, Prisma__costume_statClient<costume_stat>, Prisma__costume_statClient<costume_statGetPayload<T>>> : CheckSelect<T, Prisma__costume_statClient<costume_stat | null >, Prisma__costume_statClient<costume_statGetPayload<T> | null >>

    /**
     * Find the first Costume_stat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_statFindFirstArgs} args - Arguments to find a Costume_stat
     * @example
     * // Get one Costume_stat
     * const costume_stat = await prisma.costume_stat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends costume_statFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, costume_statFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'costume_stat'> extends True ? CheckSelect<T, Prisma__costume_statClient<costume_stat>, Prisma__costume_statClient<costume_statGetPayload<T>>> : CheckSelect<T, Prisma__costume_statClient<costume_stat | null >, Prisma__costume_statClient<costume_statGetPayload<T> | null >>

    /**
     * Find zero or more Costume_stats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_statFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Costume_stats
     * const costume_stats = await prisma.costume_stat.findMany()
     * 
     * // Get first 10 Costume_stats
     * const costume_stats = await prisma.costume_stat.findMany({ take: 10 })
     * 
     * // Only select the `costume_id`
     * const costume_statWithCostume_idOnly = await prisma.costume_stat.findMany({ select: { costume_id: true } })
     * 
    **/
    findMany<T extends costume_statFindManyArgs>(
      args?: SelectSubset<T, costume_statFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<costume_stat>>, PrismaPromise<Array<costume_statGetPayload<T>>>>

    /**
     * Create a Costume_stat.
     * @param {costume_statCreateArgs} args - Arguments to create a Costume_stat.
     * @example
     * // Create one Costume_stat
     * const Costume_stat = await prisma.costume_stat.create({
     *   data: {
     *     // ... data to create a Costume_stat
     *   }
     * })
     * 
    **/
    create<T extends costume_statCreateArgs>(
      args: SelectSubset<T, costume_statCreateArgs>
    ): CheckSelect<T, Prisma__costume_statClient<costume_stat>, Prisma__costume_statClient<costume_statGetPayload<T>>>

    /**
     * Create many Costume_stats.
     *     @param {costume_statCreateManyArgs} args - Arguments to create many Costume_stats.
     *     @example
     *     // Create many Costume_stats
     *     const costume_stat = await prisma.costume_stat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends costume_statCreateManyArgs>(
      args?: SelectSubset<T, costume_statCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Costume_stat.
     * @param {costume_statDeleteArgs} args - Arguments to delete one Costume_stat.
     * @example
     * // Delete one Costume_stat
     * const Costume_stat = await prisma.costume_stat.delete({
     *   where: {
     *     // ... filter to delete one Costume_stat
     *   }
     * })
     * 
    **/
    delete<T extends costume_statDeleteArgs>(
      args: SelectSubset<T, costume_statDeleteArgs>
    ): CheckSelect<T, Prisma__costume_statClient<costume_stat>, Prisma__costume_statClient<costume_statGetPayload<T>>>

    /**
     * Update one Costume_stat.
     * @param {costume_statUpdateArgs} args - Arguments to update one Costume_stat.
     * @example
     * // Update one Costume_stat
     * const costume_stat = await prisma.costume_stat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends costume_statUpdateArgs>(
      args: SelectSubset<T, costume_statUpdateArgs>
    ): CheckSelect<T, Prisma__costume_statClient<costume_stat>, Prisma__costume_statClient<costume_statGetPayload<T>>>

    /**
     * Delete zero or more Costume_stats.
     * @param {costume_statDeleteManyArgs} args - Arguments to filter Costume_stats to delete.
     * @example
     * // Delete a few Costume_stats
     * const { count } = await prisma.costume_stat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends costume_statDeleteManyArgs>(
      args?: SelectSubset<T, costume_statDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Costume_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_statUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Costume_stats
     * const costume_stat = await prisma.costume_stat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends costume_statUpdateManyArgs>(
      args: SelectSubset<T, costume_statUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Costume_stat.
     * @param {costume_statUpsertArgs} args - Arguments to update or create a Costume_stat.
     * @example
     * // Update or create a Costume_stat
     * const costume_stat = await prisma.costume_stat.upsert({
     *   create: {
     *     // ... data to create a Costume_stat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Costume_stat we want to update
     *   }
     * })
    **/
    upsert<T extends costume_statUpsertArgs>(
      args: SelectSubset<T, costume_statUpsertArgs>
    ): CheckSelect<T, Prisma__costume_statClient<costume_stat>, Prisma__costume_statClient<costume_statGetPayload<T>>>

    /**
     * Count the number of Costume_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {costume_statCountArgs} args - Arguments to filter Costume_stats to count.
     * @example
     * // Count the number of Costume_stats
     * const count = await prisma.costume_stat.count({
     *   where: {
     *     // ... the filter for the Costume_stats we want to count
     *   }
     * })
    **/
    count<T extends costume_statCountArgs>(
      args?: Subset<T, costume_statCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Costume_statCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Costume_stat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Costume_statAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Costume_statAggregateArgs>(args: Subset<T, Costume_statAggregateArgs>): PrismaPromise<GetCostume_statAggregateType<T>>

    /**
     * Group by Costume_stat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Costume_statGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Costume_statGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Costume_statGroupByArgs['orderBy'] }
        : { orderBy?: Costume_statGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Costume_statGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostume_statGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for costume_stat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__costume_statClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    costume<T extends costumeArgs = {}>(args?: Subset<T, costumeArgs>): CheckSelect<T, Prisma__costumeClient<costume | null >, Prisma__costumeClient<costumeGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * costume_stat findUnique
   */
  export type costume_statFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the costume_stat
     * 
    **/
    select?: costume_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_statInclude | null
    /**
     * Throw an Error if a costume_stat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which costume_stat to fetch.
     * 
    **/
    where: costume_statWhereUniqueInput
  }


  /**
   * costume_stat findFirst
   */
  export type costume_statFindFirstArgs = {
    /**
     * Select specific fields to fetch from the costume_stat
     * 
    **/
    select?: costume_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_statInclude | null
    /**
     * Throw an Error if a costume_stat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which costume_stat to fetch.
     * 
    **/
    where?: costume_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costume_stats to fetch.
     * 
    **/
    orderBy?: Enumerable<costume_statOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for costume_stats.
     * 
    **/
    cursor?: costume_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costume_stats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costume_stats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of costume_stats.
     * 
    **/
    distinct?: Enumerable<Costume_statScalarFieldEnum>
  }


  /**
   * costume_stat findMany
   */
  export type costume_statFindManyArgs = {
    /**
     * Select specific fields to fetch from the costume_stat
     * 
    **/
    select?: costume_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_statInclude | null
    /**
     * Filter, which costume_stats to fetch.
     * 
    **/
    where?: costume_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of costume_stats to fetch.
     * 
    **/
    orderBy?: Enumerable<costume_statOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing costume_stats.
     * 
    **/
    cursor?: costume_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` costume_stats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` costume_stats.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Costume_statScalarFieldEnum>
  }


  /**
   * costume_stat create
   */
  export type costume_statCreateArgs = {
    /**
     * Select specific fields to fetch from the costume_stat
     * 
    **/
    select?: costume_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_statInclude | null
    /**
     * The data needed to create a costume_stat.
     * 
    **/
    data: XOR<costume_statCreateInput, costume_statUncheckedCreateInput>
  }


  /**
   * costume_stat createMany
   */
  export type costume_statCreateManyArgs = {
    /**
     * The data used to create many costume_stats.
     * 
    **/
    data: Enumerable<costume_statCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * costume_stat update
   */
  export type costume_statUpdateArgs = {
    /**
     * Select specific fields to fetch from the costume_stat
     * 
    **/
    select?: costume_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_statInclude | null
    /**
     * The data needed to update a costume_stat.
     * 
    **/
    data: XOR<costume_statUpdateInput, costume_statUncheckedUpdateInput>
    /**
     * Choose, which costume_stat to update.
     * 
    **/
    where: costume_statWhereUniqueInput
  }


  /**
   * costume_stat updateMany
   */
  export type costume_statUpdateManyArgs = {
    /**
     * The data used to update costume_stats.
     * 
    **/
    data: XOR<costume_statUpdateManyMutationInput, costume_statUncheckedUpdateManyInput>
    /**
     * Filter which costume_stats to update
     * 
    **/
    where?: costume_statWhereInput
  }


  /**
   * costume_stat upsert
   */
  export type costume_statUpsertArgs = {
    /**
     * Select specific fields to fetch from the costume_stat
     * 
    **/
    select?: costume_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_statInclude | null
    /**
     * The filter to search for the costume_stat to update in case it exists.
     * 
    **/
    where: costume_statWhereUniqueInput
    /**
     * In case the costume_stat found by the `where` argument doesn't exist, create a new costume_stat with this data.
     * 
    **/
    create: XOR<costume_statCreateInput, costume_statUncheckedCreateInput>
    /**
     * In case the costume_stat was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<costume_statUpdateInput, costume_statUncheckedUpdateInput>
  }


  /**
   * costume_stat delete
   */
  export type costume_statDeleteArgs = {
    /**
     * Select specific fields to fetch from the costume_stat
     * 
    **/
    select?: costume_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_statInclude | null
    /**
     * Filter which costume_stat to delete.
     * 
    **/
    where: costume_statWhereUniqueInput
  }


  /**
   * costume_stat deleteMany
   */
  export type costume_statDeleteManyArgs = {
    /**
     * Filter which costume_stats to delete
     * 
    **/
    where?: costume_statWhereInput
  }


  /**
   * costume_stat without action
   */
  export type costume_statArgs = {
    /**
     * Select specific fields to fetch from the costume_stat
     * 
    **/
    select?: costume_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: costume_statInclude | null
  }



  /**
   * Model emblem
   */


  export type AggregateEmblem = {
    _count: EmblemCountAggregateOutputType | null
    _avg: EmblemAvgAggregateOutputType | null
    _sum: EmblemSumAggregateOutputType | null
    _min: EmblemMinAggregateOutputType | null
    _max: EmblemMaxAggregateOutputType | null
  }

  export type EmblemAvgAggregateOutputType = {
    emblem_id: number | null
  }

  export type EmblemSumAggregateOutputType = {
    emblem_id: number | null
  }

  export type EmblemMinAggregateOutputType = {
    emblem_id: number | null
    name: string | null
    main_message: string | null
    small_messages: string | null
    image_path: string | null
  }

  export type EmblemMaxAggregateOutputType = {
    emblem_id: number | null
    name: string | null
    main_message: string | null
    small_messages: string | null
    image_path: string | null
  }

  export type EmblemCountAggregateOutputType = {
    emblem_id: number
    name: number
    main_message: number
    small_messages: number
    image_path: number
    _all: number
  }


  export type EmblemAvgAggregateInputType = {
    emblem_id?: true
  }

  export type EmblemSumAggregateInputType = {
    emblem_id?: true
  }

  export type EmblemMinAggregateInputType = {
    emblem_id?: true
    name?: true
    main_message?: true
    small_messages?: true
    image_path?: true
  }

  export type EmblemMaxAggregateInputType = {
    emblem_id?: true
    name?: true
    main_message?: true
    small_messages?: true
    image_path?: true
  }

  export type EmblemCountAggregateInputType = {
    emblem_id?: true
    name?: true
    main_message?: true
    small_messages?: true
    image_path?: true
    _all?: true
  }

  export type EmblemAggregateArgs = {
    /**
     * Filter which emblem to aggregate.
     * 
    **/
    where?: emblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emblems to fetch.
     * 
    **/
    orderBy?: Enumerable<emblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: emblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emblems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emblems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned emblems
    **/
    _count?: true | EmblemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmblemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmblemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmblemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmblemMaxAggregateInputType
  }

  export type GetEmblemAggregateType<T extends EmblemAggregateArgs> = {
        [P in keyof T & keyof AggregateEmblem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmblem[P]>
      : GetScalarType<T[P], AggregateEmblem[P]>
  }




  export type EmblemGroupByArgs = {
    where?: emblemWhereInput
    orderBy?: Enumerable<emblemOrderByWithAggregationInput>
    by: Array<EmblemScalarFieldEnum>
    having?: emblemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmblemCountAggregateInputType | true
    _avg?: EmblemAvgAggregateInputType
    _sum?: EmblemSumAggregateInputType
    _min?: EmblemMinAggregateInputType
    _max?: EmblemMaxAggregateInputType
  }


  export type EmblemGroupByOutputType = {
    emblem_id: number
    name: string | null
    main_message: string | null
    small_messages: string | null
    image_path: string | null
    _count: EmblemCountAggregateOutputType | null
    _avg: EmblemAvgAggregateOutputType | null
    _sum: EmblemSumAggregateOutputType | null
    _min: EmblemMinAggregateOutputType | null
    _max: EmblemMaxAggregateOutputType | null
  }

  type GetEmblemGroupByPayload<T extends EmblemGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EmblemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmblemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmblemGroupByOutputType[P]>
            : GetScalarType<T[P], EmblemGroupByOutputType[P]>
        }
      >
    >


  export type emblemSelect = {
    emblem_id?: boolean
    name?: boolean
    main_message?: boolean
    small_messages?: boolean
    image_path?: boolean
    costume?: boolean | costumeFindManyArgs
    _count?: boolean | EmblemCountOutputTypeArgs
  }

  export type emblemInclude = {
    costume?: boolean | costumeFindManyArgs
    _count?: boolean | EmblemCountOutputTypeArgs
  }

  export type emblemGetPayload<
    S extends boolean | null | undefined | emblemArgs,
    U = keyof S
      > = S extends true
        ? emblem
    : S extends undefined
    ? never
    : S extends emblemArgs | emblemFindManyArgs
    ?'include' extends U
    ? emblem  & {
    [P in TrueKeys<S['include']>]:
        P extends 'costume' ? Array < costumeGetPayload<S['include'][P]>>  :
        P extends '_count' ? EmblemCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'costume' ? Array < costumeGetPayload<S['select'][P]>>  :
        P extends '_count' ? EmblemCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof emblem ? emblem[P] : never
  } 
    : emblem
  : emblem


  type emblemCountArgs = Merge<
    Omit<emblemFindManyArgs, 'select' | 'include'> & {
      select?: EmblemCountAggregateInputType | true
    }
  >

  export interface emblemDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Emblem that matches the filter.
     * @param {emblemFindUniqueArgs} args - Arguments to find a Emblem
     * @example
     * // Get one Emblem
     * const emblem = await prisma.emblem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends emblemFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, emblemFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'emblem'> extends True ? CheckSelect<T, Prisma__emblemClient<emblem>, Prisma__emblemClient<emblemGetPayload<T>>> : CheckSelect<T, Prisma__emblemClient<emblem | null >, Prisma__emblemClient<emblemGetPayload<T> | null >>

    /**
     * Find the first Emblem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emblemFindFirstArgs} args - Arguments to find a Emblem
     * @example
     * // Get one Emblem
     * const emblem = await prisma.emblem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends emblemFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, emblemFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'emblem'> extends True ? CheckSelect<T, Prisma__emblemClient<emblem>, Prisma__emblemClient<emblemGetPayload<T>>> : CheckSelect<T, Prisma__emblemClient<emblem | null >, Prisma__emblemClient<emblemGetPayload<T> | null >>

    /**
     * Find zero or more Emblems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emblemFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emblems
     * const emblems = await prisma.emblem.findMany()
     * 
     * // Get first 10 Emblems
     * const emblems = await prisma.emblem.findMany({ take: 10 })
     * 
     * // Only select the `emblem_id`
     * const emblemWithEmblem_idOnly = await prisma.emblem.findMany({ select: { emblem_id: true } })
     * 
    **/
    findMany<T extends emblemFindManyArgs>(
      args?: SelectSubset<T, emblemFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<emblem>>, PrismaPromise<Array<emblemGetPayload<T>>>>

    /**
     * Create a Emblem.
     * @param {emblemCreateArgs} args - Arguments to create a Emblem.
     * @example
     * // Create one Emblem
     * const Emblem = await prisma.emblem.create({
     *   data: {
     *     // ... data to create a Emblem
     *   }
     * })
     * 
    **/
    create<T extends emblemCreateArgs>(
      args: SelectSubset<T, emblemCreateArgs>
    ): CheckSelect<T, Prisma__emblemClient<emblem>, Prisma__emblemClient<emblemGetPayload<T>>>

    /**
     * Create many Emblems.
     *     @param {emblemCreateManyArgs} args - Arguments to create many Emblems.
     *     @example
     *     // Create many Emblems
     *     const emblem = await prisma.emblem.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends emblemCreateManyArgs>(
      args?: SelectSubset<T, emblemCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Emblem.
     * @param {emblemDeleteArgs} args - Arguments to delete one Emblem.
     * @example
     * // Delete one Emblem
     * const Emblem = await prisma.emblem.delete({
     *   where: {
     *     // ... filter to delete one Emblem
     *   }
     * })
     * 
    **/
    delete<T extends emblemDeleteArgs>(
      args: SelectSubset<T, emblemDeleteArgs>
    ): CheckSelect<T, Prisma__emblemClient<emblem>, Prisma__emblemClient<emblemGetPayload<T>>>

    /**
     * Update one Emblem.
     * @param {emblemUpdateArgs} args - Arguments to update one Emblem.
     * @example
     * // Update one Emblem
     * const emblem = await prisma.emblem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends emblemUpdateArgs>(
      args: SelectSubset<T, emblemUpdateArgs>
    ): CheckSelect<T, Prisma__emblemClient<emblem>, Prisma__emblemClient<emblemGetPayload<T>>>

    /**
     * Delete zero or more Emblems.
     * @param {emblemDeleteManyArgs} args - Arguments to filter Emblems to delete.
     * @example
     * // Delete a few Emblems
     * const { count } = await prisma.emblem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends emblemDeleteManyArgs>(
      args?: SelectSubset<T, emblemDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emblemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emblems
     * const emblem = await prisma.emblem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends emblemUpdateManyArgs>(
      args: SelectSubset<T, emblemUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Emblem.
     * @param {emblemUpsertArgs} args - Arguments to update or create a Emblem.
     * @example
     * // Update or create a Emblem
     * const emblem = await prisma.emblem.upsert({
     *   create: {
     *     // ... data to create a Emblem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Emblem we want to update
     *   }
     * })
    **/
    upsert<T extends emblemUpsertArgs>(
      args: SelectSubset<T, emblemUpsertArgs>
    ): CheckSelect<T, Prisma__emblemClient<emblem>, Prisma__emblemClient<emblemGetPayload<T>>>

    /**
     * Count the number of Emblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {emblemCountArgs} args - Arguments to filter Emblems to count.
     * @example
     * // Count the number of Emblems
     * const count = await prisma.emblem.count({
     *   where: {
     *     // ... the filter for the Emblems we want to count
     *   }
     * })
    **/
    count<T extends emblemCountArgs>(
      args?: Subset<T, emblemCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmblemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Emblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmblemAggregateArgs>(args: Subset<T, EmblemAggregateArgs>): PrismaPromise<GetEmblemAggregateType<T>>

    /**
     * Group by Emblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmblemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmblemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmblemGroupByArgs['orderBy'] }
        : { orderBy?: EmblemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmblemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmblemGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for emblem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__emblemClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    costume<T extends costumeFindManyArgs = {}>(args?: Subset<T, costumeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<costume>>, PrismaPromise<Array<costumeGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * emblem findUnique
   */
  export type emblemFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the emblem
     * 
    **/
    select?: emblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: emblemInclude | null
    /**
     * Throw an Error if a emblem can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which emblem to fetch.
     * 
    **/
    where: emblemWhereUniqueInput
  }


  /**
   * emblem findFirst
   */
  export type emblemFindFirstArgs = {
    /**
     * Select specific fields to fetch from the emblem
     * 
    **/
    select?: emblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: emblemInclude | null
    /**
     * Throw an Error if a emblem can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which emblem to fetch.
     * 
    **/
    where?: emblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emblems to fetch.
     * 
    **/
    orderBy?: Enumerable<emblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for emblems.
     * 
    **/
    cursor?: emblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emblems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emblems.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of emblems.
     * 
    **/
    distinct?: Enumerable<EmblemScalarFieldEnum>
  }


  /**
   * emblem findMany
   */
  export type emblemFindManyArgs = {
    /**
     * Select specific fields to fetch from the emblem
     * 
    **/
    select?: emblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: emblemInclude | null
    /**
     * Filter, which emblems to fetch.
     * 
    **/
    where?: emblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of emblems to fetch.
     * 
    **/
    orderBy?: Enumerable<emblemOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing emblems.
     * 
    **/
    cursor?: emblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` emblems from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` emblems.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EmblemScalarFieldEnum>
  }


  /**
   * emblem create
   */
  export type emblemCreateArgs = {
    /**
     * Select specific fields to fetch from the emblem
     * 
    **/
    select?: emblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: emblemInclude | null
    /**
     * The data needed to create a emblem.
     * 
    **/
    data: XOR<emblemCreateInput, emblemUncheckedCreateInput>
  }


  /**
   * emblem createMany
   */
  export type emblemCreateManyArgs = {
    /**
     * The data used to create many emblems.
     * 
    **/
    data: Enumerable<emblemCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * emblem update
   */
  export type emblemUpdateArgs = {
    /**
     * Select specific fields to fetch from the emblem
     * 
    **/
    select?: emblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: emblemInclude | null
    /**
     * The data needed to update a emblem.
     * 
    **/
    data: XOR<emblemUpdateInput, emblemUncheckedUpdateInput>
    /**
     * Choose, which emblem to update.
     * 
    **/
    where: emblemWhereUniqueInput
  }


  /**
   * emblem updateMany
   */
  export type emblemUpdateManyArgs = {
    /**
     * The data used to update emblems.
     * 
    **/
    data: XOR<emblemUpdateManyMutationInput, emblemUncheckedUpdateManyInput>
    /**
     * Filter which emblems to update
     * 
    **/
    where?: emblemWhereInput
  }


  /**
   * emblem upsert
   */
  export type emblemUpsertArgs = {
    /**
     * Select specific fields to fetch from the emblem
     * 
    **/
    select?: emblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: emblemInclude | null
    /**
     * The filter to search for the emblem to update in case it exists.
     * 
    **/
    where: emblemWhereUniqueInput
    /**
     * In case the emblem found by the `where` argument doesn't exist, create a new emblem with this data.
     * 
    **/
    create: XOR<emblemCreateInput, emblemUncheckedCreateInput>
    /**
     * In case the emblem was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<emblemUpdateInput, emblemUncheckedUpdateInput>
  }


  /**
   * emblem delete
   */
  export type emblemDeleteArgs = {
    /**
     * Select specific fields to fetch from the emblem
     * 
    **/
    select?: emblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: emblemInclude | null
    /**
     * Filter which emblem to delete.
     * 
    **/
    where: emblemWhereUniqueInput
  }


  /**
   * emblem deleteMany
   */
  export type emblemDeleteManyArgs = {
    /**
     * Filter which emblems to delete
     * 
    **/
    where?: emblemWhereInput
  }


  /**
   * emblem without action
   */
  export type emblemArgs = {
    /**
     * Select specific fields to fetch from the emblem
     * 
    **/
    select?: emblemSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: emblemInclude | null
  }



  /**
   * Model memoir
   */


  export type AggregateMemoir = {
    _count: MemoirCountAggregateOutputType | null
    _avg: MemoirAvgAggregateOutputType | null
    _sum: MemoirSumAggregateOutputType | null
    _min: MemoirMinAggregateOutputType | null
    _max: MemoirMaxAggregateOutputType | null
  }

  export type MemoirAvgAggregateOutputType = {
    memoir_id: number | null
    lottery_id: number | null
    memoir_series_id: number | null
  }

  export type MemoirSumAggregateOutputType = {
    memoir_id: number | null
    lottery_id: number | null
    memoir_series_id: number | null
  }

  export type MemoirMinAggregateOutputType = {
    memoir_id: number | null
    lottery_id: number | null
    rarity: string | null
    release_time: Date | null
    name: string | null
    story: string | null
    image_path_base: string | null
    memoir_series_id: number | null
  }

  export type MemoirMaxAggregateOutputType = {
    memoir_id: number | null
    lottery_id: number | null
    rarity: string | null
    release_time: Date | null
    name: string | null
    story: string | null
    image_path_base: string | null
    memoir_series_id: number | null
  }

  export type MemoirCountAggregateOutputType = {
    memoir_id: number
    lottery_id: number
    rarity: number
    release_time: number
    name: number
    story: number
    image_path_base: number
    memoir_series_id: number
    _all: number
  }


  export type MemoirAvgAggregateInputType = {
    memoir_id?: true
    lottery_id?: true
    memoir_series_id?: true
  }

  export type MemoirSumAggregateInputType = {
    memoir_id?: true
    lottery_id?: true
    memoir_series_id?: true
  }

  export type MemoirMinAggregateInputType = {
    memoir_id?: true
    lottery_id?: true
    rarity?: true
    release_time?: true
    name?: true
    story?: true
    image_path_base?: true
    memoir_series_id?: true
  }

  export type MemoirMaxAggregateInputType = {
    memoir_id?: true
    lottery_id?: true
    rarity?: true
    release_time?: true
    name?: true
    story?: true
    image_path_base?: true
    memoir_series_id?: true
  }

  export type MemoirCountAggregateInputType = {
    memoir_id?: true
    lottery_id?: true
    rarity?: true
    release_time?: true
    name?: true
    story?: true
    image_path_base?: true
    memoir_series_id?: true
    _all?: true
  }

  export type MemoirAggregateArgs = {
    /**
     * Filter which memoir to aggregate.
     * 
    **/
    where?: memoirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of memoirs to fetch.
     * 
    **/
    orderBy?: Enumerable<memoirOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: memoirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` memoirs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` memoirs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned memoirs
    **/
    _count?: true | MemoirCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemoirAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemoirSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemoirMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemoirMaxAggregateInputType
  }

  export type GetMemoirAggregateType<T extends MemoirAggregateArgs> = {
        [P in keyof T & keyof AggregateMemoir]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemoir[P]>
      : GetScalarType<T[P], AggregateMemoir[P]>
  }




  export type MemoirGroupByArgs = {
    where?: memoirWhereInput
    orderBy?: Enumerable<memoirOrderByWithAggregationInput>
    by: Array<MemoirScalarFieldEnum>
    having?: memoirScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemoirCountAggregateInputType | true
    _avg?: MemoirAvgAggregateInputType
    _sum?: MemoirSumAggregateInputType
    _min?: MemoirMinAggregateInputType
    _max?: MemoirMaxAggregateInputType
  }


  export type MemoirGroupByOutputType = {
    memoir_id: number
    lottery_id: number
    rarity: string | null
    release_time: Date
    name: string | null
    story: string | null
    image_path_base: string | null
    memoir_series_id: number | null
    _count: MemoirCountAggregateOutputType | null
    _avg: MemoirAvgAggregateOutputType | null
    _sum: MemoirSumAggregateOutputType | null
    _min: MemoirMinAggregateOutputType | null
    _max: MemoirMaxAggregateOutputType | null
  }

  type GetMemoirGroupByPayload<T extends MemoirGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MemoirGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemoirGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemoirGroupByOutputType[P]>
            : GetScalarType<T[P], MemoirGroupByOutputType[P]>
        }
      >
    >


  export type memoirSelect = {
    memoir_id?: boolean
    lottery_id?: boolean
    rarity?: boolean
    release_time?: boolean
    name?: boolean
    story?: boolean
    image_path_base?: boolean
    memoir_series_id?: boolean
    memoir_series?: boolean | memoir_seriesArgs
  }

  export type memoirInclude = {
    memoir_series?: boolean | memoir_seriesArgs
  }

  export type memoirGetPayload<
    S extends boolean | null | undefined | memoirArgs,
    U = keyof S
      > = S extends true
        ? memoir
    : S extends undefined
    ? never
    : S extends memoirArgs | memoirFindManyArgs
    ?'include' extends U
    ? memoir  & {
    [P in TrueKeys<S['include']>]:
        P extends 'memoir_series' ? memoir_seriesGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'memoir_series' ? memoir_seriesGetPayload<S['select'][P]> | null :  P extends keyof memoir ? memoir[P] : never
  } 
    : memoir
  : memoir


  type memoirCountArgs = Merge<
    Omit<memoirFindManyArgs, 'select' | 'include'> & {
      select?: MemoirCountAggregateInputType | true
    }
  >

  export interface memoirDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Memoir that matches the filter.
     * @param {memoirFindUniqueArgs} args - Arguments to find a Memoir
     * @example
     * // Get one Memoir
     * const memoir = await prisma.memoir.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends memoirFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, memoirFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'memoir'> extends True ? CheckSelect<T, Prisma__memoirClient<memoir>, Prisma__memoirClient<memoirGetPayload<T>>> : CheckSelect<T, Prisma__memoirClient<memoir | null >, Prisma__memoirClient<memoirGetPayload<T> | null >>

    /**
     * Find the first Memoir that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memoirFindFirstArgs} args - Arguments to find a Memoir
     * @example
     * // Get one Memoir
     * const memoir = await prisma.memoir.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends memoirFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, memoirFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'memoir'> extends True ? CheckSelect<T, Prisma__memoirClient<memoir>, Prisma__memoirClient<memoirGetPayload<T>>> : CheckSelect<T, Prisma__memoirClient<memoir | null >, Prisma__memoirClient<memoirGetPayload<T> | null >>

    /**
     * Find zero or more Memoirs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memoirFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memoirs
     * const memoirs = await prisma.memoir.findMany()
     * 
     * // Get first 10 Memoirs
     * const memoirs = await prisma.memoir.findMany({ take: 10 })
     * 
     * // Only select the `memoir_id`
     * const memoirWithMemoir_idOnly = await prisma.memoir.findMany({ select: { memoir_id: true } })
     * 
    **/
    findMany<T extends memoirFindManyArgs>(
      args?: SelectSubset<T, memoirFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<memoir>>, PrismaPromise<Array<memoirGetPayload<T>>>>

    /**
     * Create a Memoir.
     * @param {memoirCreateArgs} args - Arguments to create a Memoir.
     * @example
     * // Create one Memoir
     * const Memoir = await prisma.memoir.create({
     *   data: {
     *     // ... data to create a Memoir
     *   }
     * })
     * 
    **/
    create<T extends memoirCreateArgs>(
      args: SelectSubset<T, memoirCreateArgs>
    ): CheckSelect<T, Prisma__memoirClient<memoir>, Prisma__memoirClient<memoirGetPayload<T>>>

    /**
     * Create many Memoirs.
     *     @param {memoirCreateManyArgs} args - Arguments to create many Memoirs.
     *     @example
     *     // Create many Memoirs
     *     const memoir = await prisma.memoir.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends memoirCreateManyArgs>(
      args?: SelectSubset<T, memoirCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Memoir.
     * @param {memoirDeleteArgs} args - Arguments to delete one Memoir.
     * @example
     * // Delete one Memoir
     * const Memoir = await prisma.memoir.delete({
     *   where: {
     *     // ... filter to delete one Memoir
     *   }
     * })
     * 
    **/
    delete<T extends memoirDeleteArgs>(
      args: SelectSubset<T, memoirDeleteArgs>
    ): CheckSelect<T, Prisma__memoirClient<memoir>, Prisma__memoirClient<memoirGetPayload<T>>>

    /**
     * Update one Memoir.
     * @param {memoirUpdateArgs} args - Arguments to update one Memoir.
     * @example
     * // Update one Memoir
     * const memoir = await prisma.memoir.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends memoirUpdateArgs>(
      args: SelectSubset<T, memoirUpdateArgs>
    ): CheckSelect<T, Prisma__memoirClient<memoir>, Prisma__memoirClient<memoirGetPayload<T>>>

    /**
     * Delete zero or more Memoirs.
     * @param {memoirDeleteManyArgs} args - Arguments to filter Memoirs to delete.
     * @example
     * // Delete a few Memoirs
     * const { count } = await prisma.memoir.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends memoirDeleteManyArgs>(
      args?: SelectSubset<T, memoirDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memoirs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memoirUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memoirs
     * const memoir = await prisma.memoir.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends memoirUpdateManyArgs>(
      args: SelectSubset<T, memoirUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Memoir.
     * @param {memoirUpsertArgs} args - Arguments to update or create a Memoir.
     * @example
     * // Update or create a Memoir
     * const memoir = await prisma.memoir.upsert({
     *   create: {
     *     // ... data to create a Memoir
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Memoir we want to update
     *   }
     * })
    **/
    upsert<T extends memoirUpsertArgs>(
      args: SelectSubset<T, memoirUpsertArgs>
    ): CheckSelect<T, Prisma__memoirClient<memoir>, Prisma__memoirClient<memoirGetPayload<T>>>

    /**
     * Count the number of Memoirs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memoirCountArgs} args - Arguments to filter Memoirs to count.
     * @example
     * // Count the number of Memoirs
     * const count = await prisma.memoir.count({
     *   where: {
     *     // ... the filter for the Memoirs we want to count
     *   }
     * })
    **/
    count<T extends memoirCountArgs>(
      args?: Subset<T, memoirCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemoirCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Memoir.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoirAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemoirAggregateArgs>(args: Subset<T, MemoirAggregateArgs>): PrismaPromise<GetMemoirAggregateType<T>>

    /**
     * Group by Memoir.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemoirGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemoirGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemoirGroupByArgs['orderBy'] }
        : { orderBy?: MemoirGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemoirGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemoirGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for memoir.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__memoirClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    memoir_series<T extends memoir_seriesArgs = {}>(args?: Subset<T, memoir_seriesArgs>): CheckSelect<T, Prisma__memoir_seriesClient<memoir_series | null >, Prisma__memoir_seriesClient<memoir_seriesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * memoir findUnique
   */
  export type memoirFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the memoir
     * 
    **/
    select?: memoirSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: memoirInclude | null
    /**
     * Throw an Error if a memoir can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which memoir to fetch.
     * 
    **/
    where: memoirWhereUniqueInput
  }


  /**
   * memoir findFirst
   */
  export type memoirFindFirstArgs = {
    /**
     * Select specific fields to fetch from the memoir
     * 
    **/
    select?: memoirSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: memoirInclude | null
    /**
     * Throw an Error if a memoir can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which memoir to fetch.
     * 
    **/
    where?: memoirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of memoirs to fetch.
     * 
    **/
    orderBy?: Enumerable<memoirOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for memoirs.
     * 
    **/
    cursor?: memoirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` memoirs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` memoirs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of memoirs.
     * 
    **/
    distinct?: Enumerable<MemoirScalarFieldEnum>
  }


  /**
   * memoir findMany
   */
  export type memoirFindManyArgs = {
    /**
     * Select specific fields to fetch from the memoir
     * 
    **/
    select?: memoirSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: memoirInclude | null
    /**
     * Filter, which memoirs to fetch.
     * 
    **/
    where?: memoirWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of memoirs to fetch.
     * 
    **/
    orderBy?: Enumerable<memoirOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing memoirs.
     * 
    **/
    cursor?: memoirWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` memoirs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` memoirs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MemoirScalarFieldEnum>
  }


  /**
   * memoir create
   */
  export type memoirCreateArgs = {
    /**
     * Select specific fields to fetch from the memoir
     * 
    **/
    select?: memoirSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: memoirInclude | null
    /**
     * The data needed to create a memoir.
     * 
    **/
    data: XOR<memoirCreateInput, memoirUncheckedCreateInput>
  }


  /**
   * memoir createMany
   */
  export type memoirCreateManyArgs = {
    /**
     * The data used to create many memoirs.
     * 
    **/
    data: Enumerable<memoirCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * memoir update
   */
  export type memoirUpdateArgs = {
    /**
     * Select specific fields to fetch from the memoir
     * 
    **/
    select?: memoirSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: memoirInclude | null
    /**
     * The data needed to update a memoir.
     * 
    **/
    data: XOR<memoirUpdateInput, memoirUncheckedUpdateInput>
    /**
     * Choose, which memoir to update.
     * 
    **/
    where: memoirWhereUniqueInput
  }


  /**
   * memoir updateMany
   */
  export type memoirUpdateManyArgs = {
    /**
     * The data used to update memoirs.
     * 
    **/
    data: XOR<memoirUpdateManyMutationInput, memoirUncheckedUpdateManyInput>
    /**
     * Filter which memoirs to update
     * 
    **/
    where?: memoirWhereInput
  }


  /**
   * memoir upsert
   */
  export type memoirUpsertArgs = {
    /**
     * Select specific fields to fetch from the memoir
     * 
    **/
    select?: memoirSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: memoirInclude | null
    /**
     * The filter to search for the memoir to update in case it exists.
     * 
    **/
    where: memoirWhereUniqueInput
    /**
     * In case the memoir found by the `where` argument doesn't exist, create a new memoir with this data.
     * 
    **/
    create: XOR<memoirCreateInput, memoirUncheckedCreateInput>
    /**
     * In case the memoir was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<memoirUpdateInput, memoirUncheckedUpdateInput>
  }


  /**
   * memoir delete
   */
  export type memoirDeleteArgs = {
    /**
     * Select specific fields to fetch from the memoir
     * 
    **/
    select?: memoirSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: memoirInclude | null
    /**
     * Filter which memoir to delete.
     * 
    **/
    where: memoirWhereUniqueInput
  }


  /**
   * memoir deleteMany
   */
  export type memoirDeleteManyArgs = {
    /**
     * Filter which memoirs to delete
     * 
    **/
    where?: memoirWhereInput
  }


  /**
   * memoir without action
   */
  export type memoirArgs = {
    /**
     * Select specific fields to fetch from the memoir
     * 
    **/
    select?: memoirSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: memoirInclude | null
  }



  /**
   * Model memoir_series
   */


  export type AggregateMemoir_series = {
    _count: Memoir_seriesCountAggregateOutputType | null
    _avg: Memoir_seriesAvgAggregateOutputType | null
    _sum: Memoir_seriesSumAggregateOutputType | null
    _min: Memoir_seriesMinAggregateOutputType | null
    _max: Memoir_seriesMaxAggregateOutputType | null
  }

  export type Memoir_seriesAvgAggregateOutputType = {
    memoir_series_id: number | null
  }

  export type Memoir_seriesSumAggregateOutputType = {
    memoir_series_id: number | null
  }

  export type Memoir_seriesMinAggregateOutputType = {
    memoir_series_id: number | null
    name: string | null
    small_set_description: string | null
    large_set_description: string | null
  }

  export type Memoir_seriesMaxAggregateOutputType = {
    memoir_series_id: number | null
    name: string | null
    small_set_description: string | null
    large_set_description: string | null
  }

  export type Memoir_seriesCountAggregateOutputType = {
    memoir_series_id: number
    name: number
    small_set_description: number
    large_set_description: number
    _all: number
  }


  export type Memoir_seriesAvgAggregateInputType = {
    memoir_series_id?: true
  }

  export type Memoir_seriesSumAggregateInputType = {
    memoir_series_id?: true
  }

  export type Memoir_seriesMinAggregateInputType = {
    memoir_series_id?: true
    name?: true
    small_set_description?: true
    large_set_description?: true
  }

  export type Memoir_seriesMaxAggregateInputType = {
    memoir_series_id?: true
    name?: true
    small_set_description?: true
    large_set_description?: true
  }

  export type Memoir_seriesCountAggregateInputType = {
    memoir_series_id?: true
    name?: true
    small_set_description?: true
    large_set_description?: true
    _all?: true
  }

  export type Memoir_seriesAggregateArgs = {
    /**
     * Filter which memoir_series to aggregate.
     * 
    **/
    where?: memoir_seriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of memoir_series to fetch.
     * 
    **/
    orderBy?: Enumerable<memoir_seriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: memoir_seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` memoir_series from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` memoir_series.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned memoir_series
    **/
    _count?: true | Memoir_seriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Memoir_seriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Memoir_seriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Memoir_seriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Memoir_seriesMaxAggregateInputType
  }

  export type GetMemoir_seriesAggregateType<T extends Memoir_seriesAggregateArgs> = {
        [P in keyof T & keyof AggregateMemoir_series]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMemoir_series[P]>
      : GetScalarType<T[P], AggregateMemoir_series[P]>
  }




  export type Memoir_seriesGroupByArgs = {
    where?: memoir_seriesWhereInput
    orderBy?: Enumerable<memoir_seriesOrderByWithAggregationInput>
    by: Array<Memoir_seriesScalarFieldEnum>
    having?: memoir_seriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Memoir_seriesCountAggregateInputType | true
    _avg?: Memoir_seriesAvgAggregateInputType
    _sum?: Memoir_seriesSumAggregateInputType
    _min?: Memoir_seriesMinAggregateInputType
    _max?: Memoir_seriesMaxAggregateInputType
  }


  export type Memoir_seriesGroupByOutputType = {
    memoir_series_id: number
    name: string | null
    small_set_description: string | null
    large_set_description: string | null
    _count: Memoir_seriesCountAggregateOutputType | null
    _avg: Memoir_seriesAvgAggregateOutputType | null
    _sum: Memoir_seriesSumAggregateOutputType | null
    _min: Memoir_seriesMinAggregateOutputType | null
    _max: Memoir_seriesMaxAggregateOutputType | null
  }

  type GetMemoir_seriesGroupByPayload<T extends Memoir_seriesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Memoir_seriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Memoir_seriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Memoir_seriesGroupByOutputType[P]>
            : GetScalarType<T[P], Memoir_seriesGroupByOutputType[P]>
        }
      >
    >


  export type memoir_seriesSelect = {
    memoir_series_id?: boolean
    name?: boolean
    small_set_description?: boolean
    large_set_description?: boolean
    memoir?: boolean | memoirFindManyArgs
    _count?: boolean | Memoir_seriesCountOutputTypeArgs
  }

  export type memoir_seriesInclude = {
    memoir?: boolean | memoirFindManyArgs
    _count?: boolean | Memoir_seriesCountOutputTypeArgs
  }

  export type memoir_seriesGetPayload<
    S extends boolean | null | undefined | memoir_seriesArgs,
    U = keyof S
      > = S extends true
        ? memoir_series
    : S extends undefined
    ? never
    : S extends memoir_seriesArgs | memoir_seriesFindManyArgs
    ?'include' extends U
    ? memoir_series  & {
    [P in TrueKeys<S['include']>]:
        P extends 'memoir' ? Array < memoirGetPayload<S['include'][P]>>  :
        P extends '_count' ? Memoir_seriesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'memoir' ? Array < memoirGetPayload<S['select'][P]>>  :
        P extends '_count' ? Memoir_seriesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof memoir_series ? memoir_series[P] : never
  } 
    : memoir_series
  : memoir_series


  type memoir_seriesCountArgs = Merge<
    Omit<memoir_seriesFindManyArgs, 'select' | 'include'> & {
      select?: Memoir_seriesCountAggregateInputType | true
    }
  >

  export interface memoir_seriesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Memoir_series that matches the filter.
     * @param {memoir_seriesFindUniqueArgs} args - Arguments to find a Memoir_series
     * @example
     * // Get one Memoir_series
     * const memoir_series = await prisma.memoir_series.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends memoir_seriesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, memoir_seriesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'memoir_series'> extends True ? CheckSelect<T, Prisma__memoir_seriesClient<memoir_series>, Prisma__memoir_seriesClient<memoir_seriesGetPayload<T>>> : CheckSelect<T, Prisma__memoir_seriesClient<memoir_series | null >, Prisma__memoir_seriesClient<memoir_seriesGetPayload<T> | null >>

    /**
     * Find the first Memoir_series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memoir_seriesFindFirstArgs} args - Arguments to find a Memoir_series
     * @example
     * // Get one Memoir_series
     * const memoir_series = await prisma.memoir_series.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends memoir_seriesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, memoir_seriesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'memoir_series'> extends True ? CheckSelect<T, Prisma__memoir_seriesClient<memoir_series>, Prisma__memoir_seriesClient<memoir_seriesGetPayload<T>>> : CheckSelect<T, Prisma__memoir_seriesClient<memoir_series | null >, Prisma__memoir_seriesClient<memoir_seriesGetPayload<T> | null >>

    /**
     * Find zero or more Memoir_series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memoir_seriesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Memoir_series
     * const memoir_series = await prisma.memoir_series.findMany()
     * 
     * // Get first 10 Memoir_series
     * const memoir_series = await prisma.memoir_series.findMany({ take: 10 })
     * 
     * // Only select the `memoir_series_id`
     * const memoir_seriesWithMemoir_series_idOnly = await prisma.memoir_series.findMany({ select: { memoir_series_id: true } })
     * 
    **/
    findMany<T extends memoir_seriesFindManyArgs>(
      args?: SelectSubset<T, memoir_seriesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<memoir_series>>, PrismaPromise<Array<memoir_seriesGetPayload<T>>>>

    /**
     * Create a Memoir_series.
     * @param {memoir_seriesCreateArgs} args - Arguments to create a Memoir_series.
     * @example
     * // Create one Memoir_series
     * const Memoir_series = await prisma.memoir_series.create({
     *   data: {
     *     // ... data to create a Memoir_series
     *   }
     * })
     * 
    **/
    create<T extends memoir_seriesCreateArgs>(
      args: SelectSubset<T, memoir_seriesCreateArgs>
    ): CheckSelect<T, Prisma__memoir_seriesClient<memoir_series>, Prisma__memoir_seriesClient<memoir_seriesGetPayload<T>>>

    /**
     * Create many Memoir_series.
     *     @param {memoir_seriesCreateManyArgs} args - Arguments to create many Memoir_series.
     *     @example
     *     // Create many Memoir_series
     *     const memoir_series = await prisma.memoir_series.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends memoir_seriesCreateManyArgs>(
      args?: SelectSubset<T, memoir_seriesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Memoir_series.
     * @param {memoir_seriesDeleteArgs} args - Arguments to delete one Memoir_series.
     * @example
     * // Delete one Memoir_series
     * const Memoir_series = await prisma.memoir_series.delete({
     *   where: {
     *     // ... filter to delete one Memoir_series
     *   }
     * })
     * 
    **/
    delete<T extends memoir_seriesDeleteArgs>(
      args: SelectSubset<T, memoir_seriesDeleteArgs>
    ): CheckSelect<T, Prisma__memoir_seriesClient<memoir_series>, Prisma__memoir_seriesClient<memoir_seriesGetPayload<T>>>

    /**
     * Update one Memoir_series.
     * @param {memoir_seriesUpdateArgs} args - Arguments to update one Memoir_series.
     * @example
     * // Update one Memoir_series
     * const memoir_series = await prisma.memoir_series.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends memoir_seriesUpdateArgs>(
      args: SelectSubset<T, memoir_seriesUpdateArgs>
    ): CheckSelect<T, Prisma__memoir_seriesClient<memoir_series>, Prisma__memoir_seriesClient<memoir_seriesGetPayload<T>>>

    /**
     * Delete zero or more Memoir_series.
     * @param {memoir_seriesDeleteManyArgs} args - Arguments to filter Memoir_series to delete.
     * @example
     * // Delete a few Memoir_series
     * const { count } = await prisma.memoir_series.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends memoir_seriesDeleteManyArgs>(
      args?: SelectSubset<T, memoir_seriesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Memoir_series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memoir_seriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Memoir_series
     * const memoir_series = await prisma.memoir_series.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends memoir_seriesUpdateManyArgs>(
      args: SelectSubset<T, memoir_seriesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Memoir_series.
     * @param {memoir_seriesUpsertArgs} args - Arguments to update or create a Memoir_series.
     * @example
     * // Update or create a Memoir_series
     * const memoir_series = await prisma.memoir_series.upsert({
     *   create: {
     *     // ... data to create a Memoir_series
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Memoir_series we want to update
     *   }
     * })
    **/
    upsert<T extends memoir_seriesUpsertArgs>(
      args: SelectSubset<T, memoir_seriesUpsertArgs>
    ): CheckSelect<T, Prisma__memoir_seriesClient<memoir_series>, Prisma__memoir_seriesClient<memoir_seriesGetPayload<T>>>

    /**
     * Count the number of Memoir_series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memoir_seriesCountArgs} args - Arguments to filter Memoir_series to count.
     * @example
     * // Count the number of Memoir_series
     * const count = await prisma.memoir_series.count({
     *   where: {
     *     // ... the filter for the Memoir_series we want to count
     *   }
     * })
    **/
    count<T extends memoir_seriesCountArgs>(
      args?: Subset<T, memoir_seriesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Memoir_seriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Memoir_series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Memoir_seriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Memoir_seriesAggregateArgs>(args: Subset<T, Memoir_seriesAggregateArgs>): PrismaPromise<GetMemoir_seriesAggregateType<T>>

    /**
     * Group by Memoir_series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Memoir_seriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Memoir_seriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Memoir_seriesGroupByArgs['orderBy'] }
        : { orderBy?: Memoir_seriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Memoir_seriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemoir_seriesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for memoir_series.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__memoir_seriesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    memoir<T extends memoirFindManyArgs = {}>(args?: Subset<T, memoirFindManyArgs>): CheckSelect<T, PrismaPromise<Array<memoir>>, PrismaPromise<Array<memoirGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * memoir_series findUnique
   */
  export type memoir_seriesFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the memoir_series
     * 
    **/
    select?: memoir_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: memoir_seriesInclude | null
    /**
     * Throw an Error if a memoir_series can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which memoir_series to fetch.
     * 
    **/
    where: memoir_seriesWhereUniqueInput
  }


  /**
   * memoir_series findFirst
   */
  export type memoir_seriesFindFirstArgs = {
    /**
     * Select specific fields to fetch from the memoir_series
     * 
    **/
    select?: memoir_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: memoir_seriesInclude | null
    /**
     * Throw an Error if a memoir_series can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which memoir_series to fetch.
     * 
    **/
    where?: memoir_seriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of memoir_series to fetch.
     * 
    **/
    orderBy?: Enumerable<memoir_seriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for memoir_series.
     * 
    **/
    cursor?: memoir_seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` memoir_series from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` memoir_series.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of memoir_series.
     * 
    **/
    distinct?: Enumerable<Memoir_seriesScalarFieldEnum>
  }


  /**
   * memoir_series findMany
   */
  export type memoir_seriesFindManyArgs = {
    /**
     * Select specific fields to fetch from the memoir_series
     * 
    **/
    select?: memoir_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: memoir_seriesInclude | null
    /**
     * Filter, which memoir_series to fetch.
     * 
    **/
    where?: memoir_seriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of memoir_series to fetch.
     * 
    **/
    orderBy?: Enumerable<memoir_seriesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing memoir_series.
     * 
    **/
    cursor?: memoir_seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` memoir_series from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` memoir_series.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Memoir_seriesScalarFieldEnum>
  }


  /**
   * memoir_series create
   */
  export type memoir_seriesCreateArgs = {
    /**
     * Select specific fields to fetch from the memoir_series
     * 
    **/
    select?: memoir_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: memoir_seriesInclude | null
    /**
     * The data needed to create a memoir_series.
     * 
    **/
    data: XOR<memoir_seriesCreateInput, memoir_seriesUncheckedCreateInput>
  }


  /**
   * memoir_series createMany
   */
  export type memoir_seriesCreateManyArgs = {
    /**
     * The data used to create many memoir_series.
     * 
    **/
    data: Enumerable<memoir_seriesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * memoir_series update
   */
  export type memoir_seriesUpdateArgs = {
    /**
     * Select specific fields to fetch from the memoir_series
     * 
    **/
    select?: memoir_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: memoir_seriesInclude | null
    /**
     * The data needed to update a memoir_series.
     * 
    **/
    data: XOR<memoir_seriesUpdateInput, memoir_seriesUncheckedUpdateInput>
    /**
     * Choose, which memoir_series to update.
     * 
    **/
    where: memoir_seriesWhereUniqueInput
  }


  /**
   * memoir_series updateMany
   */
  export type memoir_seriesUpdateManyArgs = {
    /**
     * The data used to update memoir_series.
     * 
    **/
    data: XOR<memoir_seriesUpdateManyMutationInput, memoir_seriesUncheckedUpdateManyInput>
    /**
     * Filter which memoir_series to update
     * 
    **/
    where?: memoir_seriesWhereInput
  }


  /**
   * memoir_series upsert
   */
  export type memoir_seriesUpsertArgs = {
    /**
     * Select specific fields to fetch from the memoir_series
     * 
    **/
    select?: memoir_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: memoir_seriesInclude | null
    /**
     * The filter to search for the memoir_series to update in case it exists.
     * 
    **/
    where: memoir_seriesWhereUniqueInput
    /**
     * In case the memoir_series found by the `where` argument doesn't exist, create a new memoir_series with this data.
     * 
    **/
    create: XOR<memoir_seriesCreateInput, memoir_seriesUncheckedCreateInput>
    /**
     * In case the memoir_series was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<memoir_seriesUpdateInput, memoir_seriesUncheckedUpdateInput>
  }


  /**
   * memoir_series delete
   */
  export type memoir_seriesDeleteArgs = {
    /**
     * Select specific fields to fetch from the memoir_series
     * 
    **/
    select?: memoir_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: memoir_seriesInclude | null
    /**
     * Filter which memoir_series to delete.
     * 
    **/
    where: memoir_seriesWhereUniqueInput
  }


  /**
   * memoir_series deleteMany
   */
  export type memoir_seriesDeleteManyArgs = {
    /**
     * Filter which memoir_series to delete
     * 
    **/
    where?: memoir_seriesWhereInput
  }


  /**
   * memoir_series without action
   */
  export type memoir_seriesArgs = {
    /**
     * Select specific fields to fetch from the memoir_series
     * 
    **/
    select?: memoir_seriesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: memoir_seriesInclude | null
  }



  /**
   * Model weapon
   */


  export type AggregateWeapon = {
    _count: WeaponCountAggregateOutputType | null
    _avg: WeaponAvgAggregateOutputType | null
    _sum: WeaponSumAggregateOutputType | null
    _min: WeaponMinAggregateOutputType | null
    _max: WeaponMaxAggregateOutputType | null
  }

  export type WeaponAvgAggregateOutputType = {
    weapon_id: number | null
    evolution_group_id: number | null
    evolution_order: number | null
  }

  export type WeaponSumAggregateOutputType = {
    weapon_id: number | null
    evolution_group_id: number | null
    evolution_order: number | null
  }

  export type WeaponMinAggregateOutputType = {
    weapon_id: number | null
    evolution_group_id: number | null
    evolution_order: number | null
    weapon_type: string | null
    rarity: string | null
    attribute: string | null
    is_ex_weapon: boolean | null
    release_time: Date | null
    slug: string | null
    name: string | null
    image_path: string | null
  }

  export type WeaponMaxAggregateOutputType = {
    weapon_id: number | null
    evolution_group_id: number | null
    evolution_order: number | null
    weapon_type: string | null
    rarity: string | null
    attribute: string | null
    is_ex_weapon: boolean | null
    release_time: Date | null
    slug: string | null
    name: string | null
    image_path: string | null
  }

  export type WeaponCountAggregateOutputType = {
    weapon_id: number
    evolution_group_id: number
    evolution_order: number
    weapon_type: number
    rarity: number
    attribute: number
    is_ex_weapon: number
    release_time: number
    slug: number
    name: number
    image_path: number
    _all: number
  }


  export type WeaponAvgAggregateInputType = {
    weapon_id?: true
    evolution_group_id?: true
    evolution_order?: true
  }

  export type WeaponSumAggregateInputType = {
    weapon_id?: true
    evolution_group_id?: true
    evolution_order?: true
  }

  export type WeaponMinAggregateInputType = {
    weapon_id?: true
    evolution_group_id?: true
    evolution_order?: true
    weapon_type?: true
    rarity?: true
    attribute?: true
    is_ex_weapon?: true
    release_time?: true
    slug?: true
    name?: true
    image_path?: true
  }

  export type WeaponMaxAggregateInputType = {
    weapon_id?: true
    evolution_group_id?: true
    evolution_order?: true
    weapon_type?: true
    rarity?: true
    attribute?: true
    is_ex_weapon?: true
    release_time?: true
    slug?: true
    name?: true
    image_path?: true
  }

  export type WeaponCountAggregateInputType = {
    weapon_id?: true
    evolution_group_id?: true
    evolution_order?: true
    weapon_type?: true
    rarity?: true
    attribute?: true
    is_ex_weapon?: true
    release_time?: true
    slug?: true
    name?: true
    image_path?: true
    _all?: true
  }

  export type WeaponAggregateArgs = {
    /**
     * Filter which weapon to aggregate.
     * 
    **/
    where?: weaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapons to fetch.
     * 
    **/
    orderBy?: Enumerable<weaponOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: weaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned weapons
    **/
    _count?: true | WeaponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WeaponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WeaponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WeaponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WeaponMaxAggregateInputType
  }

  export type GetWeaponAggregateType<T extends WeaponAggregateArgs> = {
        [P in keyof T & keyof AggregateWeapon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeapon[P]>
      : GetScalarType<T[P], AggregateWeapon[P]>
  }




  export type WeaponGroupByArgs = {
    where?: weaponWhereInput
    orderBy?: Enumerable<weaponOrderByWithAggregationInput>
    by: Array<WeaponScalarFieldEnum>
    having?: weaponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WeaponCountAggregateInputType | true
    _avg?: WeaponAvgAggregateInputType
    _sum?: WeaponSumAggregateInputType
    _min?: WeaponMinAggregateInputType
    _max?: WeaponMaxAggregateInputType
  }


  export type WeaponGroupByOutputType = {
    weapon_id: number
    evolution_group_id: number
    evolution_order: number
    weapon_type: string | null
    rarity: string | null
    attribute: string | null
    is_ex_weapon: boolean
    release_time: Date | null
    slug: string | null
    name: string | null
    image_path: string | null
    _count: WeaponCountAggregateOutputType | null
    _avg: WeaponAvgAggregateOutputType | null
    _sum: WeaponSumAggregateOutputType | null
    _min: WeaponMinAggregateOutputType | null
    _max: WeaponMaxAggregateOutputType | null
  }

  type GetWeaponGroupByPayload<T extends WeaponGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WeaponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WeaponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WeaponGroupByOutputType[P]>
            : GetScalarType<T[P], WeaponGroupByOutputType[P]>
        }
      >
    >


  export type weaponSelect = {
    weapon_id?: boolean
    evolution_group_id?: boolean
    evolution_order?: boolean
    weapon_type?: boolean
    rarity?: boolean
    attribute?: boolean
    is_ex_weapon?: boolean
    release_time?: boolean
    slug?: boolean
    name?: boolean
    image_path?: boolean
    weapon_ability_link?: boolean | weapon_ability_linkFindManyArgs
    weapon_skill_link?: boolean | weapon_skill_linkFindManyArgs
    weapon_stat?: boolean | weapon_statFindManyArgs
    weapon_story_link?: boolean | weapon_story_linkFindManyArgs
    _count?: boolean | WeaponCountOutputTypeArgs
  }

  export type weaponInclude = {
    weapon_ability_link?: boolean | weapon_ability_linkFindManyArgs
    weapon_skill_link?: boolean | weapon_skill_linkFindManyArgs
    weapon_stat?: boolean | weapon_statFindManyArgs
    weapon_story_link?: boolean | weapon_story_linkFindManyArgs
    _count?: boolean | WeaponCountOutputTypeArgs
  }

  export type weaponGetPayload<
    S extends boolean | null | undefined | weaponArgs,
    U = keyof S
      > = S extends true
        ? weapon
    : S extends undefined
    ? never
    : S extends weaponArgs | weaponFindManyArgs
    ?'include' extends U
    ? weapon  & {
    [P in TrueKeys<S['include']>]:
        P extends 'weapon_ability_link' ? Array < weapon_ability_linkGetPayload<S['include'][P]>>  :
        P extends 'weapon_skill_link' ? Array < weapon_skill_linkGetPayload<S['include'][P]>>  :
        P extends 'weapon_stat' ? Array < weapon_statGetPayload<S['include'][P]>>  :
        P extends 'weapon_story_link' ? Array < weapon_story_linkGetPayload<S['include'][P]>>  :
        P extends '_count' ? WeaponCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'weapon_ability_link' ? Array < weapon_ability_linkGetPayload<S['select'][P]>>  :
        P extends 'weapon_skill_link' ? Array < weapon_skill_linkGetPayload<S['select'][P]>>  :
        P extends 'weapon_stat' ? Array < weapon_statGetPayload<S['select'][P]>>  :
        P extends 'weapon_story_link' ? Array < weapon_story_linkGetPayload<S['select'][P]>>  :
        P extends '_count' ? WeaponCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof weapon ? weapon[P] : never
  } 
    : weapon
  : weapon


  type weaponCountArgs = Merge<
    Omit<weaponFindManyArgs, 'select' | 'include'> & {
      select?: WeaponCountAggregateInputType | true
    }
  >

  export interface weaponDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Weapon that matches the filter.
     * @param {weaponFindUniqueArgs} args - Arguments to find a Weapon
     * @example
     * // Get one Weapon
     * const weapon = await prisma.weapon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends weaponFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, weaponFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'weapon'> extends True ? CheckSelect<T, Prisma__weaponClient<weapon>, Prisma__weaponClient<weaponGetPayload<T>>> : CheckSelect<T, Prisma__weaponClient<weapon | null >, Prisma__weaponClient<weaponGetPayload<T> | null >>

    /**
     * Find the first Weapon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weaponFindFirstArgs} args - Arguments to find a Weapon
     * @example
     * // Get one Weapon
     * const weapon = await prisma.weapon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends weaponFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, weaponFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'weapon'> extends True ? CheckSelect<T, Prisma__weaponClient<weapon>, Prisma__weaponClient<weaponGetPayload<T>>> : CheckSelect<T, Prisma__weaponClient<weapon | null >, Prisma__weaponClient<weaponGetPayload<T> | null >>

    /**
     * Find zero or more Weapons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weaponFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weapons
     * const weapons = await prisma.weapon.findMany()
     * 
     * // Get first 10 Weapons
     * const weapons = await prisma.weapon.findMany({ take: 10 })
     * 
     * // Only select the `weapon_id`
     * const weaponWithWeapon_idOnly = await prisma.weapon.findMany({ select: { weapon_id: true } })
     * 
    **/
    findMany<T extends weaponFindManyArgs>(
      args?: SelectSubset<T, weaponFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<weapon>>, PrismaPromise<Array<weaponGetPayload<T>>>>

    /**
     * Create a Weapon.
     * @param {weaponCreateArgs} args - Arguments to create a Weapon.
     * @example
     * // Create one Weapon
     * const Weapon = await prisma.weapon.create({
     *   data: {
     *     // ... data to create a Weapon
     *   }
     * })
     * 
    **/
    create<T extends weaponCreateArgs>(
      args: SelectSubset<T, weaponCreateArgs>
    ): CheckSelect<T, Prisma__weaponClient<weapon>, Prisma__weaponClient<weaponGetPayload<T>>>

    /**
     * Create many Weapons.
     *     @param {weaponCreateManyArgs} args - Arguments to create many Weapons.
     *     @example
     *     // Create many Weapons
     *     const weapon = await prisma.weapon.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends weaponCreateManyArgs>(
      args?: SelectSubset<T, weaponCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Weapon.
     * @param {weaponDeleteArgs} args - Arguments to delete one Weapon.
     * @example
     * // Delete one Weapon
     * const Weapon = await prisma.weapon.delete({
     *   where: {
     *     // ... filter to delete one Weapon
     *   }
     * })
     * 
    **/
    delete<T extends weaponDeleteArgs>(
      args: SelectSubset<T, weaponDeleteArgs>
    ): CheckSelect<T, Prisma__weaponClient<weapon>, Prisma__weaponClient<weaponGetPayload<T>>>

    /**
     * Update one Weapon.
     * @param {weaponUpdateArgs} args - Arguments to update one Weapon.
     * @example
     * // Update one Weapon
     * const weapon = await prisma.weapon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends weaponUpdateArgs>(
      args: SelectSubset<T, weaponUpdateArgs>
    ): CheckSelect<T, Prisma__weaponClient<weapon>, Prisma__weaponClient<weaponGetPayload<T>>>

    /**
     * Delete zero or more Weapons.
     * @param {weaponDeleteManyArgs} args - Arguments to filter Weapons to delete.
     * @example
     * // Delete a few Weapons
     * const { count } = await prisma.weapon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends weaponDeleteManyArgs>(
      args?: SelectSubset<T, weaponDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weapons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weaponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weapons
     * const weapon = await prisma.weapon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends weaponUpdateManyArgs>(
      args: SelectSubset<T, weaponUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Weapon.
     * @param {weaponUpsertArgs} args - Arguments to update or create a Weapon.
     * @example
     * // Update or create a Weapon
     * const weapon = await prisma.weapon.upsert({
     *   create: {
     *     // ... data to create a Weapon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weapon we want to update
     *   }
     * })
    **/
    upsert<T extends weaponUpsertArgs>(
      args: SelectSubset<T, weaponUpsertArgs>
    ): CheckSelect<T, Prisma__weaponClient<weapon>, Prisma__weaponClient<weaponGetPayload<T>>>

    /**
     * Count the number of Weapons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weaponCountArgs} args - Arguments to filter Weapons to count.
     * @example
     * // Count the number of Weapons
     * const count = await prisma.weapon.count({
     *   where: {
     *     // ... the filter for the Weapons we want to count
     *   }
     * })
    **/
    count<T extends weaponCountArgs>(
      args?: Subset<T, weaponCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WeaponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weapon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WeaponAggregateArgs>(args: Subset<T, WeaponAggregateArgs>): PrismaPromise<GetWeaponAggregateType<T>>

    /**
     * Group by Weapon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WeaponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WeaponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WeaponGroupByArgs['orderBy'] }
        : { orderBy?: WeaponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WeaponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeaponGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for weapon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__weaponClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    weapon_ability_link<T extends weapon_ability_linkFindManyArgs = {}>(args?: Subset<T, weapon_ability_linkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<weapon_ability_link>>, PrismaPromise<Array<weapon_ability_linkGetPayload<T>>>>;

    weapon_skill_link<T extends weapon_skill_linkFindManyArgs = {}>(args?: Subset<T, weapon_skill_linkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<weapon_skill_link>>, PrismaPromise<Array<weapon_skill_linkGetPayload<T>>>>;

    weapon_stat<T extends weapon_statFindManyArgs = {}>(args?: Subset<T, weapon_statFindManyArgs>): CheckSelect<T, PrismaPromise<Array<weapon_stat>>, PrismaPromise<Array<weapon_statGetPayload<T>>>>;

    weapon_story_link<T extends weapon_story_linkFindManyArgs = {}>(args?: Subset<T, weapon_story_linkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<weapon_story_link>>, PrismaPromise<Array<weapon_story_linkGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * weapon findUnique
   */
  export type weaponFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the weapon
     * 
    **/
    select?: weaponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weaponInclude | null
    /**
     * Throw an Error if a weapon can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weapon to fetch.
     * 
    **/
    where: weaponWhereUniqueInput
  }


  /**
   * weapon findFirst
   */
  export type weaponFindFirstArgs = {
    /**
     * Select specific fields to fetch from the weapon
     * 
    **/
    select?: weaponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weaponInclude | null
    /**
     * Throw an Error if a weapon can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weapon to fetch.
     * 
    **/
    where?: weaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapons to fetch.
     * 
    **/
    orderBy?: Enumerable<weaponOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for weapons.
     * 
    **/
    cursor?: weaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of weapons.
     * 
    **/
    distinct?: Enumerable<WeaponScalarFieldEnum>
  }


  /**
   * weapon findMany
   */
  export type weaponFindManyArgs = {
    /**
     * Select specific fields to fetch from the weapon
     * 
    **/
    select?: weaponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weaponInclude | null
    /**
     * Filter, which weapons to fetch.
     * 
    **/
    where?: weaponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapons to fetch.
     * 
    **/
    orderBy?: Enumerable<weaponOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing weapons.
     * 
    **/
    cursor?: weaponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapons.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WeaponScalarFieldEnum>
  }


  /**
   * weapon create
   */
  export type weaponCreateArgs = {
    /**
     * Select specific fields to fetch from the weapon
     * 
    **/
    select?: weaponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weaponInclude | null
    /**
     * The data needed to create a weapon.
     * 
    **/
    data: XOR<weaponCreateInput, weaponUncheckedCreateInput>
  }


  /**
   * weapon createMany
   */
  export type weaponCreateManyArgs = {
    /**
     * The data used to create many weapons.
     * 
    **/
    data: Enumerable<weaponCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * weapon update
   */
  export type weaponUpdateArgs = {
    /**
     * Select specific fields to fetch from the weapon
     * 
    **/
    select?: weaponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weaponInclude | null
    /**
     * The data needed to update a weapon.
     * 
    **/
    data: XOR<weaponUpdateInput, weaponUncheckedUpdateInput>
    /**
     * Choose, which weapon to update.
     * 
    **/
    where: weaponWhereUniqueInput
  }


  /**
   * weapon updateMany
   */
  export type weaponUpdateManyArgs = {
    /**
     * The data used to update weapons.
     * 
    **/
    data: XOR<weaponUpdateManyMutationInput, weaponUncheckedUpdateManyInput>
    /**
     * Filter which weapons to update
     * 
    **/
    where?: weaponWhereInput
  }


  /**
   * weapon upsert
   */
  export type weaponUpsertArgs = {
    /**
     * Select specific fields to fetch from the weapon
     * 
    **/
    select?: weaponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weaponInclude | null
    /**
     * The filter to search for the weapon to update in case it exists.
     * 
    **/
    where: weaponWhereUniqueInput
    /**
     * In case the weapon found by the `where` argument doesn't exist, create a new weapon with this data.
     * 
    **/
    create: XOR<weaponCreateInput, weaponUncheckedCreateInput>
    /**
     * In case the weapon was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<weaponUpdateInput, weaponUncheckedUpdateInput>
  }


  /**
   * weapon delete
   */
  export type weaponDeleteArgs = {
    /**
     * Select specific fields to fetch from the weapon
     * 
    **/
    select?: weaponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weaponInclude | null
    /**
     * Filter which weapon to delete.
     * 
    **/
    where: weaponWhereUniqueInput
  }


  /**
   * weapon deleteMany
   */
  export type weaponDeleteManyArgs = {
    /**
     * Filter which weapons to delete
     * 
    **/
    where?: weaponWhereInput
  }


  /**
   * weapon without action
   */
  export type weaponArgs = {
    /**
     * Select specific fields to fetch from the weapon
     * 
    **/
    select?: weaponSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weaponInclude | null
  }



  /**
   * Model weapon_ability
   */


  export type AggregateWeapon_ability = {
    _count: Weapon_abilityCountAggregateOutputType | null
    _avg: Weapon_abilityAvgAggregateOutputType | null
    _sum: Weapon_abilitySumAggregateOutputType | null
    _min: Weapon_abilityMinAggregateOutputType | null
    _max: Weapon_abilityMaxAggregateOutputType | null
  }

  export type Weapon_abilityAvgAggregateOutputType = {
    ability_id: number | null
    ability_level: number | null
  }

  export type Weapon_abilitySumAggregateOutputType = {
    ability_id: number | null
    ability_level: number | null
  }

  export type Weapon_abilityMinAggregateOutputType = {
    ability_id: number | null
    ability_level: number | null
    name: string | null
    description: string | null
    image_path_base: string | null
  }

  export type Weapon_abilityMaxAggregateOutputType = {
    ability_id: number | null
    ability_level: number | null
    name: string | null
    description: string | null
    image_path_base: string | null
  }

  export type Weapon_abilityCountAggregateOutputType = {
    ability_id: number
    ability_level: number
    name: number
    description: number
    image_path_base: number
    _all: number
  }


  export type Weapon_abilityAvgAggregateInputType = {
    ability_id?: true
    ability_level?: true
  }

  export type Weapon_abilitySumAggregateInputType = {
    ability_id?: true
    ability_level?: true
  }

  export type Weapon_abilityMinAggregateInputType = {
    ability_id?: true
    ability_level?: true
    name?: true
    description?: true
    image_path_base?: true
  }

  export type Weapon_abilityMaxAggregateInputType = {
    ability_id?: true
    ability_level?: true
    name?: true
    description?: true
    image_path_base?: true
  }

  export type Weapon_abilityCountAggregateInputType = {
    ability_id?: true
    ability_level?: true
    name?: true
    description?: true
    image_path_base?: true
    _all?: true
  }

  export type Weapon_abilityAggregateArgs = {
    /**
     * Filter which weapon_ability to aggregate.
     * 
    **/
    where?: weapon_abilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_abilities to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_abilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: weapon_abilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_abilities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_abilities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned weapon_abilities
    **/
    _count?: true | Weapon_abilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Weapon_abilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Weapon_abilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Weapon_abilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Weapon_abilityMaxAggregateInputType
  }

  export type GetWeapon_abilityAggregateType<T extends Weapon_abilityAggregateArgs> = {
        [P in keyof T & keyof AggregateWeapon_ability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeapon_ability[P]>
      : GetScalarType<T[P], AggregateWeapon_ability[P]>
  }




  export type Weapon_abilityGroupByArgs = {
    where?: weapon_abilityWhereInput
    orderBy?: Enumerable<weapon_abilityOrderByWithAggregationInput>
    by: Array<Weapon_abilityScalarFieldEnum>
    having?: weapon_abilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Weapon_abilityCountAggregateInputType | true
    _avg?: Weapon_abilityAvgAggregateInputType
    _sum?: Weapon_abilitySumAggregateInputType
    _min?: Weapon_abilityMinAggregateInputType
    _max?: Weapon_abilityMaxAggregateInputType
  }


  export type Weapon_abilityGroupByOutputType = {
    ability_id: number
    ability_level: number
    name: string | null
    description: string | null
    image_path_base: string | null
    _count: Weapon_abilityCountAggregateOutputType | null
    _avg: Weapon_abilityAvgAggregateOutputType | null
    _sum: Weapon_abilitySumAggregateOutputType | null
    _min: Weapon_abilityMinAggregateOutputType | null
    _max: Weapon_abilityMaxAggregateOutputType | null
  }

  type GetWeapon_abilityGroupByPayload<T extends Weapon_abilityGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Weapon_abilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Weapon_abilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Weapon_abilityGroupByOutputType[P]>
            : GetScalarType<T[P], Weapon_abilityGroupByOutputType[P]>
        }
      >
    >


  export type weapon_abilitySelect = {
    ability_id?: boolean
    ability_level?: boolean
    name?: boolean
    description?: boolean
    image_path_base?: boolean
    weapon_ability_link?: boolean | weapon_ability_linkFindManyArgs
    _count?: boolean | Weapon_abilityCountOutputTypeArgs
  }

  export type weapon_abilityInclude = {
    weapon_ability_link?: boolean | weapon_ability_linkFindManyArgs
    _count?: boolean | Weapon_abilityCountOutputTypeArgs
  }

  export type weapon_abilityGetPayload<
    S extends boolean | null | undefined | weapon_abilityArgs,
    U = keyof S
      > = S extends true
        ? weapon_ability
    : S extends undefined
    ? never
    : S extends weapon_abilityArgs | weapon_abilityFindManyArgs
    ?'include' extends U
    ? weapon_ability  & {
    [P in TrueKeys<S['include']>]:
        P extends 'weapon_ability_link' ? Array < weapon_ability_linkGetPayload<S['include'][P]>>  :
        P extends '_count' ? Weapon_abilityCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'weapon_ability_link' ? Array < weapon_ability_linkGetPayload<S['select'][P]>>  :
        P extends '_count' ? Weapon_abilityCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof weapon_ability ? weapon_ability[P] : never
  } 
    : weapon_ability
  : weapon_ability


  type weapon_abilityCountArgs = Merge<
    Omit<weapon_abilityFindManyArgs, 'select' | 'include'> & {
      select?: Weapon_abilityCountAggregateInputType | true
    }
  >

  export interface weapon_abilityDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Weapon_ability that matches the filter.
     * @param {weapon_abilityFindUniqueArgs} args - Arguments to find a Weapon_ability
     * @example
     * // Get one Weapon_ability
     * const weapon_ability = await prisma.weapon_ability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends weapon_abilityFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, weapon_abilityFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'weapon_ability'> extends True ? CheckSelect<T, Prisma__weapon_abilityClient<weapon_ability>, Prisma__weapon_abilityClient<weapon_abilityGetPayload<T>>> : CheckSelect<T, Prisma__weapon_abilityClient<weapon_ability | null >, Prisma__weapon_abilityClient<weapon_abilityGetPayload<T> | null >>

    /**
     * Find the first Weapon_ability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_abilityFindFirstArgs} args - Arguments to find a Weapon_ability
     * @example
     * // Get one Weapon_ability
     * const weapon_ability = await prisma.weapon_ability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends weapon_abilityFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, weapon_abilityFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'weapon_ability'> extends True ? CheckSelect<T, Prisma__weapon_abilityClient<weapon_ability>, Prisma__weapon_abilityClient<weapon_abilityGetPayload<T>>> : CheckSelect<T, Prisma__weapon_abilityClient<weapon_ability | null >, Prisma__weapon_abilityClient<weapon_abilityGetPayload<T> | null >>

    /**
     * Find zero or more Weapon_abilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_abilityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weapon_abilities
     * const weapon_abilities = await prisma.weapon_ability.findMany()
     * 
     * // Get first 10 Weapon_abilities
     * const weapon_abilities = await prisma.weapon_ability.findMany({ take: 10 })
     * 
     * // Only select the `ability_id`
     * const weapon_abilityWithAbility_idOnly = await prisma.weapon_ability.findMany({ select: { ability_id: true } })
     * 
    **/
    findMany<T extends weapon_abilityFindManyArgs>(
      args?: SelectSubset<T, weapon_abilityFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<weapon_ability>>, PrismaPromise<Array<weapon_abilityGetPayload<T>>>>

    /**
     * Create a Weapon_ability.
     * @param {weapon_abilityCreateArgs} args - Arguments to create a Weapon_ability.
     * @example
     * // Create one Weapon_ability
     * const Weapon_ability = await prisma.weapon_ability.create({
     *   data: {
     *     // ... data to create a Weapon_ability
     *   }
     * })
     * 
    **/
    create<T extends weapon_abilityCreateArgs>(
      args: SelectSubset<T, weapon_abilityCreateArgs>
    ): CheckSelect<T, Prisma__weapon_abilityClient<weapon_ability>, Prisma__weapon_abilityClient<weapon_abilityGetPayload<T>>>

    /**
     * Create many Weapon_abilities.
     *     @param {weapon_abilityCreateManyArgs} args - Arguments to create many Weapon_abilities.
     *     @example
     *     // Create many Weapon_abilities
     *     const weapon_ability = await prisma.weapon_ability.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends weapon_abilityCreateManyArgs>(
      args?: SelectSubset<T, weapon_abilityCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Weapon_ability.
     * @param {weapon_abilityDeleteArgs} args - Arguments to delete one Weapon_ability.
     * @example
     * // Delete one Weapon_ability
     * const Weapon_ability = await prisma.weapon_ability.delete({
     *   where: {
     *     // ... filter to delete one Weapon_ability
     *   }
     * })
     * 
    **/
    delete<T extends weapon_abilityDeleteArgs>(
      args: SelectSubset<T, weapon_abilityDeleteArgs>
    ): CheckSelect<T, Prisma__weapon_abilityClient<weapon_ability>, Prisma__weapon_abilityClient<weapon_abilityGetPayload<T>>>

    /**
     * Update one Weapon_ability.
     * @param {weapon_abilityUpdateArgs} args - Arguments to update one Weapon_ability.
     * @example
     * // Update one Weapon_ability
     * const weapon_ability = await prisma.weapon_ability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends weapon_abilityUpdateArgs>(
      args: SelectSubset<T, weapon_abilityUpdateArgs>
    ): CheckSelect<T, Prisma__weapon_abilityClient<weapon_ability>, Prisma__weapon_abilityClient<weapon_abilityGetPayload<T>>>

    /**
     * Delete zero or more Weapon_abilities.
     * @param {weapon_abilityDeleteManyArgs} args - Arguments to filter Weapon_abilities to delete.
     * @example
     * // Delete a few Weapon_abilities
     * const { count } = await prisma.weapon_ability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends weapon_abilityDeleteManyArgs>(
      args?: SelectSubset<T, weapon_abilityDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weapon_abilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_abilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weapon_abilities
     * const weapon_ability = await prisma.weapon_ability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends weapon_abilityUpdateManyArgs>(
      args: SelectSubset<T, weapon_abilityUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Weapon_ability.
     * @param {weapon_abilityUpsertArgs} args - Arguments to update or create a Weapon_ability.
     * @example
     * // Update or create a Weapon_ability
     * const weapon_ability = await prisma.weapon_ability.upsert({
     *   create: {
     *     // ... data to create a Weapon_ability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weapon_ability we want to update
     *   }
     * })
    **/
    upsert<T extends weapon_abilityUpsertArgs>(
      args: SelectSubset<T, weapon_abilityUpsertArgs>
    ): CheckSelect<T, Prisma__weapon_abilityClient<weapon_ability>, Prisma__weapon_abilityClient<weapon_abilityGetPayload<T>>>

    /**
     * Count the number of Weapon_abilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_abilityCountArgs} args - Arguments to filter Weapon_abilities to count.
     * @example
     * // Count the number of Weapon_abilities
     * const count = await prisma.weapon_ability.count({
     *   where: {
     *     // ... the filter for the Weapon_abilities we want to count
     *   }
     * })
    **/
    count<T extends weapon_abilityCountArgs>(
      args?: Subset<T, weapon_abilityCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Weapon_abilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weapon_ability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Weapon_abilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Weapon_abilityAggregateArgs>(args: Subset<T, Weapon_abilityAggregateArgs>): PrismaPromise<GetWeapon_abilityAggregateType<T>>

    /**
     * Group by Weapon_ability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Weapon_abilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Weapon_abilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Weapon_abilityGroupByArgs['orderBy'] }
        : { orderBy?: Weapon_abilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Weapon_abilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeapon_abilityGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for weapon_ability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__weapon_abilityClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    weapon_ability_link<T extends weapon_ability_linkFindManyArgs = {}>(args?: Subset<T, weapon_ability_linkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<weapon_ability_link>>, PrismaPromise<Array<weapon_ability_linkGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * weapon_ability findUnique
   */
  export type weapon_abilityFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the weapon_ability
     * 
    **/
    select?: weapon_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_abilityInclude | null
    /**
     * Throw an Error if a weapon_ability can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weapon_ability to fetch.
     * 
    **/
    where: weapon_abilityWhereUniqueInput
  }


  /**
   * weapon_ability findFirst
   */
  export type weapon_abilityFindFirstArgs = {
    /**
     * Select specific fields to fetch from the weapon_ability
     * 
    **/
    select?: weapon_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_abilityInclude | null
    /**
     * Throw an Error if a weapon_ability can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weapon_ability to fetch.
     * 
    **/
    where?: weapon_abilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_abilities to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_abilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for weapon_abilities.
     * 
    **/
    cursor?: weapon_abilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_abilities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_abilities.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of weapon_abilities.
     * 
    **/
    distinct?: Enumerable<Weapon_abilityScalarFieldEnum>
  }


  /**
   * weapon_ability findMany
   */
  export type weapon_abilityFindManyArgs = {
    /**
     * Select specific fields to fetch from the weapon_ability
     * 
    **/
    select?: weapon_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_abilityInclude | null
    /**
     * Filter, which weapon_abilities to fetch.
     * 
    **/
    where?: weapon_abilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_abilities to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_abilityOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing weapon_abilities.
     * 
    **/
    cursor?: weapon_abilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_abilities from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_abilities.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Weapon_abilityScalarFieldEnum>
  }


  /**
   * weapon_ability create
   */
  export type weapon_abilityCreateArgs = {
    /**
     * Select specific fields to fetch from the weapon_ability
     * 
    **/
    select?: weapon_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_abilityInclude | null
    /**
     * The data needed to create a weapon_ability.
     * 
    **/
    data: XOR<weapon_abilityCreateInput, weapon_abilityUncheckedCreateInput>
  }


  /**
   * weapon_ability createMany
   */
  export type weapon_abilityCreateManyArgs = {
    /**
     * The data used to create many weapon_abilities.
     * 
    **/
    data: Enumerable<weapon_abilityCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * weapon_ability update
   */
  export type weapon_abilityUpdateArgs = {
    /**
     * Select specific fields to fetch from the weapon_ability
     * 
    **/
    select?: weapon_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_abilityInclude | null
    /**
     * The data needed to update a weapon_ability.
     * 
    **/
    data: XOR<weapon_abilityUpdateInput, weapon_abilityUncheckedUpdateInput>
    /**
     * Choose, which weapon_ability to update.
     * 
    **/
    where: weapon_abilityWhereUniqueInput
  }


  /**
   * weapon_ability updateMany
   */
  export type weapon_abilityUpdateManyArgs = {
    /**
     * The data used to update weapon_abilities.
     * 
    **/
    data: XOR<weapon_abilityUpdateManyMutationInput, weapon_abilityUncheckedUpdateManyInput>
    /**
     * Filter which weapon_abilities to update
     * 
    **/
    where?: weapon_abilityWhereInput
  }


  /**
   * weapon_ability upsert
   */
  export type weapon_abilityUpsertArgs = {
    /**
     * Select specific fields to fetch from the weapon_ability
     * 
    **/
    select?: weapon_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_abilityInclude | null
    /**
     * The filter to search for the weapon_ability to update in case it exists.
     * 
    **/
    where: weapon_abilityWhereUniqueInput
    /**
     * In case the weapon_ability found by the `where` argument doesn't exist, create a new weapon_ability with this data.
     * 
    **/
    create: XOR<weapon_abilityCreateInput, weapon_abilityUncheckedCreateInput>
    /**
     * In case the weapon_ability was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<weapon_abilityUpdateInput, weapon_abilityUncheckedUpdateInput>
  }


  /**
   * weapon_ability delete
   */
  export type weapon_abilityDeleteArgs = {
    /**
     * Select specific fields to fetch from the weapon_ability
     * 
    **/
    select?: weapon_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_abilityInclude | null
    /**
     * Filter which weapon_ability to delete.
     * 
    **/
    where: weapon_abilityWhereUniqueInput
  }


  /**
   * weapon_ability deleteMany
   */
  export type weapon_abilityDeleteManyArgs = {
    /**
     * Filter which weapon_abilities to delete
     * 
    **/
    where?: weapon_abilityWhereInput
  }


  /**
   * weapon_ability without action
   */
  export type weapon_abilityArgs = {
    /**
     * Select specific fields to fetch from the weapon_ability
     * 
    **/
    select?: weapon_abilitySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_abilityInclude | null
  }



  /**
   * Model weapon_ability_link
   */


  export type AggregateWeapon_ability_link = {
    _count: Weapon_ability_linkCountAggregateOutputType | null
    _avg: Weapon_ability_linkAvgAggregateOutputType | null
    _sum: Weapon_ability_linkSumAggregateOutputType | null
    _min: Weapon_ability_linkMinAggregateOutputType | null
    _max: Weapon_ability_linkMaxAggregateOutputType | null
  }

  export type Weapon_ability_linkAvgAggregateOutputType = {
    weapon_id: number | null
    slot_number: number | null
    ability_id: number | null
    ability_level: number | null
  }

  export type Weapon_ability_linkSumAggregateOutputType = {
    weapon_id: number | null
    slot_number: number | null
    ability_id: number | null
    ability_level: number | null
  }

  export type Weapon_ability_linkMinAggregateOutputType = {
    weapon_id: number | null
    slot_number: number | null
    ability_id: number | null
    ability_level: number | null
  }

  export type Weapon_ability_linkMaxAggregateOutputType = {
    weapon_id: number | null
    slot_number: number | null
    ability_id: number | null
    ability_level: number | null
  }

  export type Weapon_ability_linkCountAggregateOutputType = {
    weapon_id: number
    slot_number: number
    ability_id: number
    ability_level: number
    _all: number
  }


  export type Weapon_ability_linkAvgAggregateInputType = {
    weapon_id?: true
    slot_number?: true
    ability_id?: true
    ability_level?: true
  }

  export type Weapon_ability_linkSumAggregateInputType = {
    weapon_id?: true
    slot_number?: true
    ability_id?: true
    ability_level?: true
  }

  export type Weapon_ability_linkMinAggregateInputType = {
    weapon_id?: true
    slot_number?: true
    ability_id?: true
    ability_level?: true
  }

  export type Weapon_ability_linkMaxAggregateInputType = {
    weapon_id?: true
    slot_number?: true
    ability_id?: true
    ability_level?: true
  }

  export type Weapon_ability_linkCountAggregateInputType = {
    weapon_id?: true
    slot_number?: true
    ability_id?: true
    ability_level?: true
    _all?: true
  }

  export type Weapon_ability_linkAggregateArgs = {
    /**
     * Filter which weapon_ability_link to aggregate.
     * 
    **/
    where?: weapon_ability_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_ability_links to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_ability_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: weapon_ability_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_ability_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_ability_links.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned weapon_ability_links
    **/
    _count?: true | Weapon_ability_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Weapon_ability_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Weapon_ability_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Weapon_ability_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Weapon_ability_linkMaxAggregateInputType
  }

  export type GetWeapon_ability_linkAggregateType<T extends Weapon_ability_linkAggregateArgs> = {
        [P in keyof T & keyof AggregateWeapon_ability_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeapon_ability_link[P]>
      : GetScalarType<T[P], AggregateWeapon_ability_link[P]>
  }




  export type Weapon_ability_linkGroupByArgs = {
    where?: weapon_ability_linkWhereInput
    orderBy?: Enumerable<weapon_ability_linkOrderByWithAggregationInput>
    by: Array<Weapon_ability_linkScalarFieldEnum>
    having?: weapon_ability_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Weapon_ability_linkCountAggregateInputType | true
    _avg?: Weapon_ability_linkAvgAggregateInputType
    _sum?: Weapon_ability_linkSumAggregateInputType
    _min?: Weapon_ability_linkMinAggregateInputType
    _max?: Weapon_ability_linkMaxAggregateInputType
  }


  export type Weapon_ability_linkGroupByOutputType = {
    weapon_id: number
    slot_number: number
    ability_id: number
    ability_level: number
    _count: Weapon_ability_linkCountAggregateOutputType | null
    _avg: Weapon_ability_linkAvgAggregateOutputType | null
    _sum: Weapon_ability_linkSumAggregateOutputType | null
    _min: Weapon_ability_linkMinAggregateOutputType | null
    _max: Weapon_ability_linkMaxAggregateOutputType | null
  }

  type GetWeapon_ability_linkGroupByPayload<T extends Weapon_ability_linkGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Weapon_ability_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Weapon_ability_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Weapon_ability_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Weapon_ability_linkGroupByOutputType[P]>
        }
      >
    >


  export type weapon_ability_linkSelect = {
    weapon_id?: boolean
    slot_number?: boolean
    ability_id?: boolean
    ability_level?: boolean
    weapon_ability?: boolean | weapon_abilityArgs
    weapon?: boolean | weaponArgs
  }

  export type weapon_ability_linkInclude = {
    weapon_ability?: boolean | weapon_abilityArgs
    weapon?: boolean | weaponArgs
  }

  export type weapon_ability_linkGetPayload<
    S extends boolean | null | undefined | weapon_ability_linkArgs,
    U = keyof S
      > = S extends true
        ? weapon_ability_link
    : S extends undefined
    ? never
    : S extends weapon_ability_linkArgs | weapon_ability_linkFindManyArgs
    ?'include' extends U
    ? weapon_ability_link  & {
    [P in TrueKeys<S['include']>]:
        P extends 'weapon_ability' ? weapon_abilityGetPayload<S['include'][P]> :
        P extends 'weapon' ? weaponGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'weapon_ability' ? weapon_abilityGetPayload<S['select'][P]> :
        P extends 'weapon' ? weaponGetPayload<S['select'][P]> :  P extends keyof weapon_ability_link ? weapon_ability_link[P] : never
  } 
    : weapon_ability_link
  : weapon_ability_link


  type weapon_ability_linkCountArgs = Merge<
    Omit<weapon_ability_linkFindManyArgs, 'select' | 'include'> & {
      select?: Weapon_ability_linkCountAggregateInputType | true
    }
  >

  export interface weapon_ability_linkDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Weapon_ability_link that matches the filter.
     * @param {weapon_ability_linkFindUniqueArgs} args - Arguments to find a Weapon_ability_link
     * @example
     * // Get one Weapon_ability_link
     * const weapon_ability_link = await prisma.weapon_ability_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends weapon_ability_linkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, weapon_ability_linkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'weapon_ability_link'> extends True ? CheckSelect<T, Prisma__weapon_ability_linkClient<weapon_ability_link>, Prisma__weapon_ability_linkClient<weapon_ability_linkGetPayload<T>>> : CheckSelect<T, Prisma__weapon_ability_linkClient<weapon_ability_link | null >, Prisma__weapon_ability_linkClient<weapon_ability_linkGetPayload<T> | null >>

    /**
     * Find the first Weapon_ability_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_ability_linkFindFirstArgs} args - Arguments to find a Weapon_ability_link
     * @example
     * // Get one Weapon_ability_link
     * const weapon_ability_link = await prisma.weapon_ability_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends weapon_ability_linkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, weapon_ability_linkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'weapon_ability_link'> extends True ? CheckSelect<T, Prisma__weapon_ability_linkClient<weapon_ability_link>, Prisma__weapon_ability_linkClient<weapon_ability_linkGetPayload<T>>> : CheckSelect<T, Prisma__weapon_ability_linkClient<weapon_ability_link | null >, Prisma__weapon_ability_linkClient<weapon_ability_linkGetPayload<T> | null >>

    /**
     * Find zero or more Weapon_ability_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_ability_linkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weapon_ability_links
     * const weapon_ability_links = await prisma.weapon_ability_link.findMany()
     * 
     * // Get first 10 Weapon_ability_links
     * const weapon_ability_links = await prisma.weapon_ability_link.findMany({ take: 10 })
     * 
     * // Only select the `weapon_id`
     * const weapon_ability_linkWithWeapon_idOnly = await prisma.weapon_ability_link.findMany({ select: { weapon_id: true } })
     * 
    **/
    findMany<T extends weapon_ability_linkFindManyArgs>(
      args?: SelectSubset<T, weapon_ability_linkFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<weapon_ability_link>>, PrismaPromise<Array<weapon_ability_linkGetPayload<T>>>>

    /**
     * Create a Weapon_ability_link.
     * @param {weapon_ability_linkCreateArgs} args - Arguments to create a Weapon_ability_link.
     * @example
     * // Create one Weapon_ability_link
     * const Weapon_ability_link = await prisma.weapon_ability_link.create({
     *   data: {
     *     // ... data to create a Weapon_ability_link
     *   }
     * })
     * 
    **/
    create<T extends weapon_ability_linkCreateArgs>(
      args: SelectSubset<T, weapon_ability_linkCreateArgs>
    ): CheckSelect<T, Prisma__weapon_ability_linkClient<weapon_ability_link>, Prisma__weapon_ability_linkClient<weapon_ability_linkGetPayload<T>>>

    /**
     * Create many Weapon_ability_links.
     *     @param {weapon_ability_linkCreateManyArgs} args - Arguments to create many Weapon_ability_links.
     *     @example
     *     // Create many Weapon_ability_links
     *     const weapon_ability_link = await prisma.weapon_ability_link.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends weapon_ability_linkCreateManyArgs>(
      args?: SelectSubset<T, weapon_ability_linkCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Weapon_ability_link.
     * @param {weapon_ability_linkDeleteArgs} args - Arguments to delete one Weapon_ability_link.
     * @example
     * // Delete one Weapon_ability_link
     * const Weapon_ability_link = await prisma.weapon_ability_link.delete({
     *   where: {
     *     // ... filter to delete one Weapon_ability_link
     *   }
     * })
     * 
    **/
    delete<T extends weapon_ability_linkDeleteArgs>(
      args: SelectSubset<T, weapon_ability_linkDeleteArgs>
    ): CheckSelect<T, Prisma__weapon_ability_linkClient<weapon_ability_link>, Prisma__weapon_ability_linkClient<weapon_ability_linkGetPayload<T>>>

    /**
     * Update one Weapon_ability_link.
     * @param {weapon_ability_linkUpdateArgs} args - Arguments to update one Weapon_ability_link.
     * @example
     * // Update one Weapon_ability_link
     * const weapon_ability_link = await prisma.weapon_ability_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends weapon_ability_linkUpdateArgs>(
      args: SelectSubset<T, weapon_ability_linkUpdateArgs>
    ): CheckSelect<T, Prisma__weapon_ability_linkClient<weapon_ability_link>, Prisma__weapon_ability_linkClient<weapon_ability_linkGetPayload<T>>>

    /**
     * Delete zero or more Weapon_ability_links.
     * @param {weapon_ability_linkDeleteManyArgs} args - Arguments to filter Weapon_ability_links to delete.
     * @example
     * // Delete a few Weapon_ability_links
     * const { count } = await prisma.weapon_ability_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends weapon_ability_linkDeleteManyArgs>(
      args?: SelectSubset<T, weapon_ability_linkDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weapon_ability_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_ability_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weapon_ability_links
     * const weapon_ability_link = await prisma.weapon_ability_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends weapon_ability_linkUpdateManyArgs>(
      args: SelectSubset<T, weapon_ability_linkUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Weapon_ability_link.
     * @param {weapon_ability_linkUpsertArgs} args - Arguments to update or create a Weapon_ability_link.
     * @example
     * // Update or create a Weapon_ability_link
     * const weapon_ability_link = await prisma.weapon_ability_link.upsert({
     *   create: {
     *     // ... data to create a Weapon_ability_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weapon_ability_link we want to update
     *   }
     * })
    **/
    upsert<T extends weapon_ability_linkUpsertArgs>(
      args: SelectSubset<T, weapon_ability_linkUpsertArgs>
    ): CheckSelect<T, Prisma__weapon_ability_linkClient<weapon_ability_link>, Prisma__weapon_ability_linkClient<weapon_ability_linkGetPayload<T>>>

    /**
     * Count the number of Weapon_ability_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_ability_linkCountArgs} args - Arguments to filter Weapon_ability_links to count.
     * @example
     * // Count the number of Weapon_ability_links
     * const count = await prisma.weapon_ability_link.count({
     *   where: {
     *     // ... the filter for the Weapon_ability_links we want to count
     *   }
     * })
    **/
    count<T extends weapon_ability_linkCountArgs>(
      args?: Subset<T, weapon_ability_linkCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Weapon_ability_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weapon_ability_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Weapon_ability_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Weapon_ability_linkAggregateArgs>(args: Subset<T, Weapon_ability_linkAggregateArgs>): PrismaPromise<GetWeapon_ability_linkAggregateType<T>>

    /**
     * Group by Weapon_ability_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Weapon_ability_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Weapon_ability_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Weapon_ability_linkGroupByArgs['orderBy'] }
        : { orderBy?: Weapon_ability_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Weapon_ability_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeapon_ability_linkGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for weapon_ability_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__weapon_ability_linkClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    weapon_ability<T extends weapon_abilityArgs = {}>(args?: Subset<T, weapon_abilityArgs>): CheckSelect<T, Prisma__weapon_abilityClient<weapon_ability | null >, Prisma__weapon_abilityClient<weapon_abilityGetPayload<T> | null >>;

    weapon<T extends weaponArgs = {}>(args?: Subset<T, weaponArgs>): CheckSelect<T, Prisma__weaponClient<weapon | null >, Prisma__weaponClient<weaponGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * weapon_ability_link findUnique
   */
  export type weapon_ability_linkFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the weapon_ability_link
     * 
    **/
    select?: weapon_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_ability_linkInclude | null
    /**
     * Throw an Error if a weapon_ability_link can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weapon_ability_link to fetch.
     * 
    **/
    where: weapon_ability_linkWhereUniqueInput
  }


  /**
   * weapon_ability_link findFirst
   */
  export type weapon_ability_linkFindFirstArgs = {
    /**
     * Select specific fields to fetch from the weapon_ability_link
     * 
    **/
    select?: weapon_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_ability_linkInclude | null
    /**
     * Throw an Error if a weapon_ability_link can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weapon_ability_link to fetch.
     * 
    **/
    where?: weapon_ability_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_ability_links to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_ability_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for weapon_ability_links.
     * 
    **/
    cursor?: weapon_ability_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_ability_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_ability_links.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of weapon_ability_links.
     * 
    **/
    distinct?: Enumerable<Weapon_ability_linkScalarFieldEnum>
  }


  /**
   * weapon_ability_link findMany
   */
  export type weapon_ability_linkFindManyArgs = {
    /**
     * Select specific fields to fetch from the weapon_ability_link
     * 
    **/
    select?: weapon_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_ability_linkInclude | null
    /**
     * Filter, which weapon_ability_links to fetch.
     * 
    **/
    where?: weapon_ability_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_ability_links to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_ability_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing weapon_ability_links.
     * 
    **/
    cursor?: weapon_ability_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_ability_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_ability_links.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Weapon_ability_linkScalarFieldEnum>
  }


  /**
   * weapon_ability_link create
   */
  export type weapon_ability_linkCreateArgs = {
    /**
     * Select specific fields to fetch from the weapon_ability_link
     * 
    **/
    select?: weapon_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_ability_linkInclude | null
    /**
     * The data needed to create a weapon_ability_link.
     * 
    **/
    data: XOR<weapon_ability_linkCreateInput, weapon_ability_linkUncheckedCreateInput>
  }


  /**
   * weapon_ability_link createMany
   */
  export type weapon_ability_linkCreateManyArgs = {
    /**
     * The data used to create many weapon_ability_links.
     * 
    **/
    data: Enumerable<weapon_ability_linkCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * weapon_ability_link update
   */
  export type weapon_ability_linkUpdateArgs = {
    /**
     * Select specific fields to fetch from the weapon_ability_link
     * 
    **/
    select?: weapon_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_ability_linkInclude | null
    /**
     * The data needed to update a weapon_ability_link.
     * 
    **/
    data: XOR<weapon_ability_linkUpdateInput, weapon_ability_linkUncheckedUpdateInput>
    /**
     * Choose, which weapon_ability_link to update.
     * 
    **/
    where: weapon_ability_linkWhereUniqueInput
  }


  /**
   * weapon_ability_link updateMany
   */
  export type weapon_ability_linkUpdateManyArgs = {
    /**
     * The data used to update weapon_ability_links.
     * 
    **/
    data: XOR<weapon_ability_linkUpdateManyMutationInput, weapon_ability_linkUncheckedUpdateManyInput>
    /**
     * Filter which weapon_ability_links to update
     * 
    **/
    where?: weapon_ability_linkWhereInput
  }


  /**
   * weapon_ability_link upsert
   */
  export type weapon_ability_linkUpsertArgs = {
    /**
     * Select specific fields to fetch from the weapon_ability_link
     * 
    **/
    select?: weapon_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_ability_linkInclude | null
    /**
     * The filter to search for the weapon_ability_link to update in case it exists.
     * 
    **/
    where: weapon_ability_linkWhereUniqueInput
    /**
     * In case the weapon_ability_link found by the `where` argument doesn't exist, create a new weapon_ability_link with this data.
     * 
    **/
    create: XOR<weapon_ability_linkCreateInput, weapon_ability_linkUncheckedCreateInput>
    /**
     * In case the weapon_ability_link was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<weapon_ability_linkUpdateInput, weapon_ability_linkUncheckedUpdateInput>
  }


  /**
   * weapon_ability_link delete
   */
  export type weapon_ability_linkDeleteArgs = {
    /**
     * Select specific fields to fetch from the weapon_ability_link
     * 
    **/
    select?: weapon_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_ability_linkInclude | null
    /**
     * Filter which weapon_ability_link to delete.
     * 
    **/
    where: weapon_ability_linkWhereUniqueInput
  }


  /**
   * weapon_ability_link deleteMany
   */
  export type weapon_ability_linkDeleteManyArgs = {
    /**
     * Filter which weapon_ability_links to delete
     * 
    **/
    where?: weapon_ability_linkWhereInput
  }


  /**
   * weapon_ability_link without action
   */
  export type weapon_ability_linkArgs = {
    /**
     * Select specific fields to fetch from the weapon_ability_link
     * 
    **/
    select?: weapon_ability_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_ability_linkInclude | null
  }



  /**
   * Model weapon_skill
   */


  export type AggregateWeapon_skill = {
    _count: Weapon_skillCountAggregateOutputType | null
    _avg: Weapon_skillAvgAggregateOutputType | null
    _sum: Weapon_skillSumAggregateOutputType | null
    _min: Weapon_skillMinAggregateOutputType | null
    _max: Weapon_skillMaxAggregateOutputType | null
  }

  export type Weapon_skillAvgAggregateOutputType = {
    skill_id: number | null
    skill_level: number | null
    cooldown_time: number | null
  }

  export type Weapon_skillSumAggregateOutputType = {
    skill_id: number | null
    skill_level: number | null
    cooldown_time: number | null
  }

  export type Weapon_skillMinAggregateOutputType = {
    skill_id: number | null
    skill_level: number | null
    cooldown_time: number | null
    name: string | null
    description: string | null
    short_description: string | null
    image_path: string | null
  }

  export type Weapon_skillMaxAggregateOutputType = {
    skill_id: number | null
    skill_level: number | null
    cooldown_time: number | null
    name: string | null
    description: string | null
    short_description: string | null
    image_path: string | null
  }

  export type Weapon_skillCountAggregateOutputType = {
    skill_id: number
    skill_level: number
    cooldown_time: number
    name: number
    description: number
    short_description: number
    image_path: number
    _all: number
  }


  export type Weapon_skillAvgAggregateInputType = {
    skill_id?: true
    skill_level?: true
    cooldown_time?: true
  }

  export type Weapon_skillSumAggregateInputType = {
    skill_id?: true
    skill_level?: true
    cooldown_time?: true
  }

  export type Weapon_skillMinAggregateInputType = {
    skill_id?: true
    skill_level?: true
    cooldown_time?: true
    name?: true
    description?: true
    short_description?: true
    image_path?: true
  }

  export type Weapon_skillMaxAggregateInputType = {
    skill_id?: true
    skill_level?: true
    cooldown_time?: true
    name?: true
    description?: true
    short_description?: true
    image_path?: true
  }

  export type Weapon_skillCountAggregateInputType = {
    skill_id?: true
    skill_level?: true
    cooldown_time?: true
    name?: true
    description?: true
    short_description?: true
    image_path?: true
    _all?: true
  }

  export type Weapon_skillAggregateArgs = {
    /**
     * Filter which weapon_skill to aggregate.
     * 
    **/
    where?: weapon_skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_skills to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_skillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: weapon_skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_skills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_skills.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned weapon_skills
    **/
    _count?: true | Weapon_skillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Weapon_skillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Weapon_skillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Weapon_skillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Weapon_skillMaxAggregateInputType
  }

  export type GetWeapon_skillAggregateType<T extends Weapon_skillAggregateArgs> = {
        [P in keyof T & keyof AggregateWeapon_skill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeapon_skill[P]>
      : GetScalarType<T[P], AggregateWeapon_skill[P]>
  }




  export type Weapon_skillGroupByArgs = {
    where?: weapon_skillWhereInput
    orderBy?: Enumerable<weapon_skillOrderByWithAggregationInput>
    by: Array<Weapon_skillScalarFieldEnum>
    having?: weapon_skillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Weapon_skillCountAggregateInputType | true
    _avg?: Weapon_skillAvgAggregateInputType
    _sum?: Weapon_skillSumAggregateInputType
    _min?: Weapon_skillMinAggregateInputType
    _max?: Weapon_skillMaxAggregateInputType
  }


  export type Weapon_skillGroupByOutputType = {
    skill_id: number
    skill_level: number
    cooldown_time: number
    name: string | null
    description: string | null
    short_description: string | null
    image_path: string | null
    _count: Weapon_skillCountAggregateOutputType | null
    _avg: Weapon_skillAvgAggregateOutputType | null
    _sum: Weapon_skillSumAggregateOutputType | null
    _min: Weapon_skillMinAggregateOutputType | null
    _max: Weapon_skillMaxAggregateOutputType | null
  }

  type GetWeapon_skillGroupByPayload<T extends Weapon_skillGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Weapon_skillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Weapon_skillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Weapon_skillGroupByOutputType[P]>
            : GetScalarType<T[P], Weapon_skillGroupByOutputType[P]>
        }
      >
    >


  export type weapon_skillSelect = {
    skill_id?: boolean
    skill_level?: boolean
    cooldown_time?: boolean
    name?: boolean
    description?: boolean
    short_description?: boolean
    image_path?: boolean
    weapon_skill_link?: boolean | weapon_skill_linkFindManyArgs
    _count?: boolean | Weapon_skillCountOutputTypeArgs
  }

  export type weapon_skillInclude = {
    weapon_skill_link?: boolean | weapon_skill_linkFindManyArgs
    _count?: boolean | Weapon_skillCountOutputTypeArgs
  }

  export type weapon_skillGetPayload<
    S extends boolean | null | undefined | weapon_skillArgs,
    U = keyof S
      > = S extends true
        ? weapon_skill
    : S extends undefined
    ? never
    : S extends weapon_skillArgs | weapon_skillFindManyArgs
    ?'include' extends U
    ? weapon_skill  & {
    [P in TrueKeys<S['include']>]:
        P extends 'weapon_skill_link' ? Array < weapon_skill_linkGetPayload<S['include'][P]>>  :
        P extends '_count' ? Weapon_skillCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'weapon_skill_link' ? Array < weapon_skill_linkGetPayload<S['select'][P]>>  :
        P extends '_count' ? Weapon_skillCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof weapon_skill ? weapon_skill[P] : never
  } 
    : weapon_skill
  : weapon_skill


  type weapon_skillCountArgs = Merge<
    Omit<weapon_skillFindManyArgs, 'select' | 'include'> & {
      select?: Weapon_skillCountAggregateInputType | true
    }
  >

  export interface weapon_skillDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Weapon_skill that matches the filter.
     * @param {weapon_skillFindUniqueArgs} args - Arguments to find a Weapon_skill
     * @example
     * // Get one Weapon_skill
     * const weapon_skill = await prisma.weapon_skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends weapon_skillFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, weapon_skillFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'weapon_skill'> extends True ? CheckSelect<T, Prisma__weapon_skillClient<weapon_skill>, Prisma__weapon_skillClient<weapon_skillGetPayload<T>>> : CheckSelect<T, Prisma__weapon_skillClient<weapon_skill | null >, Prisma__weapon_skillClient<weapon_skillGetPayload<T> | null >>

    /**
     * Find the first Weapon_skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_skillFindFirstArgs} args - Arguments to find a Weapon_skill
     * @example
     * // Get one Weapon_skill
     * const weapon_skill = await prisma.weapon_skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends weapon_skillFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, weapon_skillFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'weapon_skill'> extends True ? CheckSelect<T, Prisma__weapon_skillClient<weapon_skill>, Prisma__weapon_skillClient<weapon_skillGetPayload<T>>> : CheckSelect<T, Prisma__weapon_skillClient<weapon_skill | null >, Prisma__weapon_skillClient<weapon_skillGetPayload<T> | null >>

    /**
     * Find zero or more Weapon_skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_skillFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weapon_skills
     * const weapon_skills = await prisma.weapon_skill.findMany()
     * 
     * // Get first 10 Weapon_skills
     * const weapon_skills = await prisma.weapon_skill.findMany({ take: 10 })
     * 
     * // Only select the `skill_id`
     * const weapon_skillWithSkill_idOnly = await prisma.weapon_skill.findMany({ select: { skill_id: true } })
     * 
    **/
    findMany<T extends weapon_skillFindManyArgs>(
      args?: SelectSubset<T, weapon_skillFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<weapon_skill>>, PrismaPromise<Array<weapon_skillGetPayload<T>>>>

    /**
     * Create a Weapon_skill.
     * @param {weapon_skillCreateArgs} args - Arguments to create a Weapon_skill.
     * @example
     * // Create one Weapon_skill
     * const Weapon_skill = await prisma.weapon_skill.create({
     *   data: {
     *     // ... data to create a Weapon_skill
     *   }
     * })
     * 
    **/
    create<T extends weapon_skillCreateArgs>(
      args: SelectSubset<T, weapon_skillCreateArgs>
    ): CheckSelect<T, Prisma__weapon_skillClient<weapon_skill>, Prisma__weapon_skillClient<weapon_skillGetPayload<T>>>

    /**
     * Create many Weapon_skills.
     *     @param {weapon_skillCreateManyArgs} args - Arguments to create many Weapon_skills.
     *     @example
     *     // Create many Weapon_skills
     *     const weapon_skill = await prisma.weapon_skill.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends weapon_skillCreateManyArgs>(
      args?: SelectSubset<T, weapon_skillCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Weapon_skill.
     * @param {weapon_skillDeleteArgs} args - Arguments to delete one Weapon_skill.
     * @example
     * // Delete one Weapon_skill
     * const Weapon_skill = await prisma.weapon_skill.delete({
     *   where: {
     *     // ... filter to delete one Weapon_skill
     *   }
     * })
     * 
    **/
    delete<T extends weapon_skillDeleteArgs>(
      args: SelectSubset<T, weapon_skillDeleteArgs>
    ): CheckSelect<T, Prisma__weapon_skillClient<weapon_skill>, Prisma__weapon_skillClient<weapon_skillGetPayload<T>>>

    /**
     * Update one Weapon_skill.
     * @param {weapon_skillUpdateArgs} args - Arguments to update one Weapon_skill.
     * @example
     * // Update one Weapon_skill
     * const weapon_skill = await prisma.weapon_skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends weapon_skillUpdateArgs>(
      args: SelectSubset<T, weapon_skillUpdateArgs>
    ): CheckSelect<T, Prisma__weapon_skillClient<weapon_skill>, Prisma__weapon_skillClient<weapon_skillGetPayload<T>>>

    /**
     * Delete zero or more Weapon_skills.
     * @param {weapon_skillDeleteManyArgs} args - Arguments to filter Weapon_skills to delete.
     * @example
     * // Delete a few Weapon_skills
     * const { count } = await prisma.weapon_skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends weapon_skillDeleteManyArgs>(
      args?: SelectSubset<T, weapon_skillDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weapon_skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_skillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weapon_skills
     * const weapon_skill = await prisma.weapon_skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends weapon_skillUpdateManyArgs>(
      args: SelectSubset<T, weapon_skillUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Weapon_skill.
     * @param {weapon_skillUpsertArgs} args - Arguments to update or create a Weapon_skill.
     * @example
     * // Update or create a Weapon_skill
     * const weapon_skill = await prisma.weapon_skill.upsert({
     *   create: {
     *     // ... data to create a Weapon_skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weapon_skill we want to update
     *   }
     * })
    **/
    upsert<T extends weapon_skillUpsertArgs>(
      args: SelectSubset<T, weapon_skillUpsertArgs>
    ): CheckSelect<T, Prisma__weapon_skillClient<weapon_skill>, Prisma__weapon_skillClient<weapon_skillGetPayload<T>>>

    /**
     * Count the number of Weapon_skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_skillCountArgs} args - Arguments to filter Weapon_skills to count.
     * @example
     * // Count the number of Weapon_skills
     * const count = await prisma.weapon_skill.count({
     *   where: {
     *     // ... the filter for the Weapon_skills we want to count
     *   }
     * })
    **/
    count<T extends weapon_skillCountArgs>(
      args?: Subset<T, weapon_skillCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Weapon_skillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weapon_skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Weapon_skillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Weapon_skillAggregateArgs>(args: Subset<T, Weapon_skillAggregateArgs>): PrismaPromise<GetWeapon_skillAggregateType<T>>

    /**
     * Group by Weapon_skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Weapon_skillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Weapon_skillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Weapon_skillGroupByArgs['orderBy'] }
        : { orderBy?: Weapon_skillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Weapon_skillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeapon_skillGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for weapon_skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__weapon_skillClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    weapon_skill_link<T extends weapon_skill_linkFindManyArgs = {}>(args?: Subset<T, weapon_skill_linkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<weapon_skill_link>>, PrismaPromise<Array<weapon_skill_linkGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * weapon_skill findUnique
   */
  export type weapon_skillFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the weapon_skill
     * 
    **/
    select?: weapon_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_skillInclude | null
    /**
     * Throw an Error if a weapon_skill can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weapon_skill to fetch.
     * 
    **/
    where: weapon_skillWhereUniqueInput
  }


  /**
   * weapon_skill findFirst
   */
  export type weapon_skillFindFirstArgs = {
    /**
     * Select specific fields to fetch from the weapon_skill
     * 
    **/
    select?: weapon_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_skillInclude | null
    /**
     * Throw an Error if a weapon_skill can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weapon_skill to fetch.
     * 
    **/
    where?: weapon_skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_skills to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_skillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for weapon_skills.
     * 
    **/
    cursor?: weapon_skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_skills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_skills.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of weapon_skills.
     * 
    **/
    distinct?: Enumerable<Weapon_skillScalarFieldEnum>
  }


  /**
   * weapon_skill findMany
   */
  export type weapon_skillFindManyArgs = {
    /**
     * Select specific fields to fetch from the weapon_skill
     * 
    **/
    select?: weapon_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_skillInclude | null
    /**
     * Filter, which weapon_skills to fetch.
     * 
    **/
    where?: weapon_skillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_skills to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_skillOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing weapon_skills.
     * 
    **/
    cursor?: weapon_skillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_skills from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_skills.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Weapon_skillScalarFieldEnum>
  }


  /**
   * weapon_skill create
   */
  export type weapon_skillCreateArgs = {
    /**
     * Select specific fields to fetch from the weapon_skill
     * 
    **/
    select?: weapon_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_skillInclude | null
    /**
     * The data needed to create a weapon_skill.
     * 
    **/
    data: XOR<weapon_skillCreateInput, weapon_skillUncheckedCreateInput>
  }


  /**
   * weapon_skill createMany
   */
  export type weapon_skillCreateManyArgs = {
    /**
     * The data used to create many weapon_skills.
     * 
    **/
    data: Enumerable<weapon_skillCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * weapon_skill update
   */
  export type weapon_skillUpdateArgs = {
    /**
     * Select specific fields to fetch from the weapon_skill
     * 
    **/
    select?: weapon_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_skillInclude | null
    /**
     * The data needed to update a weapon_skill.
     * 
    **/
    data: XOR<weapon_skillUpdateInput, weapon_skillUncheckedUpdateInput>
    /**
     * Choose, which weapon_skill to update.
     * 
    **/
    where: weapon_skillWhereUniqueInput
  }


  /**
   * weapon_skill updateMany
   */
  export type weapon_skillUpdateManyArgs = {
    /**
     * The data used to update weapon_skills.
     * 
    **/
    data: XOR<weapon_skillUpdateManyMutationInput, weapon_skillUncheckedUpdateManyInput>
    /**
     * Filter which weapon_skills to update
     * 
    **/
    where?: weapon_skillWhereInput
  }


  /**
   * weapon_skill upsert
   */
  export type weapon_skillUpsertArgs = {
    /**
     * Select specific fields to fetch from the weapon_skill
     * 
    **/
    select?: weapon_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_skillInclude | null
    /**
     * The filter to search for the weapon_skill to update in case it exists.
     * 
    **/
    where: weapon_skillWhereUniqueInput
    /**
     * In case the weapon_skill found by the `where` argument doesn't exist, create a new weapon_skill with this data.
     * 
    **/
    create: XOR<weapon_skillCreateInput, weapon_skillUncheckedCreateInput>
    /**
     * In case the weapon_skill was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<weapon_skillUpdateInput, weapon_skillUncheckedUpdateInput>
  }


  /**
   * weapon_skill delete
   */
  export type weapon_skillDeleteArgs = {
    /**
     * Select specific fields to fetch from the weapon_skill
     * 
    **/
    select?: weapon_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_skillInclude | null
    /**
     * Filter which weapon_skill to delete.
     * 
    **/
    where: weapon_skillWhereUniqueInput
  }


  /**
   * weapon_skill deleteMany
   */
  export type weapon_skillDeleteManyArgs = {
    /**
     * Filter which weapon_skills to delete
     * 
    **/
    where?: weapon_skillWhereInput
  }


  /**
   * weapon_skill without action
   */
  export type weapon_skillArgs = {
    /**
     * Select specific fields to fetch from the weapon_skill
     * 
    **/
    select?: weapon_skillSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_skillInclude | null
  }



  /**
   * Model weapon_skill_link
   */


  export type AggregateWeapon_skill_link = {
    _count: Weapon_skill_linkCountAggregateOutputType | null
    _avg: Weapon_skill_linkAvgAggregateOutputType | null
    _sum: Weapon_skill_linkSumAggregateOutputType | null
    _min: Weapon_skill_linkMinAggregateOutputType | null
    _max: Weapon_skill_linkMaxAggregateOutputType | null
  }

  export type Weapon_skill_linkAvgAggregateOutputType = {
    weapon_id: number | null
    slot_number: number | null
    skill_id: number | null
    skill_level: number | null
  }

  export type Weapon_skill_linkSumAggregateOutputType = {
    weapon_id: number | null
    slot_number: number | null
    skill_id: number | null
    skill_level: number | null
  }

  export type Weapon_skill_linkMinAggregateOutputType = {
    weapon_id: number | null
    slot_number: number | null
    skill_id: number | null
    skill_level: number | null
  }

  export type Weapon_skill_linkMaxAggregateOutputType = {
    weapon_id: number | null
    slot_number: number | null
    skill_id: number | null
    skill_level: number | null
  }

  export type Weapon_skill_linkCountAggregateOutputType = {
    weapon_id: number
    slot_number: number
    skill_id: number
    skill_level: number
    _all: number
  }


  export type Weapon_skill_linkAvgAggregateInputType = {
    weapon_id?: true
    slot_number?: true
    skill_id?: true
    skill_level?: true
  }

  export type Weapon_skill_linkSumAggregateInputType = {
    weapon_id?: true
    slot_number?: true
    skill_id?: true
    skill_level?: true
  }

  export type Weapon_skill_linkMinAggregateInputType = {
    weapon_id?: true
    slot_number?: true
    skill_id?: true
    skill_level?: true
  }

  export type Weapon_skill_linkMaxAggregateInputType = {
    weapon_id?: true
    slot_number?: true
    skill_id?: true
    skill_level?: true
  }

  export type Weapon_skill_linkCountAggregateInputType = {
    weapon_id?: true
    slot_number?: true
    skill_id?: true
    skill_level?: true
    _all?: true
  }

  export type Weapon_skill_linkAggregateArgs = {
    /**
     * Filter which weapon_skill_link to aggregate.
     * 
    **/
    where?: weapon_skill_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_skill_links to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_skill_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: weapon_skill_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_skill_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_skill_links.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned weapon_skill_links
    **/
    _count?: true | Weapon_skill_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Weapon_skill_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Weapon_skill_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Weapon_skill_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Weapon_skill_linkMaxAggregateInputType
  }

  export type GetWeapon_skill_linkAggregateType<T extends Weapon_skill_linkAggregateArgs> = {
        [P in keyof T & keyof AggregateWeapon_skill_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeapon_skill_link[P]>
      : GetScalarType<T[P], AggregateWeapon_skill_link[P]>
  }




  export type Weapon_skill_linkGroupByArgs = {
    where?: weapon_skill_linkWhereInput
    orderBy?: Enumerable<weapon_skill_linkOrderByWithAggregationInput>
    by: Array<Weapon_skill_linkScalarFieldEnum>
    having?: weapon_skill_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Weapon_skill_linkCountAggregateInputType | true
    _avg?: Weapon_skill_linkAvgAggregateInputType
    _sum?: Weapon_skill_linkSumAggregateInputType
    _min?: Weapon_skill_linkMinAggregateInputType
    _max?: Weapon_skill_linkMaxAggregateInputType
  }


  export type Weapon_skill_linkGroupByOutputType = {
    weapon_id: number
    slot_number: number
    skill_id: number
    skill_level: number
    _count: Weapon_skill_linkCountAggregateOutputType | null
    _avg: Weapon_skill_linkAvgAggregateOutputType | null
    _sum: Weapon_skill_linkSumAggregateOutputType | null
    _min: Weapon_skill_linkMinAggregateOutputType | null
    _max: Weapon_skill_linkMaxAggregateOutputType | null
  }

  type GetWeapon_skill_linkGroupByPayload<T extends Weapon_skill_linkGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Weapon_skill_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Weapon_skill_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Weapon_skill_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Weapon_skill_linkGroupByOutputType[P]>
        }
      >
    >


  export type weapon_skill_linkSelect = {
    weapon_id?: boolean
    slot_number?: boolean
    skill_id?: boolean
    skill_level?: boolean
    weapon_skill?: boolean | weapon_skillArgs
    weapon?: boolean | weaponArgs
  }

  export type weapon_skill_linkInclude = {
    weapon_skill?: boolean | weapon_skillArgs
    weapon?: boolean | weaponArgs
  }

  export type weapon_skill_linkGetPayload<
    S extends boolean | null | undefined | weapon_skill_linkArgs,
    U = keyof S
      > = S extends true
        ? weapon_skill_link
    : S extends undefined
    ? never
    : S extends weapon_skill_linkArgs | weapon_skill_linkFindManyArgs
    ?'include' extends U
    ? weapon_skill_link  & {
    [P in TrueKeys<S['include']>]:
        P extends 'weapon_skill' ? weapon_skillGetPayload<S['include'][P]> :
        P extends 'weapon' ? weaponGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'weapon_skill' ? weapon_skillGetPayload<S['select'][P]> :
        P extends 'weapon' ? weaponGetPayload<S['select'][P]> :  P extends keyof weapon_skill_link ? weapon_skill_link[P] : never
  } 
    : weapon_skill_link
  : weapon_skill_link


  type weapon_skill_linkCountArgs = Merge<
    Omit<weapon_skill_linkFindManyArgs, 'select' | 'include'> & {
      select?: Weapon_skill_linkCountAggregateInputType | true
    }
  >

  export interface weapon_skill_linkDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Weapon_skill_link that matches the filter.
     * @param {weapon_skill_linkFindUniqueArgs} args - Arguments to find a Weapon_skill_link
     * @example
     * // Get one Weapon_skill_link
     * const weapon_skill_link = await prisma.weapon_skill_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends weapon_skill_linkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, weapon_skill_linkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'weapon_skill_link'> extends True ? CheckSelect<T, Prisma__weapon_skill_linkClient<weapon_skill_link>, Prisma__weapon_skill_linkClient<weapon_skill_linkGetPayload<T>>> : CheckSelect<T, Prisma__weapon_skill_linkClient<weapon_skill_link | null >, Prisma__weapon_skill_linkClient<weapon_skill_linkGetPayload<T> | null >>

    /**
     * Find the first Weapon_skill_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_skill_linkFindFirstArgs} args - Arguments to find a Weapon_skill_link
     * @example
     * // Get one Weapon_skill_link
     * const weapon_skill_link = await prisma.weapon_skill_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends weapon_skill_linkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, weapon_skill_linkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'weapon_skill_link'> extends True ? CheckSelect<T, Prisma__weapon_skill_linkClient<weapon_skill_link>, Prisma__weapon_skill_linkClient<weapon_skill_linkGetPayload<T>>> : CheckSelect<T, Prisma__weapon_skill_linkClient<weapon_skill_link | null >, Prisma__weapon_skill_linkClient<weapon_skill_linkGetPayload<T> | null >>

    /**
     * Find zero or more Weapon_skill_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_skill_linkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weapon_skill_links
     * const weapon_skill_links = await prisma.weapon_skill_link.findMany()
     * 
     * // Get first 10 Weapon_skill_links
     * const weapon_skill_links = await prisma.weapon_skill_link.findMany({ take: 10 })
     * 
     * // Only select the `weapon_id`
     * const weapon_skill_linkWithWeapon_idOnly = await prisma.weapon_skill_link.findMany({ select: { weapon_id: true } })
     * 
    **/
    findMany<T extends weapon_skill_linkFindManyArgs>(
      args?: SelectSubset<T, weapon_skill_linkFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<weapon_skill_link>>, PrismaPromise<Array<weapon_skill_linkGetPayload<T>>>>

    /**
     * Create a Weapon_skill_link.
     * @param {weapon_skill_linkCreateArgs} args - Arguments to create a Weapon_skill_link.
     * @example
     * // Create one Weapon_skill_link
     * const Weapon_skill_link = await prisma.weapon_skill_link.create({
     *   data: {
     *     // ... data to create a Weapon_skill_link
     *   }
     * })
     * 
    **/
    create<T extends weapon_skill_linkCreateArgs>(
      args: SelectSubset<T, weapon_skill_linkCreateArgs>
    ): CheckSelect<T, Prisma__weapon_skill_linkClient<weapon_skill_link>, Prisma__weapon_skill_linkClient<weapon_skill_linkGetPayload<T>>>

    /**
     * Create many Weapon_skill_links.
     *     @param {weapon_skill_linkCreateManyArgs} args - Arguments to create many Weapon_skill_links.
     *     @example
     *     // Create many Weapon_skill_links
     *     const weapon_skill_link = await prisma.weapon_skill_link.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends weapon_skill_linkCreateManyArgs>(
      args?: SelectSubset<T, weapon_skill_linkCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Weapon_skill_link.
     * @param {weapon_skill_linkDeleteArgs} args - Arguments to delete one Weapon_skill_link.
     * @example
     * // Delete one Weapon_skill_link
     * const Weapon_skill_link = await prisma.weapon_skill_link.delete({
     *   where: {
     *     // ... filter to delete one Weapon_skill_link
     *   }
     * })
     * 
    **/
    delete<T extends weapon_skill_linkDeleteArgs>(
      args: SelectSubset<T, weapon_skill_linkDeleteArgs>
    ): CheckSelect<T, Prisma__weapon_skill_linkClient<weapon_skill_link>, Prisma__weapon_skill_linkClient<weapon_skill_linkGetPayload<T>>>

    /**
     * Update one Weapon_skill_link.
     * @param {weapon_skill_linkUpdateArgs} args - Arguments to update one Weapon_skill_link.
     * @example
     * // Update one Weapon_skill_link
     * const weapon_skill_link = await prisma.weapon_skill_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends weapon_skill_linkUpdateArgs>(
      args: SelectSubset<T, weapon_skill_linkUpdateArgs>
    ): CheckSelect<T, Prisma__weapon_skill_linkClient<weapon_skill_link>, Prisma__weapon_skill_linkClient<weapon_skill_linkGetPayload<T>>>

    /**
     * Delete zero or more Weapon_skill_links.
     * @param {weapon_skill_linkDeleteManyArgs} args - Arguments to filter Weapon_skill_links to delete.
     * @example
     * // Delete a few Weapon_skill_links
     * const { count } = await prisma.weapon_skill_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends weapon_skill_linkDeleteManyArgs>(
      args?: SelectSubset<T, weapon_skill_linkDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weapon_skill_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_skill_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weapon_skill_links
     * const weapon_skill_link = await prisma.weapon_skill_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends weapon_skill_linkUpdateManyArgs>(
      args: SelectSubset<T, weapon_skill_linkUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Weapon_skill_link.
     * @param {weapon_skill_linkUpsertArgs} args - Arguments to update or create a Weapon_skill_link.
     * @example
     * // Update or create a Weapon_skill_link
     * const weapon_skill_link = await prisma.weapon_skill_link.upsert({
     *   create: {
     *     // ... data to create a Weapon_skill_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weapon_skill_link we want to update
     *   }
     * })
    **/
    upsert<T extends weapon_skill_linkUpsertArgs>(
      args: SelectSubset<T, weapon_skill_linkUpsertArgs>
    ): CheckSelect<T, Prisma__weapon_skill_linkClient<weapon_skill_link>, Prisma__weapon_skill_linkClient<weapon_skill_linkGetPayload<T>>>

    /**
     * Count the number of Weapon_skill_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_skill_linkCountArgs} args - Arguments to filter Weapon_skill_links to count.
     * @example
     * // Count the number of Weapon_skill_links
     * const count = await prisma.weapon_skill_link.count({
     *   where: {
     *     // ... the filter for the Weapon_skill_links we want to count
     *   }
     * })
    **/
    count<T extends weapon_skill_linkCountArgs>(
      args?: Subset<T, weapon_skill_linkCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Weapon_skill_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weapon_skill_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Weapon_skill_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Weapon_skill_linkAggregateArgs>(args: Subset<T, Weapon_skill_linkAggregateArgs>): PrismaPromise<GetWeapon_skill_linkAggregateType<T>>

    /**
     * Group by Weapon_skill_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Weapon_skill_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Weapon_skill_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Weapon_skill_linkGroupByArgs['orderBy'] }
        : { orderBy?: Weapon_skill_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Weapon_skill_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeapon_skill_linkGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for weapon_skill_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__weapon_skill_linkClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    weapon_skill<T extends weapon_skillArgs = {}>(args?: Subset<T, weapon_skillArgs>): CheckSelect<T, Prisma__weapon_skillClient<weapon_skill | null >, Prisma__weapon_skillClient<weapon_skillGetPayload<T> | null >>;

    weapon<T extends weaponArgs = {}>(args?: Subset<T, weaponArgs>): CheckSelect<T, Prisma__weaponClient<weapon | null >, Prisma__weaponClient<weaponGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * weapon_skill_link findUnique
   */
  export type weapon_skill_linkFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the weapon_skill_link
     * 
    **/
    select?: weapon_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_skill_linkInclude | null
    /**
     * Throw an Error if a weapon_skill_link can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weapon_skill_link to fetch.
     * 
    **/
    where: weapon_skill_linkWhereUniqueInput
  }


  /**
   * weapon_skill_link findFirst
   */
  export type weapon_skill_linkFindFirstArgs = {
    /**
     * Select specific fields to fetch from the weapon_skill_link
     * 
    **/
    select?: weapon_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_skill_linkInclude | null
    /**
     * Throw an Error if a weapon_skill_link can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weapon_skill_link to fetch.
     * 
    **/
    where?: weapon_skill_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_skill_links to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_skill_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for weapon_skill_links.
     * 
    **/
    cursor?: weapon_skill_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_skill_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_skill_links.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of weapon_skill_links.
     * 
    **/
    distinct?: Enumerable<Weapon_skill_linkScalarFieldEnum>
  }


  /**
   * weapon_skill_link findMany
   */
  export type weapon_skill_linkFindManyArgs = {
    /**
     * Select specific fields to fetch from the weapon_skill_link
     * 
    **/
    select?: weapon_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_skill_linkInclude | null
    /**
     * Filter, which weapon_skill_links to fetch.
     * 
    **/
    where?: weapon_skill_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_skill_links to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_skill_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing weapon_skill_links.
     * 
    **/
    cursor?: weapon_skill_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_skill_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_skill_links.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Weapon_skill_linkScalarFieldEnum>
  }


  /**
   * weapon_skill_link create
   */
  export type weapon_skill_linkCreateArgs = {
    /**
     * Select specific fields to fetch from the weapon_skill_link
     * 
    **/
    select?: weapon_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_skill_linkInclude | null
    /**
     * The data needed to create a weapon_skill_link.
     * 
    **/
    data: XOR<weapon_skill_linkCreateInput, weapon_skill_linkUncheckedCreateInput>
  }


  /**
   * weapon_skill_link createMany
   */
  export type weapon_skill_linkCreateManyArgs = {
    /**
     * The data used to create many weapon_skill_links.
     * 
    **/
    data: Enumerable<weapon_skill_linkCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * weapon_skill_link update
   */
  export type weapon_skill_linkUpdateArgs = {
    /**
     * Select specific fields to fetch from the weapon_skill_link
     * 
    **/
    select?: weapon_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_skill_linkInclude | null
    /**
     * The data needed to update a weapon_skill_link.
     * 
    **/
    data: XOR<weapon_skill_linkUpdateInput, weapon_skill_linkUncheckedUpdateInput>
    /**
     * Choose, which weapon_skill_link to update.
     * 
    **/
    where: weapon_skill_linkWhereUniqueInput
  }


  /**
   * weapon_skill_link updateMany
   */
  export type weapon_skill_linkUpdateManyArgs = {
    /**
     * The data used to update weapon_skill_links.
     * 
    **/
    data: XOR<weapon_skill_linkUpdateManyMutationInput, weapon_skill_linkUncheckedUpdateManyInput>
    /**
     * Filter which weapon_skill_links to update
     * 
    **/
    where?: weapon_skill_linkWhereInput
  }


  /**
   * weapon_skill_link upsert
   */
  export type weapon_skill_linkUpsertArgs = {
    /**
     * Select specific fields to fetch from the weapon_skill_link
     * 
    **/
    select?: weapon_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_skill_linkInclude | null
    /**
     * The filter to search for the weapon_skill_link to update in case it exists.
     * 
    **/
    where: weapon_skill_linkWhereUniqueInput
    /**
     * In case the weapon_skill_link found by the `where` argument doesn't exist, create a new weapon_skill_link with this data.
     * 
    **/
    create: XOR<weapon_skill_linkCreateInput, weapon_skill_linkUncheckedCreateInput>
    /**
     * In case the weapon_skill_link was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<weapon_skill_linkUpdateInput, weapon_skill_linkUncheckedUpdateInput>
  }


  /**
   * weapon_skill_link delete
   */
  export type weapon_skill_linkDeleteArgs = {
    /**
     * Select specific fields to fetch from the weapon_skill_link
     * 
    **/
    select?: weapon_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_skill_linkInclude | null
    /**
     * Filter which weapon_skill_link to delete.
     * 
    **/
    where: weapon_skill_linkWhereUniqueInput
  }


  /**
   * weapon_skill_link deleteMany
   */
  export type weapon_skill_linkDeleteManyArgs = {
    /**
     * Filter which weapon_skill_links to delete
     * 
    **/
    where?: weapon_skill_linkWhereInput
  }


  /**
   * weapon_skill_link without action
   */
  export type weapon_skill_linkArgs = {
    /**
     * Select specific fields to fetch from the weapon_skill_link
     * 
    **/
    select?: weapon_skill_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_skill_linkInclude | null
  }



  /**
   * Model weapon_stat
   */


  export type AggregateWeapon_stat = {
    _count: Weapon_statCountAggregateOutputType | null
    _avg: Weapon_statAvgAggregateOutputType | null
    _sum: Weapon_statSumAggregateOutputType | null
    _min: Weapon_statMinAggregateOutputType | null
    _max: Weapon_statMaxAggregateOutputType | null
  }

  export type Weapon_statAvgAggregateOutputType = {
    weapon_id: number | null
    level: number | null
    atk: number | null
    hp: number | null
    vit: number | null
  }

  export type Weapon_statSumAggregateOutputType = {
    weapon_id: number | null
    level: number | null
    atk: number | null
    hp: number | null
    vit: number | null
  }

  export type Weapon_statMinAggregateOutputType = {
    weapon_id: number | null
    level: number | null
    atk: number | null
    hp: number | null
    vit: number | null
  }

  export type Weapon_statMaxAggregateOutputType = {
    weapon_id: number | null
    level: number | null
    atk: number | null
    hp: number | null
    vit: number | null
  }

  export type Weapon_statCountAggregateOutputType = {
    weapon_id: number
    level: number
    atk: number
    hp: number
    vit: number
    _all: number
  }


  export type Weapon_statAvgAggregateInputType = {
    weapon_id?: true
    level?: true
    atk?: true
    hp?: true
    vit?: true
  }

  export type Weapon_statSumAggregateInputType = {
    weapon_id?: true
    level?: true
    atk?: true
    hp?: true
    vit?: true
  }

  export type Weapon_statMinAggregateInputType = {
    weapon_id?: true
    level?: true
    atk?: true
    hp?: true
    vit?: true
  }

  export type Weapon_statMaxAggregateInputType = {
    weapon_id?: true
    level?: true
    atk?: true
    hp?: true
    vit?: true
  }

  export type Weapon_statCountAggregateInputType = {
    weapon_id?: true
    level?: true
    atk?: true
    hp?: true
    vit?: true
    _all?: true
  }

  export type Weapon_statAggregateArgs = {
    /**
     * Filter which weapon_stat to aggregate.
     * 
    **/
    where?: weapon_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_stats to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_statOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: weapon_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_stats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_stats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned weapon_stats
    **/
    _count?: true | Weapon_statCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Weapon_statAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Weapon_statSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Weapon_statMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Weapon_statMaxAggregateInputType
  }

  export type GetWeapon_statAggregateType<T extends Weapon_statAggregateArgs> = {
        [P in keyof T & keyof AggregateWeapon_stat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeapon_stat[P]>
      : GetScalarType<T[P], AggregateWeapon_stat[P]>
  }




  export type Weapon_statGroupByArgs = {
    where?: weapon_statWhereInput
    orderBy?: Enumerable<weapon_statOrderByWithAggregationInput>
    by: Array<Weapon_statScalarFieldEnum>
    having?: weapon_statScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Weapon_statCountAggregateInputType | true
    _avg?: Weapon_statAvgAggregateInputType
    _sum?: Weapon_statSumAggregateInputType
    _min?: Weapon_statMinAggregateInputType
    _max?: Weapon_statMaxAggregateInputType
  }


  export type Weapon_statGroupByOutputType = {
    weapon_id: number
    level: number
    atk: number
    hp: number
    vit: number
    _count: Weapon_statCountAggregateOutputType | null
    _avg: Weapon_statAvgAggregateOutputType | null
    _sum: Weapon_statSumAggregateOutputType | null
    _min: Weapon_statMinAggregateOutputType | null
    _max: Weapon_statMaxAggregateOutputType | null
  }

  type GetWeapon_statGroupByPayload<T extends Weapon_statGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Weapon_statGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Weapon_statGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Weapon_statGroupByOutputType[P]>
            : GetScalarType<T[P], Weapon_statGroupByOutputType[P]>
        }
      >
    >


  export type weapon_statSelect = {
    weapon_id?: boolean
    level?: boolean
    atk?: boolean
    hp?: boolean
    vit?: boolean
    weapon?: boolean | weaponArgs
  }

  export type weapon_statInclude = {
    weapon?: boolean | weaponArgs
  }

  export type weapon_statGetPayload<
    S extends boolean | null | undefined | weapon_statArgs,
    U = keyof S
      > = S extends true
        ? weapon_stat
    : S extends undefined
    ? never
    : S extends weapon_statArgs | weapon_statFindManyArgs
    ?'include' extends U
    ? weapon_stat  & {
    [P in TrueKeys<S['include']>]:
        P extends 'weapon' ? weaponGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'weapon' ? weaponGetPayload<S['select'][P]> :  P extends keyof weapon_stat ? weapon_stat[P] : never
  } 
    : weapon_stat
  : weapon_stat


  type weapon_statCountArgs = Merge<
    Omit<weapon_statFindManyArgs, 'select' | 'include'> & {
      select?: Weapon_statCountAggregateInputType | true
    }
  >

  export interface weapon_statDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Weapon_stat that matches the filter.
     * @param {weapon_statFindUniqueArgs} args - Arguments to find a Weapon_stat
     * @example
     * // Get one Weapon_stat
     * const weapon_stat = await prisma.weapon_stat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends weapon_statFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, weapon_statFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'weapon_stat'> extends True ? CheckSelect<T, Prisma__weapon_statClient<weapon_stat>, Prisma__weapon_statClient<weapon_statGetPayload<T>>> : CheckSelect<T, Prisma__weapon_statClient<weapon_stat | null >, Prisma__weapon_statClient<weapon_statGetPayload<T> | null >>

    /**
     * Find the first Weapon_stat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_statFindFirstArgs} args - Arguments to find a Weapon_stat
     * @example
     * // Get one Weapon_stat
     * const weapon_stat = await prisma.weapon_stat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends weapon_statFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, weapon_statFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'weapon_stat'> extends True ? CheckSelect<T, Prisma__weapon_statClient<weapon_stat>, Prisma__weapon_statClient<weapon_statGetPayload<T>>> : CheckSelect<T, Prisma__weapon_statClient<weapon_stat | null >, Prisma__weapon_statClient<weapon_statGetPayload<T> | null >>

    /**
     * Find zero or more Weapon_stats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_statFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weapon_stats
     * const weapon_stats = await prisma.weapon_stat.findMany()
     * 
     * // Get first 10 Weapon_stats
     * const weapon_stats = await prisma.weapon_stat.findMany({ take: 10 })
     * 
     * // Only select the `weapon_id`
     * const weapon_statWithWeapon_idOnly = await prisma.weapon_stat.findMany({ select: { weapon_id: true } })
     * 
    **/
    findMany<T extends weapon_statFindManyArgs>(
      args?: SelectSubset<T, weapon_statFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<weapon_stat>>, PrismaPromise<Array<weapon_statGetPayload<T>>>>

    /**
     * Create a Weapon_stat.
     * @param {weapon_statCreateArgs} args - Arguments to create a Weapon_stat.
     * @example
     * // Create one Weapon_stat
     * const Weapon_stat = await prisma.weapon_stat.create({
     *   data: {
     *     // ... data to create a Weapon_stat
     *   }
     * })
     * 
    **/
    create<T extends weapon_statCreateArgs>(
      args: SelectSubset<T, weapon_statCreateArgs>
    ): CheckSelect<T, Prisma__weapon_statClient<weapon_stat>, Prisma__weapon_statClient<weapon_statGetPayload<T>>>

    /**
     * Create many Weapon_stats.
     *     @param {weapon_statCreateManyArgs} args - Arguments to create many Weapon_stats.
     *     @example
     *     // Create many Weapon_stats
     *     const weapon_stat = await prisma.weapon_stat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends weapon_statCreateManyArgs>(
      args?: SelectSubset<T, weapon_statCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Weapon_stat.
     * @param {weapon_statDeleteArgs} args - Arguments to delete one Weapon_stat.
     * @example
     * // Delete one Weapon_stat
     * const Weapon_stat = await prisma.weapon_stat.delete({
     *   where: {
     *     // ... filter to delete one Weapon_stat
     *   }
     * })
     * 
    **/
    delete<T extends weapon_statDeleteArgs>(
      args: SelectSubset<T, weapon_statDeleteArgs>
    ): CheckSelect<T, Prisma__weapon_statClient<weapon_stat>, Prisma__weapon_statClient<weapon_statGetPayload<T>>>

    /**
     * Update one Weapon_stat.
     * @param {weapon_statUpdateArgs} args - Arguments to update one Weapon_stat.
     * @example
     * // Update one Weapon_stat
     * const weapon_stat = await prisma.weapon_stat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends weapon_statUpdateArgs>(
      args: SelectSubset<T, weapon_statUpdateArgs>
    ): CheckSelect<T, Prisma__weapon_statClient<weapon_stat>, Prisma__weapon_statClient<weapon_statGetPayload<T>>>

    /**
     * Delete zero or more Weapon_stats.
     * @param {weapon_statDeleteManyArgs} args - Arguments to filter Weapon_stats to delete.
     * @example
     * // Delete a few Weapon_stats
     * const { count } = await prisma.weapon_stat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends weapon_statDeleteManyArgs>(
      args?: SelectSubset<T, weapon_statDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weapon_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_statUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weapon_stats
     * const weapon_stat = await prisma.weapon_stat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends weapon_statUpdateManyArgs>(
      args: SelectSubset<T, weapon_statUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Weapon_stat.
     * @param {weapon_statUpsertArgs} args - Arguments to update or create a Weapon_stat.
     * @example
     * // Update or create a Weapon_stat
     * const weapon_stat = await prisma.weapon_stat.upsert({
     *   create: {
     *     // ... data to create a Weapon_stat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weapon_stat we want to update
     *   }
     * })
    **/
    upsert<T extends weapon_statUpsertArgs>(
      args: SelectSubset<T, weapon_statUpsertArgs>
    ): CheckSelect<T, Prisma__weapon_statClient<weapon_stat>, Prisma__weapon_statClient<weapon_statGetPayload<T>>>

    /**
     * Count the number of Weapon_stats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_statCountArgs} args - Arguments to filter Weapon_stats to count.
     * @example
     * // Count the number of Weapon_stats
     * const count = await prisma.weapon_stat.count({
     *   where: {
     *     // ... the filter for the Weapon_stats we want to count
     *   }
     * })
    **/
    count<T extends weapon_statCountArgs>(
      args?: Subset<T, weapon_statCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Weapon_statCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weapon_stat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Weapon_statAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Weapon_statAggregateArgs>(args: Subset<T, Weapon_statAggregateArgs>): PrismaPromise<GetWeapon_statAggregateType<T>>

    /**
     * Group by Weapon_stat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Weapon_statGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Weapon_statGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Weapon_statGroupByArgs['orderBy'] }
        : { orderBy?: Weapon_statGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Weapon_statGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeapon_statGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for weapon_stat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__weapon_statClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    weapon<T extends weaponArgs = {}>(args?: Subset<T, weaponArgs>): CheckSelect<T, Prisma__weaponClient<weapon | null >, Prisma__weaponClient<weaponGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * weapon_stat findUnique
   */
  export type weapon_statFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the weapon_stat
     * 
    **/
    select?: weapon_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_statInclude | null
    /**
     * Throw an Error if a weapon_stat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weapon_stat to fetch.
     * 
    **/
    where: weapon_statWhereUniqueInput
  }


  /**
   * weapon_stat findFirst
   */
  export type weapon_statFindFirstArgs = {
    /**
     * Select specific fields to fetch from the weapon_stat
     * 
    **/
    select?: weapon_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_statInclude | null
    /**
     * Throw an Error if a weapon_stat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weapon_stat to fetch.
     * 
    **/
    where?: weapon_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_stats to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_statOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for weapon_stats.
     * 
    **/
    cursor?: weapon_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_stats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_stats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of weapon_stats.
     * 
    **/
    distinct?: Enumerable<Weapon_statScalarFieldEnum>
  }


  /**
   * weapon_stat findMany
   */
  export type weapon_statFindManyArgs = {
    /**
     * Select specific fields to fetch from the weapon_stat
     * 
    **/
    select?: weapon_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_statInclude | null
    /**
     * Filter, which weapon_stats to fetch.
     * 
    **/
    where?: weapon_statWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_stats to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_statOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing weapon_stats.
     * 
    **/
    cursor?: weapon_statWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_stats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_stats.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Weapon_statScalarFieldEnum>
  }


  /**
   * weapon_stat create
   */
  export type weapon_statCreateArgs = {
    /**
     * Select specific fields to fetch from the weapon_stat
     * 
    **/
    select?: weapon_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_statInclude | null
    /**
     * The data needed to create a weapon_stat.
     * 
    **/
    data: XOR<weapon_statCreateInput, weapon_statUncheckedCreateInput>
  }


  /**
   * weapon_stat createMany
   */
  export type weapon_statCreateManyArgs = {
    /**
     * The data used to create many weapon_stats.
     * 
    **/
    data: Enumerable<weapon_statCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * weapon_stat update
   */
  export type weapon_statUpdateArgs = {
    /**
     * Select specific fields to fetch from the weapon_stat
     * 
    **/
    select?: weapon_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_statInclude | null
    /**
     * The data needed to update a weapon_stat.
     * 
    **/
    data: XOR<weapon_statUpdateInput, weapon_statUncheckedUpdateInput>
    /**
     * Choose, which weapon_stat to update.
     * 
    **/
    where: weapon_statWhereUniqueInput
  }


  /**
   * weapon_stat updateMany
   */
  export type weapon_statUpdateManyArgs = {
    /**
     * The data used to update weapon_stats.
     * 
    **/
    data: XOR<weapon_statUpdateManyMutationInput, weapon_statUncheckedUpdateManyInput>
    /**
     * Filter which weapon_stats to update
     * 
    **/
    where?: weapon_statWhereInput
  }


  /**
   * weapon_stat upsert
   */
  export type weapon_statUpsertArgs = {
    /**
     * Select specific fields to fetch from the weapon_stat
     * 
    **/
    select?: weapon_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_statInclude | null
    /**
     * The filter to search for the weapon_stat to update in case it exists.
     * 
    **/
    where: weapon_statWhereUniqueInput
    /**
     * In case the weapon_stat found by the `where` argument doesn't exist, create a new weapon_stat with this data.
     * 
    **/
    create: XOR<weapon_statCreateInput, weapon_statUncheckedCreateInput>
    /**
     * In case the weapon_stat was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<weapon_statUpdateInput, weapon_statUncheckedUpdateInput>
  }


  /**
   * weapon_stat delete
   */
  export type weapon_statDeleteArgs = {
    /**
     * Select specific fields to fetch from the weapon_stat
     * 
    **/
    select?: weapon_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_statInclude | null
    /**
     * Filter which weapon_stat to delete.
     * 
    **/
    where: weapon_statWhereUniqueInput
  }


  /**
   * weapon_stat deleteMany
   */
  export type weapon_statDeleteManyArgs = {
    /**
     * Filter which weapon_stats to delete
     * 
    **/
    where?: weapon_statWhereInput
  }


  /**
   * weapon_stat without action
   */
  export type weapon_statArgs = {
    /**
     * Select specific fields to fetch from the weapon_stat
     * 
    **/
    select?: weapon_statSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_statInclude | null
  }



  /**
   * Model weapon_story
   */


  export type AggregateWeapon_story = {
    _count: Weapon_storyCountAggregateOutputType | null
    _avg: Weapon_storyAvgAggregateOutputType | null
    _sum: Weapon_storySumAggregateOutputType | null
    _min: Weapon_storyMinAggregateOutputType | null
    _max: Weapon_storyMaxAggregateOutputType | null
  }

  export type Weapon_storyAvgAggregateOutputType = {
    id: number | null
  }

  export type Weapon_storySumAggregateOutputType = {
    id: number | null
  }

  export type Weapon_storyMinAggregateOutputType = {
    id: number | null
    story: string | null
  }

  export type Weapon_storyMaxAggregateOutputType = {
    id: number | null
    story: string | null
  }

  export type Weapon_storyCountAggregateOutputType = {
    id: number
    story: number
    _all: number
  }


  export type Weapon_storyAvgAggregateInputType = {
    id?: true
  }

  export type Weapon_storySumAggregateInputType = {
    id?: true
  }

  export type Weapon_storyMinAggregateInputType = {
    id?: true
    story?: true
  }

  export type Weapon_storyMaxAggregateInputType = {
    id?: true
    story?: true
  }

  export type Weapon_storyCountAggregateInputType = {
    id?: true
    story?: true
    _all?: true
  }

  export type Weapon_storyAggregateArgs = {
    /**
     * Filter which weapon_story to aggregate.
     * 
    **/
    where?: weapon_storyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_stories to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_storyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: weapon_storyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_stories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_stories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned weapon_stories
    **/
    _count?: true | Weapon_storyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Weapon_storyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Weapon_storySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Weapon_storyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Weapon_storyMaxAggregateInputType
  }

  export type GetWeapon_storyAggregateType<T extends Weapon_storyAggregateArgs> = {
        [P in keyof T & keyof AggregateWeapon_story]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeapon_story[P]>
      : GetScalarType<T[P], AggregateWeapon_story[P]>
  }




  export type Weapon_storyGroupByArgs = {
    where?: weapon_storyWhereInput
    orderBy?: Enumerable<weapon_storyOrderByWithAggregationInput>
    by: Array<Weapon_storyScalarFieldEnum>
    having?: weapon_storyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Weapon_storyCountAggregateInputType | true
    _avg?: Weapon_storyAvgAggregateInputType
    _sum?: Weapon_storySumAggregateInputType
    _min?: Weapon_storyMinAggregateInputType
    _max?: Weapon_storyMaxAggregateInputType
  }


  export type Weapon_storyGroupByOutputType = {
    id: number
    story: string | null
    _count: Weapon_storyCountAggregateOutputType | null
    _avg: Weapon_storyAvgAggregateOutputType | null
    _sum: Weapon_storySumAggregateOutputType | null
    _min: Weapon_storyMinAggregateOutputType | null
    _max: Weapon_storyMaxAggregateOutputType | null
  }

  type GetWeapon_storyGroupByPayload<T extends Weapon_storyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Weapon_storyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Weapon_storyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Weapon_storyGroupByOutputType[P]>
            : GetScalarType<T[P], Weapon_storyGroupByOutputType[P]>
        }
      >
    >


  export type weapon_storySelect = {
    id?: boolean
    story?: boolean
    weapon_story_link?: boolean | weapon_story_linkFindManyArgs
    _count?: boolean | Weapon_storyCountOutputTypeArgs
  }

  export type weapon_storyInclude = {
    weapon_story_link?: boolean | weapon_story_linkFindManyArgs
    _count?: boolean | Weapon_storyCountOutputTypeArgs
  }

  export type weapon_storyGetPayload<
    S extends boolean | null | undefined | weapon_storyArgs,
    U = keyof S
      > = S extends true
        ? weapon_story
    : S extends undefined
    ? never
    : S extends weapon_storyArgs | weapon_storyFindManyArgs
    ?'include' extends U
    ? weapon_story  & {
    [P in TrueKeys<S['include']>]:
        P extends 'weapon_story_link' ? Array < weapon_story_linkGetPayload<S['include'][P]>>  :
        P extends '_count' ? Weapon_storyCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'weapon_story_link' ? Array < weapon_story_linkGetPayload<S['select'][P]>>  :
        P extends '_count' ? Weapon_storyCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof weapon_story ? weapon_story[P] : never
  } 
    : weapon_story
  : weapon_story


  type weapon_storyCountArgs = Merge<
    Omit<weapon_storyFindManyArgs, 'select' | 'include'> & {
      select?: Weapon_storyCountAggregateInputType | true
    }
  >

  export interface weapon_storyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Weapon_story that matches the filter.
     * @param {weapon_storyFindUniqueArgs} args - Arguments to find a Weapon_story
     * @example
     * // Get one Weapon_story
     * const weapon_story = await prisma.weapon_story.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends weapon_storyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, weapon_storyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'weapon_story'> extends True ? CheckSelect<T, Prisma__weapon_storyClient<weapon_story>, Prisma__weapon_storyClient<weapon_storyGetPayload<T>>> : CheckSelect<T, Prisma__weapon_storyClient<weapon_story | null >, Prisma__weapon_storyClient<weapon_storyGetPayload<T> | null >>

    /**
     * Find the first Weapon_story that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_storyFindFirstArgs} args - Arguments to find a Weapon_story
     * @example
     * // Get one Weapon_story
     * const weapon_story = await prisma.weapon_story.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends weapon_storyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, weapon_storyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'weapon_story'> extends True ? CheckSelect<T, Prisma__weapon_storyClient<weapon_story>, Prisma__weapon_storyClient<weapon_storyGetPayload<T>>> : CheckSelect<T, Prisma__weapon_storyClient<weapon_story | null >, Prisma__weapon_storyClient<weapon_storyGetPayload<T> | null >>

    /**
     * Find zero or more Weapon_stories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_storyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weapon_stories
     * const weapon_stories = await prisma.weapon_story.findMany()
     * 
     * // Get first 10 Weapon_stories
     * const weapon_stories = await prisma.weapon_story.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const weapon_storyWithIdOnly = await prisma.weapon_story.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends weapon_storyFindManyArgs>(
      args?: SelectSubset<T, weapon_storyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<weapon_story>>, PrismaPromise<Array<weapon_storyGetPayload<T>>>>

    /**
     * Create a Weapon_story.
     * @param {weapon_storyCreateArgs} args - Arguments to create a Weapon_story.
     * @example
     * // Create one Weapon_story
     * const Weapon_story = await prisma.weapon_story.create({
     *   data: {
     *     // ... data to create a Weapon_story
     *   }
     * })
     * 
    **/
    create<T extends weapon_storyCreateArgs>(
      args: SelectSubset<T, weapon_storyCreateArgs>
    ): CheckSelect<T, Prisma__weapon_storyClient<weapon_story>, Prisma__weapon_storyClient<weapon_storyGetPayload<T>>>

    /**
     * Create many Weapon_stories.
     *     @param {weapon_storyCreateManyArgs} args - Arguments to create many Weapon_stories.
     *     @example
     *     // Create many Weapon_stories
     *     const weapon_story = await prisma.weapon_story.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends weapon_storyCreateManyArgs>(
      args?: SelectSubset<T, weapon_storyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Weapon_story.
     * @param {weapon_storyDeleteArgs} args - Arguments to delete one Weapon_story.
     * @example
     * // Delete one Weapon_story
     * const Weapon_story = await prisma.weapon_story.delete({
     *   where: {
     *     // ... filter to delete one Weapon_story
     *   }
     * })
     * 
    **/
    delete<T extends weapon_storyDeleteArgs>(
      args: SelectSubset<T, weapon_storyDeleteArgs>
    ): CheckSelect<T, Prisma__weapon_storyClient<weapon_story>, Prisma__weapon_storyClient<weapon_storyGetPayload<T>>>

    /**
     * Update one Weapon_story.
     * @param {weapon_storyUpdateArgs} args - Arguments to update one Weapon_story.
     * @example
     * // Update one Weapon_story
     * const weapon_story = await prisma.weapon_story.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends weapon_storyUpdateArgs>(
      args: SelectSubset<T, weapon_storyUpdateArgs>
    ): CheckSelect<T, Prisma__weapon_storyClient<weapon_story>, Prisma__weapon_storyClient<weapon_storyGetPayload<T>>>

    /**
     * Delete zero or more Weapon_stories.
     * @param {weapon_storyDeleteManyArgs} args - Arguments to filter Weapon_stories to delete.
     * @example
     * // Delete a few Weapon_stories
     * const { count } = await prisma.weapon_story.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends weapon_storyDeleteManyArgs>(
      args?: SelectSubset<T, weapon_storyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weapon_stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_storyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weapon_stories
     * const weapon_story = await prisma.weapon_story.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends weapon_storyUpdateManyArgs>(
      args: SelectSubset<T, weapon_storyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Weapon_story.
     * @param {weapon_storyUpsertArgs} args - Arguments to update or create a Weapon_story.
     * @example
     * // Update or create a Weapon_story
     * const weapon_story = await prisma.weapon_story.upsert({
     *   create: {
     *     // ... data to create a Weapon_story
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weapon_story we want to update
     *   }
     * })
    **/
    upsert<T extends weapon_storyUpsertArgs>(
      args: SelectSubset<T, weapon_storyUpsertArgs>
    ): CheckSelect<T, Prisma__weapon_storyClient<weapon_story>, Prisma__weapon_storyClient<weapon_storyGetPayload<T>>>

    /**
     * Count the number of Weapon_stories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_storyCountArgs} args - Arguments to filter Weapon_stories to count.
     * @example
     * // Count the number of Weapon_stories
     * const count = await prisma.weapon_story.count({
     *   where: {
     *     // ... the filter for the Weapon_stories we want to count
     *   }
     * })
    **/
    count<T extends weapon_storyCountArgs>(
      args?: Subset<T, weapon_storyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Weapon_storyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weapon_story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Weapon_storyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Weapon_storyAggregateArgs>(args: Subset<T, Weapon_storyAggregateArgs>): PrismaPromise<GetWeapon_storyAggregateType<T>>

    /**
     * Group by Weapon_story.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Weapon_storyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Weapon_storyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Weapon_storyGroupByArgs['orderBy'] }
        : { orderBy?: Weapon_storyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Weapon_storyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeapon_storyGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for weapon_story.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__weapon_storyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    weapon_story_link<T extends weapon_story_linkFindManyArgs = {}>(args?: Subset<T, weapon_story_linkFindManyArgs>): CheckSelect<T, PrismaPromise<Array<weapon_story_link>>, PrismaPromise<Array<weapon_story_linkGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * weapon_story findUnique
   */
  export type weapon_storyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the weapon_story
     * 
    **/
    select?: weapon_storySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_storyInclude | null
    /**
     * Throw an Error if a weapon_story can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weapon_story to fetch.
     * 
    **/
    where: weapon_storyWhereUniqueInput
  }


  /**
   * weapon_story findFirst
   */
  export type weapon_storyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the weapon_story
     * 
    **/
    select?: weapon_storySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_storyInclude | null
    /**
     * Throw an Error if a weapon_story can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weapon_story to fetch.
     * 
    **/
    where?: weapon_storyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_stories to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_storyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for weapon_stories.
     * 
    **/
    cursor?: weapon_storyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_stories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_stories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of weapon_stories.
     * 
    **/
    distinct?: Enumerable<Weapon_storyScalarFieldEnum>
  }


  /**
   * weapon_story findMany
   */
  export type weapon_storyFindManyArgs = {
    /**
     * Select specific fields to fetch from the weapon_story
     * 
    **/
    select?: weapon_storySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_storyInclude | null
    /**
     * Filter, which weapon_stories to fetch.
     * 
    **/
    where?: weapon_storyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_stories to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_storyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing weapon_stories.
     * 
    **/
    cursor?: weapon_storyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_stories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_stories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Weapon_storyScalarFieldEnum>
  }


  /**
   * weapon_story create
   */
  export type weapon_storyCreateArgs = {
    /**
     * Select specific fields to fetch from the weapon_story
     * 
    **/
    select?: weapon_storySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_storyInclude | null
    /**
     * The data needed to create a weapon_story.
     * 
    **/
    data: XOR<weapon_storyCreateInput, weapon_storyUncheckedCreateInput>
  }


  /**
   * weapon_story createMany
   */
  export type weapon_storyCreateManyArgs = {
    /**
     * The data used to create many weapon_stories.
     * 
    **/
    data: Enumerable<weapon_storyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * weapon_story update
   */
  export type weapon_storyUpdateArgs = {
    /**
     * Select specific fields to fetch from the weapon_story
     * 
    **/
    select?: weapon_storySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_storyInclude | null
    /**
     * The data needed to update a weapon_story.
     * 
    **/
    data: XOR<weapon_storyUpdateInput, weapon_storyUncheckedUpdateInput>
    /**
     * Choose, which weapon_story to update.
     * 
    **/
    where: weapon_storyWhereUniqueInput
  }


  /**
   * weapon_story updateMany
   */
  export type weapon_storyUpdateManyArgs = {
    /**
     * The data used to update weapon_stories.
     * 
    **/
    data: XOR<weapon_storyUpdateManyMutationInput, weapon_storyUncheckedUpdateManyInput>
    /**
     * Filter which weapon_stories to update
     * 
    **/
    where?: weapon_storyWhereInput
  }


  /**
   * weapon_story upsert
   */
  export type weapon_storyUpsertArgs = {
    /**
     * Select specific fields to fetch from the weapon_story
     * 
    **/
    select?: weapon_storySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_storyInclude | null
    /**
     * The filter to search for the weapon_story to update in case it exists.
     * 
    **/
    where: weapon_storyWhereUniqueInput
    /**
     * In case the weapon_story found by the `where` argument doesn't exist, create a new weapon_story with this data.
     * 
    **/
    create: XOR<weapon_storyCreateInput, weapon_storyUncheckedCreateInput>
    /**
     * In case the weapon_story was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<weapon_storyUpdateInput, weapon_storyUncheckedUpdateInput>
  }


  /**
   * weapon_story delete
   */
  export type weapon_storyDeleteArgs = {
    /**
     * Select specific fields to fetch from the weapon_story
     * 
    **/
    select?: weapon_storySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_storyInclude | null
    /**
     * Filter which weapon_story to delete.
     * 
    **/
    where: weapon_storyWhereUniqueInput
  }


  /**
   * weapon_story deleteMany
   */
  export type weapon_storyDeleteManyArgs = {
    /**
     * Filter which weapon_stories to delete
     * 
    **/
    where?: weapon_storyWhereInput
  }


  /**
   * weapon_story without action
   */
  export type weapon_storyArgs = {
    /**
     * Select specific fields to fetch from the weapon_story
     * 
    **/
    select?: weapon_storySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_storyInclude | null
  }



  /**
   * Model weapon_story_link
   */


  export type AggregateWeapon_story_link = {
    _count: Weapon_story_linkCountAggregateOutputType | null
    _avg: Weapon_story_linkAvgAggregateOutputType | null
    _sum: Weapon_story_linkSumAggregateOutputType | null
    _min: Weapon_story_linkMinAggregateOutputType | null
    _max: Weapon_story_linkMaxAggregateOutputType | null
  }

  export type Weapon_story_linkAvgAggregateOutputType = {
    weapon_id: number | null
    weapon_story_id: number | null
  }

  export type Weapon_story_linkSumAggregateOutputType = {
    weapon_id: number | null
    weapon_story_id: number | null
  }

  export type Weapon_story_linkMinAggregateOutputType = {
    weapon_id: number | null
    weapon_story_id: number | null
  }

  export type Weapon_story_linkMaxAggregateOutputType = {
    weapon_id: number | null
    weapon_story_id: number | null
  }

  export type Weapon_story_linkCountAggregateOutputType = {
    weapon_id: number
    weapon_story_id: number
    _all: number
  }


  export type Weapon_story_linkAvgAggregateInputType = {
    weapon_id?: true
    weapon_story_id?: true
  }

  export type Weapon_story_linkSumAggregateInputType = {
    weapon_id?: true
    weapon_story_id?: true
  }

  export type Weapon_story_linkMinAggregateInputType = {
    weapon_id?: true
    weapon_story_id?: true
  }

  export type Weapon_story_linkMaxAggregateInputType = {
    weapon_id?: true
    weapon_story_id?: true
  }

  export type Weapon_story_linkCountAggregateInputType = {
    weapon_id?: true
    weapon_story_id?: true
    _all?: true
  }

  export type Weapon_story_linkAggregateArgs = {
    /**
     * Filter which weapon_story_link to aggregate.
     * 
    **/
    where?: weapon_story_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_story_links to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_story_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: weapon_story_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_story_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_story_links.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned weapon_story_links
    **/
    _count?: true | Weapon_story_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Weapon_story_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Weapon_story_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Weapon_story_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Weapon_story_linkMaxAggregateInputType
  }

  export type GetWeapon_story_linkAggregateType<T extends Weapon_story_linkAggregateArgs> = {
        [P in keyof T & keyof AggregateWeapon_story_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWeapon_story_link[P]>
      : GetScalarType<T[P], AggregateWeapon_story_link[P]>
  }




  export type Weapon_story_linkGroupByArgs = {
    where?: weapon_story_linkWhereInput
    orderBy?: Enumerable<weapon_story_linkOrderByWithAggregationInput>
    by: Array<Weapon_story_linkScalarFieldEnum>
    having?: weapon_story_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Weapon_story_linkCountAggregateInputType | true
    _avg?: Weapon_story_linkAvgAggregateInputType
    _sum?: Weapon_story_linkSumAggregateInputType
    _min?: Weapon_story_linkMinAggregateInputType
    _max?: Weapon_story_linkMaxAggregateInputType
  }


  export type Weapon_story_linkGroupByOutputType = {
    weapon_id: number
    weapon_story_id: number
    _count: Weapon_story_linkCountAggregateOutputType | null
    _avg: Weapon_story_linkAvgAggregateOutputType | null
    _sum: Weapon_story_linkSumAggregateOutputType | null
    _min: Weapon_story_linkMinAggregateOutputType | null
    _max: Weapon_story_linkMaxAggregateOutputType | null
  }

  type GetWeapon_story_linkGroupByPayload<T extends Weapon_story_linkGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Weapon_story_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Weapon_story_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Weapon_story_linkGroupByOutputType[P]>
            : GetScalarType<T[P], Weapon_story_linkGroupByOutputType[P]>
        }
      >
    >


  export type weapon_story_linkSelect = {
    weapon_id?: boolean
    weapon_story_id?: boolean
    weapon?: boolean | weaponArgs
    weapon_story?: boolean | weapon_storyArgs
  }

  export type weapon_story_linkInclude = {
    weapon?: boolean | weaponArgs
    weapon_story?: boolean | weapon_storyArgs
  }

  export type weapon_story_linkGetPayload<
    S extends boolean | null | undefined | weapon_story_linkArgs,
    U = keyof S
      > = S extends true
        ? weapon_story_link
    : S extends undefined
    ? never
    : S extends weapon_story_linkArgs | weapon_story_linkFindManyArgs
    ?'include' extends U
    ? weapon_story_link  & {
    [P in TrueKeys<S['include']>]:
        P extends 'weapon' ? weaponGetPayload<S['include'][P]> :
        P extends 'weapon_story' ? weapon_storyGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'weapon' ? weaponGetPayload<S['select'][P]> :
        P extends 'weapon_story' ? weapon_storyGetPayload<S['select'][P]> :  P extends keyof weapon_story_link ? weapon_story_link[P] : never
  } 
    : weapon_story_link
  : weapon_story_link


  type weapon_story_linkCountArgs = Merge<
    Omit<weapon_story_linkFindManyArgs, 'select' | 'include'> & {
      select?: Weapon_story_linkCountAggregateInputType | true
    }
  >

  export interface weapon_story_linkDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Weapon_story_link that matches the filter.
     * @param {weapon_story_linkFindUniqueArgs} args - Arguments to find a Weapon_story_link
     * @example
     * // Get one Weapon_story_link
     * const weapon_story_link = await prisma.weapon_story_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends weapon_story_linkFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, weapon_story_linkFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'weapon_story_link'> extends True ? CheckSelect<T, Prisma__weapon_story_linkClient<weapon_story_link>, Prisma__weapon_story_linkClient<weapon_story_linkGetPayload<T>>> : CheckSelect<T, Prisma__weapon_story_linkClient<weapon_story_link | null >, Prisma__weapon_story_linkClient<weapon_story_linkGetPayload<T> | null >>

    /**
     * Find the first Weapon_story_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_story_linkFindFirstArgs} args - Arguments to find a Weapon_story_link
     * @example
     * // Get one Weapon_story_link
     * const weapon_story_link = await prisma.weapon_story_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends weapon_story_linkFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, weapon_story_linkFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'weapon_story_link'> extends True ? CheckSelect<T, Prisma__weapon_story_linkClient<weapon_story_link>, Prisma__weapon_story_linkClient<weapon_story_linkGetPayload<T>>> : CheckSelect<T, Prisma__weapon_story_linkClient<weapon_story_link | null >, Prisma__weapon_story_linkClient<weapon_story_linkGetPayload<T> | null >>

    /**
     * Find zero or more Weapon_story_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_story_linkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Weapon_story_links
     * const weapon_story_links = await prisma.weapon_story_link.findMany()
     * 
     * // Get first 10 Weapon_story_links
     * const weapon_story_links = await prisma.weapon_story_link.findMany({ take: 10 })
     * 
     * // Only select the `weapon_id`
     * const weapon_story_linkWithWeapon_idOnly = await prisma.weapon_story_link.findMany({ select: { weapon_id: true } })
     * 
    **/
    findMany<T extends weapon_story_linkFindManyArgs>(
      args?: SelectSubset<T, weapon_story_linkFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<weapon_story_link>>, PrismaPromise<Array<weapon_story_linkGetPayload<T>>>>

    /**
     * Create a Weapon_story_link.
     * @param {weapon_story_linkCreateArgs} args - Arguments to create a Weapon_story_link.
     * @example
     * // Create one Weapon_story_link
     * const Weapon_story_link = await prisma.weapon_story_link.create({
     *   data: {
     *     // ... data to create a Weapon_story_link
     *   }
     * })
     * 
    **/
    create<T extends weapon_story_linkCreateArgs>(
      args: SelectSubset<T, weapon_story_linkCreateArgs>
    ): CheckSelect<T, Prisma__weapon_story_linkClient<weapon_story_link>, Prisma__weapon_story_linkClient<weapon_story_linkGetPayload<T>>>

    /**
     * Create many Weapon_story_links.
     *     @param {weapon_story_linkCreateManyArgs} args - Arguments to create many Weapon_story_links.
     *     @example
     *     // Create many Weapon_story_links
     *     const weapon_story_link = await prisma.weapon_story_link.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends weapon_story_linkCreateManyArgs>(
      args?: SelectSubset<T, weapon_story_linkCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Weapon_story_link.
     * @param {weapon_story_linkDeleteArgs} args - Arguments to delete one Weapon_story_link.
     * @example
     * // Delete one Weapon_story_link
     * const Weapon_story_link = await prisma.weapon_story_link.delete({
     *   where: {
     *     // ... filter to delete one Weapon_story_link
     *   }
     * })
     * 
    **/
    delete<T extends weapon_story_linkDeleteArgs>(
      args: SelectSubset<T, weapon_story_linkDeleteArgs>
    ): CheckSelect<T, Prisma__weapon_story_linkClient<weapon_story_link>, Prisma__weapon_story_linkClient<weapon_story_linkGetPayload<T>>>

    /**
     * Update one Weapon_story_link.
     * @param {weapon_story_linkUpdateArgs} args - Arguments to update one Weapon_story_link.
     * @example
     * // Update one Weapon_story_link
     * const weapon_story_link = await prisma.weapon_story_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends weapon_story_linkUpdateArgs>(
      args: SelectSubset<T, weapon_story_linkUpdateArgs>
    ): CheckSelect<T, Prisma__weapon_story_linkClient<weapon_story_link>, Prisma__weapon_story_linkClient<weapon_story_linkGetPayload<T>>>

    /**
     * Delete zero or more Weapon_story_links.
     * @param {weapon_story_linkDeleteManyArgs} args - Arguments to filter Weapon_story_links to delete.
     * @example
     * // Delete a few Weapon_story_links
     * const { count } = await prisma.weapon_story_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends weapon_story_linkDeleteManyArgs>(
      args?: SelectSubset<T, weapon_story_linkDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Weapon_story_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_story_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Weapon_story_links
     * const weapon_story_link = await prisma.weapon_story_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends weapon_story_linkUpdateManyArgs>(
      args: SelectSubset<T, weapon_story_linkUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Weapon_story_link.
     * @param {weapon_story_linkUpsertArgs} args - Arguments to update or create a Weapon_story_link.
     * @example
     * // Update or create a Weapon_story_link
     * const weapon_story_link = await prisma.weapon_story_link.upsert({
     *   create: {
     *     // ... data to create a Weapon_story_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Weapon_story_link we want to update
     *   }
     * })
    **/
    upsert<T extends weapon_story_linkUpsertArgs>(
      args: SelectSubset<T, weapon_story_linkUpsertArgs>
    ): CheckSelect<T, Prisma__weapon_story_linkClient<weapon_story_link>, Prisma__weapon_story_linkClient<weapon_story_linkGetPayload<T>>>

    /**
     * Count the number of Weapon_story_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {weapon_story_linkCountArgs} args - Arguments to filter Weapon_story_links to count.
     * @example
     * // Count the number of Weapon_story_links
     * const count = await prisma.weapon_story_link.count({
     *   where: {
     *     // ... the filter for the Weapon_story_links we want to count
     *   }
     * })
    **/
    count<T extends weapon_story_linkCountArgs>(
      args?: Subset<T, weapon_story_linkCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Weapon_story_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Weapon_story_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Weapon_story_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Weapon_story_linkAggregateArgs>(args: Subset<T, Weapon_story_linkAggregateArgs>): PrismaPromise<GetWeapon_story_linkAggregateType<T>>

    /**
     * Group by Weapon_story_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Weapon_story_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Weapon_story_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Weapon_story_linkGroupByArgs['orderBy'] }
        : { orderBy?: Weapon_story_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Weapon_story_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWeapon_story_linkGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for weapon_story_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__weapon_story_linkClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    weapon<T extends weaponArgs = {}>(args?: Subset<T, weaponArgs>): CheckSelect<T, Prisma__weaponClient<weapon | null >, Prisma__weaponClient<weaponGetPayload<T> | null >>;

    weapon_story<T extends weapon_storyArgs = {}>(args?: Subset<T, weapon_storyArgs>): CheckSelect<T, Prisma__weapon_storyClient<weapon_story | null >, Prisma__weapon_storyClient<weapon_storyGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * weapon_story_link findUnique
   */
  export type weapon_story_linkFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the weapon_story_link
     * 
    **/
    select?: weapon_story_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_story_linkInclude | null
    /**
     * Throw an Error if a weapon_story_link can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weapon_story_link to fetch.
     * 
    **/
    where: weapon_story_linkWhereUniqueInput
  }


  /**
   * weapon_story_link findFirst
   */
  export type weapon_story_linkFindFirstArgs = {
    /**
     * Select specific fields to fetch from the weapon_story_link
     * 
    **/
    select?: weapon_story_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_story_linkInclude | null
    /**
     * Throw an Error if a weapon_story_link can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which weapon_story_link to fetch.
     * 
    **/
    where?: weapon_story_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_story_links to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_story_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for weapon_story_links.
     * 
    **/
    cursor?: weapon_story_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_story_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_story_links.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of weapon_story_links.
     * 
    **/
    distinct?: Enumerable<Weapon_story_linkScalarFieldEnum>
  }


  /**
   * weapon_story_link findMany
   */
  export type weapon_story_linkFindManyArgs = {
    /**
     * Select specific fields to fetch from the weapon_story_link
     * 
    **/
    select?: weapon_story_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_story_linkInclude | null
    /**
     * Filter, which weapon_story_links to fetch.
     * 
    **/
    where?: weapon_story_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of weapon_story_links to fetch.
     * 
    **/
    orderBy?: Enumerable<weapon_story_linkOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing weapon_story_links.
     * 
    **/
    cursor?: weapon_story_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` weapon_story_links from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` weapon_story_links.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Weapon_story_linkScalarFieldEnum>
  }


  /**
   * weapon_story_link create
   */
  export type weapon_story_linkCreateArgs = {
    /**
     * Select specific fields to fetch from the weapon_story_link
     * 
    **/
    select?: weapon_story_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_story_linkInclude | null
    /**
     * The data needed to create a weapon_story_link.
     * 
    **/
    data: XOR<weapon_story_linkCreateInput, weapon_story_linkUncheckedCreateInput>
  }


  /**
   * weapon_story_link createMany
   */
  export type weapon_story_linkCreateManyArgs = {
    /**
     * The data used to create many weapon_story_links.
     * 
    **/
    data: Enumerable<weapon_story_linkCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * weapon_story_link update
   */
  export type weapon_story_linkUpdateArgs = {
    /**
     * Select specific fields to fetch from the weapon_story_link
     * 
    **/
    select?: weapon_story_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_story_linkInclude | null
    /**
     * The data needed to update a weapon_story_link.
     * 
    **/
    data: XOR<weapon_story_linkUpdateInput, weapon_story_linkUncheckedUpdateInput>
    /**
     * Choose, which weapon_story_link to update.
     * 
    **/
    where: weapon_story_linkWhereUniqueInput
  }


  /**
   * weapon_story_link updateMany
   */
  export type weapon_story_linkUpdateManyArgs = {
    /**
     * The data used to update weapon_story_links.
     * 
    **/
    data: XOR<weapon_story_linkUpdateManyMutationInput, weapon_story_linkUncheckedUpdateManyInput>
    /**
     * Filter which weapon_story_links to update
     * 
    **/
    where?: weapon_story_linkWhereInput
  }


  /**
   * weapon_story_link upsert
   */
  export type weapon_story_linkUpsertArgs = {
    /**
     * Select specific fields to fetch from the weapon_story_link
     * 
    **/
    select?: weapon_story_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_story_linkInclude | null
    /**
     * The filter to search for the weapon_story_link to update in case it exists.
     * 
    **/
    where: weapon_story_linkWhereUniqueInput
    /**
     * In case the weapon_story_link found by the `where` argument doesn't exist, create a new weapon_story_link with this data.
     * 
    **/
    create: XOR<weapon_story_linkCreateInput, weapon_story_linkUncheckedCreateInput>
    /**
     * In case the weapon_story_link was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<weapon_story_linkUpdateInput, weapon_story_linkUncheckedUpdateInput>
  }


  /**
   * weapon_story_link delete
   */
  export type weapon_story_linkDeleteArgs = {
    /**
     * Select specific fields to fetch from the weapon_story_link
     * 
    **/
    select?: weapon_story_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_story_linkInclude | null
    /**
     * Filter which weapon_story_link to delete.
     * 
    **/
    where: weapon_story_linkWhereUniqueInput
  }


  /**
   * weapon_story_link deleteMany
   */
  export type weapon_story_linkDeleteManyArgs = {
    /**
     * Filter which weapon_story_links to delete
     * 
    **/
    where?: weapon_story_linkWhereInput
  }


  /**
   * weapon_story_link without action
   */
  export type weapon_story_linkArgs = {
    /**
     * Select specific fields to fetch from the weapon_story_link
     * 
    **/
    select?: weapon_story_linkSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: weapon_story_linkInclude | null
  }



  /**
   * Model debris
   */


  export type AggregateDebris = {
    _count: DebrisCountAggregateOutputType | null
    _avg: DebrisAvgAggregateOutputType | null
    _sum: DebrisSumAggregateOutputType | null
    _min: DebrisMinAggregateOutputType | null
    _max: DebrisMaxAggregateOutputType | null
  }

  export type DebrisAvgAggregateOutputType = {
    debris_id: number | null
    rarity: number | null
  }

  export type DebrisSumAggregateOutputType = {
    debris_id: number | null
    rarity: number | null
  }

  export type DebrisMinAggregateOutputType = {
    debris_id: number | null
    rarity: number | null
    release_time: Date | null
    name: string | null
    image_path_base: string | null
  }

  export type DebrisMaxAggregateOutputType = {
    debris_id: number | null
    rarity: number | null
    release_time: Date | null
    name: string | null
    image_path_base: string | null
  }

  export type DebrisCountAggregateOutputType = {
    debris_id: number
    rarity: number
    release_time: number
    name: number
    image_path_base: number
    _all: number
  }


  export type DebrisAvgAggregateInputType = {
    debris_id?: true
    rarity?: true
  }

  export type DebrisSumAggregateInputType = {
    debris_id?: true
    rarity?: true
  }

  export type DebrisMinAggregateInputType = {
    debris_id?: true
    rarity?: true
    release_time?: true
    name?: true
    image_path_base?: true
  }

  export type DebrisMaxAggregateInputType = {
    debris_id?: true
    rarity?: true
    release_time?: true
    name?: true
    image_path_base?: true
  }

  export type DebrisCountAggregateInputType = {
    debris_id?: true
    rarity?: true
    release_time?: true
    name?: true
    image_path_base?: true
    _all?: true
  }

  export type DebrisAggregateArgs = {
    /**
     * Filter which debris to aggregate.
     * 
    **/
    where?: debrisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of debris to fetch.
     * 
    **/
    orderBy?: Enumerable<debrisOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: debrisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` debris from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` debris.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned debris
    **/
    _count?: true | DebrisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DebrisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DebrisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DebrisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DebrisMaxAggregateInputType
  }

  export type GetDebrisAggregateType<T extends DebrisAggregateArgs> = {
        [P in keyof T & keyof AggregateDebris]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDebris[P]>
      : GetScalarType<T[P], AggregateDebris[P]>
  }




  export type DebrisGroupByArgs = {
    where?: debrisWhereInput
    orderBy?: Enumerable<debrisOrderByWithAggregationInput>
    by: Array<DebrisScalarFieldEnum>
    having?: debrisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DebrisCountAggregateInputType | true
    _avg?: DebrisAvgAggregateInputType
    _sum?: DebrisSumAggregateInputType
    _min?: DebrisMinAggregateInputType
    _max?: DebrisMaxAggregateInputType
  }


  export type DebrisGroupByOutputType = {
    debris_id: number
    rarity: number
    release_time: Date
    name: string | null
    image_path_base: string | null
    _count: DebrisCountAggregateOutputType | null
    _avg: DebrisAvgAggregateOutputType | null
    _sum: DebrisSumAggregateOutputType | null
    _min: DebrisMinAggregateOutputType | null
    _max: DebrisMaxAggregateOutputType | null
  }

  type GetDebrisGroupByPayload<T extends DebrisGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DebrisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DebrisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DebrisGroupByOutputType[P]>
            : GetScalarType<T[P], DebrisGroupByOutputType[P]>
        }
      >
    >


  export type debrisSelect = {
    debris_id?: boolean
    rarity?: boolean
    release_time?: boolean
    name?: boolean
    image_path_base?: boolean
  }

  export type debrisGetPayload<
    S extends boolean | null | undefined | debrisArgs,
    U = keyof S
      > = S extends true
        ? debris
    : S extends undefined
    ? never
    : S extends debrisArgs | debrisFindManyArgs
    ?'include' extends U
    ? debris 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof debris ? debris[P] : never
  } 
    : debris
  : debris


  type debrisCountArgs = Merge<
    Omit<debrisFindManyArgs, 'select' | 'include'> & {
      select?: DebrisCountAggregateInputType | true
    }
  >

  export interface debrisDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Debris that matches the filter.
     * @param {debrisFindUniqueArgs} args - Arguments to find a Debris
     * @example
     * // Get one Debris
     * const debris = await prisma.debris.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends debrisFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, debrisFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'debris'> extends True ? CheckSelect<T, Prisma__debrisClient<debris>, Prisma__debrisClient<debrisGetPayload<T>>> : CheckSelect<T, Prisma__debrisClient<debris | null >, Prisma__debrisClient<debrisGetPayload<T> | null >>

    /**
     * Find the first Debris that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debrisFindFirstArgs} args - Arguments to find a Debris
     * @example
     * // Get one Debris
     * const debris = await prisma.debris.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends debrisFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, debrisFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'debris'> extends True ? CheckSelect<T, Prisma__debrisClient<debris>, Prisma__debrisClient<debrisGetPayload<T>>> : CheckSelect<T, Prisma__debrisClient<debris | null >, Prisma__debrisClient<debrisGetPayload<T> | null >>

    /**
     * Find zero or more Debris that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debrisFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Debris
     * const debris = await prisma.debris.findMany()
     * 
     * // Get first 10 Debris
     * const debris = await prisma.debris.findMany({ take: 10 })
     * 
     * // Only select the `debris_id`
     * const debrisWithDebris_idOnly = await prisma.debris.findMany({ select: { debris_id: true } })
     * 
    **/
    findMany<T extends debrisFindManyArgs>(
      args?: SelectSubset<T, debrisFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<debris>>, PrismaPromise<Array<debrisGetPayload<T>>>>

    /**
     * Create a Debris.
     * @param {debrisCreateArgs} args - Arguments to create a Debris.
     * @example
     * // Create one Debris
     * const Debris = await prisma.debris.create({
     *   data: {
     *     // ... data to create a Debris
     *   }
     * })
     * 
    **/
    create<T extends debrisCreateArgs>(
      args: SelectSubset<T, debrisCreateArgs>
    ): CheckSelect<T, Prisma__debrisClient<debris>, Prisma__debrisClient<debrisGetPayload<T>>>

    /**
     * Create many Debris.
     *     @param {debrisCreateManyArgs} args - Arguments to create many Debris.
     *     @example
     *     // Create many Debris
     *     const debris = await prisma.debris.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends debrisCreateManyArgs>(
      args?: SelectSubset<T, debrisCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Debris.
     * @param {debrisDeleteArgs} args - Arguments to delete one Debris.
     * @example
     * // Delete one Debris
     * const Debris = await prisma.debris.delete({
     *   where: {
     *     // ... filter to delete one Debris
     *   }
     * })
     * 
    **/
    delete<T extends debrisDeleteArgs>(
      args: SelectSubset<T, debrisDeleteArgs>
    ): CheckSelect<T, Prisma__debrisClient<debris>, Prisma__debrisClient<debrisGetPayload<T>>>

    /**
     * Update one Debris.
     * @param {debrisUpdateArgs} args - Arguments to update one Debris.
     * @example
     * // Update one Debris
     * const debris = await prisma.debris.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends debrisUpdateArgs>(
      args: SelectSubset<T, debrisUpdateArgs>
    ): CheckSelect<T, Prisma__debrisClient<debris>, Prisma__debrisClient<debrisGetPayload<T>>>

    /**
     * Delete zero or more Debris.
     * @param {debrisDeleteManyArgs} args - Arguments to filter Debris to delete.
     * @example
     * // Delete a few Debris
     * const { count } = await prisma.debris.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends debrisDeleteManyArgs>(
      args?: SelectSubset<T, debrisDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Debris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debrisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Debris
     * const debris = await prisma.debris.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends debrisUpdateManyArgs>(
      args: SelectSubset<T, debrisUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Debris.
     * @param {debrisUpsertArgs} args - Arguments to update or create a Debris.
     * @example
     * // Update or create a Debris
     * const debris = await prisma.debris.upsert({
     *   create: {
     *     // ... data to create a Debris
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Debris we want to update
     *   }
     * })
    **/
    upsert<T extends debrisUpsertArgs>(
      args: SelectSubset<T, debrisUpsertArgs>
    ): CheckSelect<T, Prisma__debrisClient<debris>, Prisma__debrisClient<debrisGetPayload<T>>>

    /**
     * Count the number of Debris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {debrisCountArgs} args - Arguments to filter Debris to count.
     * @example
     * // Count the number of Debris
     * const count = await prisma.debris.count({
     *   where: {
     *     // ... the filter for the Debris we want to count
     *   }
     * })
    **/
    count<T extends debrisCountArgs>(
      args?: Subset<T, debrisCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DebrisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Debris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebrisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DebrisAggregateArgs>(args: Subset<T, DebrisAggregateArgs>): PrismaPromise<GetDebrisAggregateType<T>>

    /**
     * Group by Debris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DebrisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DebrisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DebrisGroupByArgs['orderBy'] }
        : { orderBy?: DebrisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DebrisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDebrisGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for debris.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__debrisClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * debris findUnique
   */
  export type debrisFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the debris
     * 
    **/
    select?: debrisSelect | null
    /**
     * Throw an Error if a debris can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which debris to fetch.
     * 
    **/
    where: debrisWhereUniqueInput
  }


  /**
   * debris findFirst
   */
  export type debrisFindFirstArgs = {
    /**
     * Select specific fields to fetch from the debris
     * 
    **/
    select?: debrisSelect | null
    /**
     * Throw an Error if a debris can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which debris to fetch.
     * 
    **/
    where?: debrisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of debris to fetch.
     * 
    **/
    orderBy?: Enumerable<debrisOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for debris.
     * 
    **/
    cursor?: debrisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` debris from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` debris.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of debris.
     * 
    **/
    distinct?: Enumerable<DebrisScalarFieldEnum>
  }


  /**
   * debris findMany
   */
  export type debrisFindManyArgs = {
    /**
     * Select specific fields to fetch from the debris
     * 
    **/
    select?: debrisSelect | null
    /**
     * Filter, which debris to fetch.
     * 
    **/
    where?: debrisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of debris to fetch.
     * 
    **/
    orderBy?: Enumerable<debrisOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing debris.
     * 
    **/
    cursor?: debrisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` debris from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` debris.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DebrisScalarFieldEnum>
  }


  /**
   * debris create
   */
  export type debrisCreateArgs = {
    /**
     * Select specific fields to fetch from the debris
     * 
    **/
    select?: debrisSelect | null
    /**
     * The data needed to create a debris.
     * 
    **/
    data: XOR<debrisCreateInput, debrisUncheckedCreateInput>
  }


  /**
   * debris createMany
   */
  export type debrisCreateManyArgs = {
    /**
     * The data used to create many debris.
     * 
    **/
    data: Enumerable<debrisCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * debris update
   */
  export type debrisUpdateArgs = {
    /**
     * Select specific fields to fetch from the debris
     * 
    **/
    select?: debrisSelect | null
    /**
     * The data needed to update a debris.
     * 
    **/
    data: XOR<debrisUpdateInput, debrisUncheckedUpdateInput>
    /**
     * Choose, which debris to update.
     * 
    **/
    where: debrisWhereUniqueInput
  }


  /**
   * debris updateMany
   */
  export type debrisUpdateManyArgs = {
    /**
     * The data used to update debris.
     * 
    **/
    data: XOR<debrisUpdateManyMutationInput, debrisUncheckedUpdateManyInput>
    /**
     * Filter which debris to update
     * 
    **/
    where?: debrisWhereInput
  }


  /**
   * debris upsert
   */
  export type debrisUpsertArgs = {
    /**
     * Select specific fields to fetch from the debris
     * 
    **/
    select?: debrisSelect | null
    /**
     * The filter to search for the debris to update in case it exists.
     * 
    **/
    where: debrisWhereUniqueInput
    /**
     * In case the debris found by the `where` argument doesn't exist, create a new debris with this data.
     * 
    **/
    create: XOR<debrisCreateInput, debrisUncheckedCreateInput>
    /**
     * In case the debris was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<debrisUpdateInput, debrisUncheckedUpdateInput>
  }


  /**
   * debris delete
   */
  export type debrisDeleteArgs = {
    /**
     * Select specific fields to fetch from the debris
     * 
    **/
    select?: debrisSelect | null
    /**
     * Filter which debris to delete.
     * 
    **/
    where: debrisWhereUniqueInput
  }


  /**
   * debris deleteMany
   */
  export type debrisDeleteManyArgs = {
    /**
     * Filter which debris to delete
     * 
    **/
    where?: debrisWhereInput
  }


  /**
   * debris without action
   */
  export type debrisArgs = {
    /**
     * Select specific fields to fetch from the debris
     * 
    **/
    select?: debrisSelect | null
  }



  /**
   * Model notification
   */


  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    notification_id: number | null
  }

  export type NotificationSumAggregateOutputType = {
    notification_id: number | null
  }

  export type NotificationMinAggregateOutputType = {
    notification_id: number | null
    information_type: string | null
    title: string | null
    body: string | null
    release_time: Date | null
    thumbnail_path: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    notification_id: number | null
    information_type: string | null
    title: string | null
    body: string | null
    release_time: Date | null
    thumbnail_path: string | null
  }

  export type NotificationCountAggregateOutputType = {
    notification_id: number
    information_type: number
    title: number
    body: number
    release_time: number
    thumbnail_path: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    notification_id?: true
  }

  export type NotificationSumAggregateInputType = {
    notification_id?: true
  }

  export type NotificationMinAggregateInputType = {
    notification_id?: true
    information_type?: true
    title?: true
    body?: true
    release_time?: true
    thumbnail_path?: true
  }

  export type NotificationMaxAggregateInputType = {
    notification_id?: true
    information_type?: true
    title?: true
    body?: true
    release_time?: true
    thumbnail_path?: true
  }

  export type NotificationCountAggregateInputType = {
    notification_id?: true
    information_type?: true
    title?: true
    body?: true
    release_time?: true
    thumbnail_path?: true
    _all?: true
  }

  export type NotificationAggregateArgs = {
    /**
     * Filter which notification to aggregate.
     * 
    **/
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<notificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs = {
    where?: notificationWhereInput
    orderBy?: Enumerable<notificationOrderByWithAggregationInput>
    by: Array<NotificationScalarFieldEnum>
    having?: notificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }


  export type NotificationGroupByOutputType = {
    notification_id: number
    information_type: string | null
    title: string | null
    body: string | null
    release_time: Date | null
    thumbnail_path: string | null
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type notificationSelect = {
    notification_id?: boolean
    information_type?: boolean
    title?: boolean
    body?: boolean
    release_time?: boolean
    thumbnail_path?: boolean
  }

  export type notificationGetPayload<
    S extends boolean | null | undefined | notificationArgs,
    U = keyof S
      > = S extends true
        ? notification
    : S extends undefined
    ? never
    : S extends notificationArgs | notificationFindManyArgs
    ?'include' extends U
    ? notification 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof notification ? notification[P] : never
  } 
    : notification
  : notification


  type notificationCountArgs = Merge<
    Omit<notificationFindManyArgs, 'select' | 'include'> & {
      select?: NotificationCountAggregateInputType | true
    }
  >

  export interface notificationDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Notification that matches the filter.
     * @param {notificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends notificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, notificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'notification'> extends True ? CheckSelect<T, Prisma__notificationClient<notification>, Prisma__notificationClient<notificationGetPayload<T>>> : CheckSelect<T, Prisma__notificationClient<notification | null >, Prisma__notificationClient<notificationGetPayload<T> | null >>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends notificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, notificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'notification'> extends True ? CheckSelect<T, Prisma__notificationClient<notification>, Prisma__notificationClient<notificationGetPayload<T>>> : CheckSelect<T, Prisma__notificationClient<notification | null >, Prisma__notificationClient<notificationGetPayload<T> | null >>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `notification_id`
     * const notificationWithNotification_idOnly = await prisma.notification.findMany({ select: { notification_id: true } })
     * 
    **/
    findMany<T extends notificationFindManyArgs>(
      args?: SelectSubset<T, notificationFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<notification>>, PrismaPromise<Array<notificationGetPayload<T>>>>

    /**
     * Create a Notification.
     * @param {notificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends notificationCreateArgs>(
      args: SelectSubset<T, notificationCreateArgs>
    ): CheckSelect<T, Prisma__notificationClient<notification>, Prisma__notificationClient<notificationGetPayload<T>>>

    /**
     * Create many Notifications.
     *     @param {notificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends notificationCreateManyArgs>(
      args?: SelectSubset<T, notificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {notificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends notificationDeleteArgs>(
      args: SelectSubset<T, notificationDeleteArgs>
    ): CheckSelect<T, Prisma__notificationClient<notification>, Prisma__notificationClient<notificationGetPayload<T>>>

    /**
     * Update one Notification.
     * @param {notificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends notificationUpdateArgs>(
      args: SelectSubset<T, notificationUpdateArgs>
    ): CheckSelect<T, Prisma__notificationClient<notification>, Prisma__notificationClient<notificationGetPayload<T>>>

    /**
     * Delete zero or more Notifications.
     * @param {notificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends notificationDeleteManyArgs>(
      args?: SelectSubset<T, notificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends notificationUpdateManyArgs>(
      args: SelectSubset<T, notificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {notificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends notificationUpsertArgs>(
      args: SelectSubset<T, notificationUpsertArgs>
    ): CheckSelect<T, Prisma__notificationClient<notification>, Prisma__notificationClient<notificationGetPayload<T>>>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationCountArgs>(
      args?: Subset<T, notificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__notificationClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * notification findUnique
   */
  export type notificationFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the notification
     * 
    **/
    select?: notificationSelect | null
    /**
     * Throw an Error if a notification can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which notification to fetch.
     * 
    **/
    where: notificationWhereUniqueInput
  }


  /**
   * notification findFirst
   */
  export type notificationFindFirstArgs = {
    /**
     * Select specific fields to fetch from the notification
     * 
    **/
    select?: notificationSelect | null
    /**
     * Throw an Error if a notification can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which notification to fetch.
     * 
    **/
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<notificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     * 
    **/
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     * 
    **/
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * notification findMany
   */
  export type notificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the notification
     * 
    **/
    select?: notificationSelect | null
    /**
     * Filter, which notifications to fetch.
     * 
    **/
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<notificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     * 
    **/
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * notification create
   */
  export type notificationCreateArgs = {
    /**
     * Select specific fields to fetch from the notification
     * 
    **/
    select?: notificationSelect | null
    /**
     * The data needed to create a notification.
     * 
    **/
    data: XOR<notificationCreateInput, notificationUncheckedCreateInput>
  }


  /**
   * notification createMany
   */
  export type notificationCreateManyArgs = {
    /**
     * The data used to create many notifications.
     * 
    **/
    data: Enumerable<notificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * notification update
   */
  export type notificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the notification
     * 
    **/
    select?: notificationSelect | null
    /**
     * The data needed to update a notification.
     * 
    **/
    data: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
    /**
     * Choose, which notification to update.
     * 
    **/
    where: notificationWhereUniqueInput
  }


  /**
   * notification updateMany
   */
  export type notificationUpdateManyArgs = {
    /**
     * The data used to update notifications.
     * 
    **/
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     * 
    **/
    where?: notificationWhereInput
  }


  /**
   * notification upsert
   */
  export type notificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the notification
     * 
    **/
    select?: notificationSelect | null
    /**
     * The filter to search for the notification to update in case it exists.
     * 
    **/
    where: notificationWhereUniqueInput
    /**
     * In case the notification found by the `where` argument doesn't exist, create a new notification with this data.
     * 
    **/
    create: XOR<notificationCreateInput, notificationUncheckedCreateInput>
    /**
     * In case the notification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
  }


  /**
   * notification delete
   */
  export type notificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the notification
     * 
    **/
    select?: notificationSelect | null
    /**
     * Filter which notification to delete.
     * 
    **/
    where: notificationWhereUniqueInput
  }


  /**
   * notification deleteMany
   */
  export type notificationDeleteManyArgs = {
    /**
     * Filter which notifications to delete
     * 
    **/
    where?: notificationWhereInput
  }


  /**
   * notification without action
   */
  export type notificationArgs = {
    /**
     * Select specific fields to fetch from the notification
     * 
    **/
    select?: notificationSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const CharacterScalarFieldEnum: {
    character_id: 'character_id',
    slug: 'slug',
    name: 'name',
    image_path: 'image_path'
  };

  export type CharacterScalarFieldEnum = (typeof CharacterScalarFieldEnum)[keyof typeof CharacterScalarFieldEnum]


  export const Character_rank_bonusScalarFieldEnum: {
    rank_bonus_id: 'rank_bonus_id',
    rank_bonus_level: 'rank_bonus_level',
    character_id: 'character_id',
    description: 'description',
    stat: 'stat',
    type: 'type',
    amount: 'amount'
  };

  export type Character_rank_bonusScalarFieldEnum = (typeof Character_rank_bonusScalarFieldEnum)[keyof typeof Character_rank_bonusScalarFieldEnum]


  export const CompanionScalarFieldEnum: {
    companion_id: 'companion_id',
    attribute: 'attribute',
    type: 'type',
    release_time: 'release_time',
    name: 'name',
    story: 'story',
    image_path_base: 'image_path_base'
  };

  export type CompanionScalarFieldEnum = (typeof CompanionScalarFieldEnum)[keyof typeof CompanionScalarFieldEnum]


  export const Companion_abilityScalarFieldEnum: {
    ability_id: 'ability_id',
    ability_level: 'ability_level',
    name: 'name',
    description: 'description',
    image_path_base: 'image_path_base'
  };

  export type Companion_abilityScalarFieldEnum = (typeof Companion_abilityScalarFieldEnum)[keyof typeof Companion_abilityScalarFieldEnum]


  export const Companion_ability_linkScalarFieldEnum: {
    companion_id: 'companion_id',
    companion_level: 'companion_level',
    ability_id: 'ability_id',
    ability_level: 'ability_level'
  };

  export type Companion_ability_linkScalarFieldEnum = (typeof Companion_ability_linkScalarFieldEnum)[keyof typeof Companion_ability_linkScalarFieldEnum]


  export const Companion_skillScalarFieldEnum: {
    skill_id: 'skill_id',
    skill_level: 'skill_level',
    cooldown_time: 'cooldown_time',
    name: 'name',
    description: 'description',
    short_description: 'short_description',
    image_path: 'image_path'
  };

  export type Companion_skillScalarFieldEnum = (typeof Companion_skillScalarFieldEnum)[keyof typeof Companion_skillScalarFieldEnum]


  export const Companion_skill_linkScalarFieldEnum: {
    companion_id: 'companion_id',
    companion_level: 'companion_level',
    skill_id: 'skill_id',
    skill_level: 'skill_level'
  };

  export type Companion_skill_linkScalarFieldEnum = (typeof Companion_skill_linkScalarFieldEnum)[keyof typeof Companion_skill_linkScalarFieldEnum]


  export const Companion_statScalarFieldEnum: {
    companion_id: 'companion_id',
    level: 'level',
    atk: 'atk',
    hp: 'hp',
    vit: 'vit'
  };

  export type Companion_statScalarFieldEnum = (typeof Companion_statScalarFieldEnum)[keyof typeof Companion_statScalarFieldEnum]


  export const CostumeScalarFieldEnum: {
    costume_id: 'costume_id',
    character_id: 'character_id',
    emblem_id: 'emblem_id',
    weapon_type: 'weapon_type',
    rarity: 'rarity',
    release_time: 'release_time',
    is_ex_costume: 'is_ex_costume',
    slug: 'slug',
    title: 'title',
    description: 'description',
    image_path_base: 'image_path_base'
  };

  export type CostumeScalarFieldEnum = (typeof CostumeScalarFieldEnum)[keyof typeof CostumeScalarFieldEnum]


  export const Costume_abilityScalarFieldEnum: {
    ability_id: 'ability_id',
    ability_level: 'ability_level',
    name: 'name',
    description: 'description',
    image_path_base: 'image_path_base'
  };

  export type Costume_abilityScalarFieldEnum = (typeof Costume_abilityScalarFieldEnum)[keyof typeof Costume_abilityScalarFieldEnum]


  export const Costume_ability_linkScalarFieldEnum: {
    costume_id: 'costume_id',
    ability_slot: 'ability_slot',
    ability_id: 'ability_id',
    ability_level: 'ability_level'
  };

  export type Costume_ability_linkScalarFieldEnum = (typeof Costume_ability_linkScalarFieldEnum)[keyof typeof Costume_ability_linkScalarFieldEnum]


  export const Costume_skillScalarFieldEnum: {
    skill_id: 'skill_id',
    skill_level: 'skill_level',
    gauge_rise_speed: 'gauge_rise_speed',
    cooldown_time: 'cooldown_time',
    name: 'name',
    description: 'description',
    short_description: 'short_description',
    image_path: 'image_path'
  };

  export type Costume_skillScalarFieldEnum = (typeof Costume_skillScalarFieldEnum)[keyof typeof Costume_skillScalarFieldEnum]


  export const Costume_skill_linkScalarFieldEnum: {
    costume_id: 'costume_id',
    skill_id: 'skill_id',
    skill_level: 'skill_level'
  };

  export type Costume_skill_linkScalarFieldEnum = (typeof Costume_skill_linkScalarFieldEnum)[keyof typeof Costume_skill_linkScalarFieldEnum]


  export const Costume_statScalarFieldEnum: {
    costume_id: 'costume_id',
    level: 'level',
    agi: 'agi',
    atk: 'atk',
    crit_atk: 'crit_atk',
    crit_rate: 'crit_rate',
    eva_rate: 'eva_rate',
    hp: 'hp',
    vit: 'vit'
  };

  export type Costume_statScalarFieldEnum = (typeof Costume_statScalarFieldEnum)[keyof typeof Costume_statScalarFieldEnum]


  export const EmblemScalarFieldEnum: {
    emblem_id: 'emblem_id',
    name: 'name',
    main_message: 'main_message',
    small_messages: 'small_messages',
    image_path: 'image_path'
  };

  export type EmblemScalarFieldEnum = (typeof EmblemScalarFieldEnum)[keyof typeof EmblemScalarFieldEnum]


  export const MemoirScalarFieldEnum: {
    memoir_id: 'memoir_id',
    lottery_id: 'lottery_id',
    rarity: 'rarity',
    release_time: 'release_time',
    name: 'name',
    story: 'story',
    image_path_base: 'image_path_base',
    memoir_series_id: 'memoir_series_id'
  };

  export type MemoirScalarFieldEnum = (typeof MemoirScalarFieldEnum)[keyof typeof MemoirScalarFieldEnum]


  export const Memoir_seriesScalarFieldEnum: {
    memoir_series_id: 'memoir_series_id',
    name: 'name',
    small_set_description: 'small_set_description',
    large_set_description: 'large_set_description'
  };

  export type Memoir_seriesScalarFieldEnum = (typeof Memoir_seriesScalarFieldEnum)[keyof typeof Memoir_seriesScalarFieldEnum]


  export const WeaponScalarFieldEnum: {
    weapon_id: 'weapon_id',
    evolution_group_id: 'evolution_group_id',
    evolution_order: 'evolution_order',
    weapon_type: 'weapon_type',
    rarity: 'rarity',
    attribute: 'attribute',
    is_ex_weapon: 'is_ex_weapon',
    release_time: 'release_time',
    slug: 'slug',
    name: 'name',
    image_path: 'image_path'
  };

  export type WeaponScalarFieldEnum = (typeof WeaponScalarFieldEnum)[keyof typeof WeaponScalarFieldEnum]


  export const Weapon_abilityScalarFieldEnum: {
    ability_id: 'ability_id',
    ability_level: 'ability_level',
    name: 'name',
    description: 'description',
    image_path_base: 'image_path_base'
  };

  export type Weapon_abilityScalarFieldEnum = (typeof Weapon_abilityScalarFieldEnum)[keyof typeof Weapon_abilityScalarFieldEnum]


  export const Weapon_ability_linkScalarFieldEnum: {
    weapon_id: 'weapon_id',
    slot_number: 'slot_number',
    ability_id: 'ability_id',
    ability_level: 'ability_level'
  };

  export type Weapon_ability_linkScalarFieldEnum = (typeof Weapon_ability_linkScalarFieldEnum)[keyof typeof Weapon_ability_linkScalarFieldEnum]


  export const Weapon_skillScalarFieldEnum: {
    skill_id: 'skill_id',
    skill_level: 'skill_level',
    cooldown_time: 'cooldown_time',
    name: 'name',
    description: 'description',
    short_description: 'short_description',
    image_path: 'image_path'
  };

  export type Weapon_skillScalarFieldEnum = (typeof Weapon_skillScalarFieldEnum)[keyof typeof Weapon_skillScalarFieldEnum]


  export const Weapon_skill_linkScalarFieldEnum: {
    weapon_id: 'weapon_id',
    slot_number: 'slot_number',
    skill_id: 'skill_id',
    skill_level: 'skill_level'
  };

  export type Weapon_skill_linkScalarFieldEnum = (typeof Weapon_skill_linkScalarFieldEnum)[keyof typeof Weapon_skill_linkScalarFieldEnum]


  export const Weapon_statScalarFieldEnum: {
    weapon_id: 'weapon_id',
    level: 'level',
    atk: 'atk',
    hp: 'hp',
    vit: 'vit'
  };

  export type Weapon_statScalarFieldEnum = (typeof Weapon_statScalarFieldEnum)[keyof typeof Weapon_statScalarFieldEnum]


  export const Weapon_storyScalarFieldEnum: {
    id: 'id',
    story: 'story'
  };

  export type Weapon_storyScalarFieldEnum = (typeof Weapon_storyScalarFieldEnum)[keyof typeof Weapon_storyScalarFieldEnum]


  export const Weapon_story_linkScalarFieldEnum: {
    weapon_id: 'weapon_id',
    weapon_story_id: 'weapon_story_id'
  };

  export type Weapon_story_linkScalarFieldEnum = (typeof Weapon_story_linkScalarFieldEnum)[keyof typeof Weapon_story_linkScalarFieldEnum]


  export const DebrisScalarFieldEnum: {
    debris_id: 'debris_id',
    rarity: 'rarity',
    release_time: 'release_time',
    name: 'name',
    image_path_base: 'image_path_base'
  };

  export type DebrisScalarFieldEnum = (typeof DebrisScalarFieldEnum)[keyof typeof DebrisScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    notification_id: 'notification_id',
    information_type: 'information_type',
    title: 'title',
    body: 'body',
    release_time: 'release_time',
    thumbnail_path: 'thumbnail_path'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type characterWhereInput = {
    AND?: Enumerable<characterWhereInput>
    OR?: Enumerable<characterWhereInput>
    NOT?: Enumerable<characterWhereInput>
    character_id?: IntFilter | number
    slug?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    image_path?: StringNullableFilter | string | null
    character_rank_bonus?: Character_rank_bonusListRelationFilter
    costume?: CostumeListRelationFilter
  }

  export type characterOrderByWithRelationInput = {
    character_id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    image_path?: SortOrder
    character_rank_bonus?: character_rank_bonusOrderByRelationAggregateInput
    costume?: costumeOrderByRelationAggregateInput
  }

  export type characterWhereUniqueInput = {
    character_id?: number
  }

  export type characterOrderByWithAggregationInput = {
    character_id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    image_path?: SortOrder
    _count?: characterCountOrderByAggregateInput
    _avg?: characterAvgOrderByAggregateInput
    _max?: characterMaxOrderByAggregateInput
    _min?: characterMinOrderByAggregateInput
    _sum?: characterSumOrderByAggregateInput
  }

  export type characterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<characterScalarWhereWithAggregatesInput>
    OR?: Enumerable<characterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<characterScalarWhereWithAggregatesInput>
    character_id?: IntWithAggregatesFilter | number
    slug?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    image_path?: StringNullableWithAggregatesFilter | string | null
  }

  export type character_rank_bonusWhereInput = {
    AND?: Enumerable<character_rank_bonusWhereInput>
    OR?: Enumerable<character_rank_bonusWhereInput>
    NOT?: Enumerable<character_rank_bonusWhereInput>
    rank_bonus_id?: IntFilter | number
    rank_bonus_level?: IntFilter | number
    character_id?: IntFilter | number
    description?: StringNullableFilter | string | null
    stat?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    amount?: IntFilter | number
    character?: XOR<CharacterRelationFilter, characterWhereInput>
  }

  export type character_rank_bonusOrderByWithRelationInput = {
    rank_bonus_id?: SortOrder
    rank_bonus_level?: SortOrder
    character_id?: SortOrder
    description?: SortOrder
    stat?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    character?: characterOrderByWithRelationInput
  }

  export type character_rank_bonusWhereUniqueInput = {
    rank_bonus_id_rank_bonus_level?: character_rank_bonusRank_bonus_idRank_bonus_levelCompoundUniqueInput
  }

  export type character_rank_bonusOrderByWithAggregationInput = {
    rank_bonus_id?: SortOrder
    rank_bonus_level?: SortOrder
    character_id?: SortOrder
    description?: SortOrder
    stat?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    _count?: character_rank_bonusCountOrderByAggregateInput
    _avg?: character_rank_bonusAvgOrderByAggregateInput
    _max?: character_rank_bonusMaxOrderByAggregateInput
    _min?: character_rank_bonusMinOrderByAggregateInput
    _sum?: character_rank_bonusSumOrderByAggregateInput
  }

  export type character_rank_bonusScalarWhereWithAggregatesInput = {
    AND?: Enumerable<character_rank_bonusScalarWhereWithAggregatesInput>
    OR?: Enumerable<character_rank_bonusScalarWhereWithAggregatesInput>
    NOT?: Enumerable<character_rank_bonusScalarWhereWithAggregatesInput>
    rank_bonus_id?: IntWithAggregatesFilter | number
    rank_bonus_level?: IntWithAggregatesFilter | number
    character_id?: IntWithAggregatesFilter | number
    description?: StringNullableWithAggregatesFilter | string | null
    stat?: StringNullableWithAggregatesFilter | string | null
    type?: StringNullableWithAggregatesFilter | string | null
    amount?: IntWithAggregatesFilter | number
  }

  export type companionWhereInput = {
    AND?: Enumerable<companionWhereInput>
    OR?: Enumerable<companionWhereInput>
    NOT?: Enumerable<companionWhereInput>
    companion_id?: IntFilter | number
    attribute?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    release_time?: DateTimeFilter | Date | string
    name?: StringNullableFilter | string | null
    story?: StringNullableFilter | string | null
    image_path_base?: StringNullableFilter | string | null
    companion_ability_link?: Companion_ability_linkListRelationFilter
    companion_skill_link?: Companion_skill_linkListRelationFilter
    companion_stat?: Companion_statListRelationFilter
  }

  export type companionOrderByWithRelationInput = {
    companion_id?: SortOrder
    attribute?: SortOrder
    type?: SortOrder
    release_time?: SortOrder
    name?: SortOrder
    story?: SortOrder
    image_path_base?: SortOrder
    companion_ability_link?: companion_ability_linkOrderByRelationAggregateInput
    companion_skill_link?: companion_skill_linkOrderByRelationAggregateInput
    companion_stat?: companion_statOrderByRelationAggregateInput
  }

  export type companionWhereUniqueInput = {
    companion_id?: number
  }

  export type companionOrderByWithAggregationInput = {
    companion_id?: SortOrder
    attribute?: SortOrder
    type?: SortOrder
    release_time?: SortOrder
    name?: SortOrder
    story?: SortOrder
    image_path_base?: SortOrder
    _count?: companionCountOrderByAggregateInput
    _avg?: companionAvgOrderByAggregateInput
    _max?: companionMaxOrderByAggregateInput
    _min?: companionMinOrderByAggregateInput
    _sum?: companionSumOrderByAggregateInput
  }

  export type companionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<companionScalarWhereWithAggregatesInput>
    OR?: Enumerable<companionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<companionScalarWhereWithAggregatesInput>
    companion_id?: IntWithAggregatesFilter | number
    attribute?: StringNullableWithAggregatesFilter | string | null
    type?: StringNullableWithAggregatesFilter | string | null
    release_time?: DateTimeWithAggregatesFilter | Date | string
    name?: StringNullableWithAggregatesFilter | string | null
    story?: StringNullableWithAggregatesFilter | string | null
    image_path_base?: StringNullableWithAggregatesFilter | string | null
  }

  export type companion_abilityWhereInput = {
    AND?: Enumerable<companion_abilityWhereInput>
    OR?: Enumerable<companion_abilityWhereInput>
    NOT?: Enumerable<companion_abilityWhereInput>
    ability_id?: IntFilter | number
    ability_level?: IntFilter | number
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    image_path_base?: StringNullableFilter | string | null
    companion_ability_link?: Companion_ability_linkListRelationFilter
  }

  export type companion_abilityOrderByWithRelationInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
    companion_ability_link?: companion_ability_linkOrderByRelationAggregateInput
  }

  export type companion_abilityWhereUniqueInput = {
    ability_id_ability_level?: companion_abilityAbility_idAbility_levelCompoundUniqueInput
  }

  export type companion_abilityOrderByWithAggregationInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
    _count?: companion_abilityCountOrderByAggregateInput
    _avg?: companion_abilityAvgOrderByAggregateInput
    _max?: companion_abilityMaxOrderByAggregateInput
    _min?: companion_abilityMinOrderByAggregateInput
    _sum?: companion_abilitySumOrderByAggregateInput
  }

  export type companion_abilityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<companion_abilityScalarWhereWithAggregatesInput>
    OR?: Enumerable<companion_abilityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<companion_abilityScalarWhereWithAggregatesInput>
    ability_id?: IntWithAggregatesFilter | number
    ability_level?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    image_path_base?: StringNullableWithAggregatesFilter | string | null
  }

  export type companion_ability_linkWhereInput = {
    AND?: Enumerable<companion_ability_linkWhereInput>
    OR?: Enumerable<companion_ability_linkWhereInput>
    NOT?: Enumerable<companion_ability_linkWhereInput>
    companion_id?: IntFilter | number
    companion_level?: IntFilter | number
    ability_id?: IntFilter | number
    ability_level?: IntFilter | number
    companion_ability?: XOR<Companion_abilityRelationFilter, companion_abilityWhereInput>
    companion?: XOR<CompanionRelationFilter, companionWhereInput>
  }

  export type companion_ability_linkOrderByWithRelationInput = {
    companion_id?: SortOrder
    companion_level?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
    companion_ability?: companion_abilityOrderByWithRelationInput
    companion?: companionOrderByWithRelationInput
  }

  export type companion_ability_linkWhereUniqueInput = {
    companion_id_companion_level_ability_id_ability_level?: companion_ability_linkCompanion_idCompanion_levelAbility_idAbility_levelCompoundUniqueInput
  }

  export type companion_ability_linkOrderByWithAggregationInput = {
    companion_id?: SortOrder
    companion_level?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
    _count?: companion_ability_linkCountOrderByAggregateInput
    _avg?: companion_ability_linkAvgOrderByAggregateInput
    _max?: companion_ability_linkMaxOrderByAggregateInput
    _min?: companion_ability_linkMinOrderByAggregateInput
    _sum?: companion_ability_linkSumOrderByAggregateInput
  }

  export type companion_ability_linkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<companion_ability_linkScalarWhereWithAggregatesInput>
    OR?: Enumerable<companion_ability_linkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<companion_ability_linkScalarWhereWithAggregatesInput>
    companion_id?: IntWithAggregatesFilter | number
    companion_level?: IntWithAggregatesFilter | number
    ability_id?: IntWithAggregatesFilter | number
    ability_level?: IntWithAggregatesFilter | number
  }

  export type companion_skillWhereInput = {
    AND?: Enumerable<companion_skillWhereInput>
    OR?: Enumerable<companion_skillWhereInput>
    NOT?: Enumerable<companion_skillWhereInput>
    skill_id?: IntFilter | number
    skill_level?: IntFilter | number
    cooldown_time?: IntFilter | number
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    short_description?: StringNullableFilter | string | null
    image_path?: StringNullableFilter | string | null
    companion_skill_link?: Companion_skill_linkListRelationFilter
  }

  export type companion_skillOrderByWithRelationInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    cooldown_time?: SortOrder
    name?: SortOrder
    description?: SortOrder
    short_description?: SortOrder
    image_path?: SortOrder
    companion_skill_link?: companion_skill_linkOrderByRelationAggregateInput
  }

  export type companion_skillWhereUniqueInput = {
    skill_id_skill_level?: companion_skillSkill_idSkill_levelCompoundUniqueInput
  }

  export type companion_skillOrderByWithAggregationInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    cooldown_time?: SortOrder
    name?: SortOrder
    description?: SortOrder
    short_description?: SortOrder
    image_path?: SortOrder
    _count?: companion_skillCountOrderByAggregateInput
    _avg?: companion_skillAvgOrderByAggregateInput
    _max?: companion_skillMaxOrderByAggregateInput
    _min?: companion_skillMinOrderByAggregateInput
    _sum?: companion_skillSumOrderByAggregateInput
  }

  export type companion_skillScalarWhereWithAggregatesInput = {
    AND?: Enumerable<companion_skillScalarWhereWithAggregatesInput>
    OR?: Enumerable<companion_skillScalarWhereWithAggregatesInput>
    NOT?: Enumerable<companion_skillScalarWhereWithAggregatesInput>
    skill_id?: IntWithAggregatesFilter | number
    skill_level?: IntWithAggregatesFilter | number
    cooldown_time?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    short_description?: StringNullableWithAggregatesFilter | string | null
    image_path?: StringNullableWithAggregatesFilter | string | null
  }

  export type companion_skill_linkWhereInput = {
    AND?: Enumerable<companion_skill_linkWhereInput>
    OR?: Enumerable<companion_skill_linkWhereInput>
    NOT?: Enumerable<companion_skill_linkWhereInput>
    companion_id?: IntFilter | number
    companion_level?: IntFilter | number
    skill_id?: IntFilter | number
    skill_level?: IntFilter | number
    companion?: XOR<CompanionRelationFilter, companionWhereInput>
    companion_skill?: XOR<Companion_skillRelationFilter, companion_skillWhereInput>
  }

  export type companion_skill_linkOrderByWithRelationInput = {
    companion_id?: SortOrder
    companion_level?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
    companion?: companionOrderByWithRelationInput
    companion_skill?: companion_skillOrderByWithRelationInput
  }

  export type companion_skill_linkWhereUniqueInput = {
    companion_id_companion_level_skill_id_skill_level?: companion_skill_linkCompanion_idCompanion_levelSkill_idSkill_levelCompoundUniqueInput
  }

  export type companion_skill_linkOrderByWithAggregationInput = {
    companion_id?: SortOrder
    companion_level?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
    _count?: companion_skill_linkCountOrderByAggregateInput
    _avg?: companion_skill_linkAvgOrderByAggregateInput
    _max?: companion_skill_linkMaxOrderByAggregateInput
    _min?: companion_skill_linkMinOrderByAggregateInput
    _sum?: companion_skill_linkSumOrderByAggregateInput
  }

  export type companion_skill_linkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<companion_skill_linkScalarWhereWithAggregatesInput>
    OR?: Enumerable<companion_skill_linkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<companion_skill_linkScalarWhereWithAggregatesInput>
    companion_id?: IntWithAggregatesFilter | number
    companion_level?: IntWithAggregatesFilter | number
    skill_id?: IntWithAggregatesFilter | number
    skill_level?: IntWithAggregatesFilter | number
  }

  export type companion_statWhereInput = {
    AND?: Enumerable<companion_statWhereInput>
    OR?: Enumerable<companion_statWhereInput>
    NOT?: Enumerable<companion_statWhereInput>
    companion_id?: IntFilter | number
    level?: IntFilter | number
    atk?: IntFilter | number
    hp?: IntFilter | number
    vit?: IntFilter | number
    companion?: XOR<CompanionRelationFilter, companionWhereInput>
  }

  export type companion_statOrderByWithRelationInput = {
    companion_id?: SortOrder
    level?: SortOrder
    atk?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
    companion?: companionOrderByWithRelationInput
  }

  export type companion_statWhereUniqueInput = {
    companion_id_level?: companion_statCompanion_idLevelCompoundUniqueInput
  }

  export type companion_statOrderByWithAggregationInput = {
    companion_id?: SortOrder
    level?: SortOrder
    atk?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
    _count?: companion_statCountOrderByAggregateInput
    _avg?: companion_statAvgOrderByAggregateInput
    _max?: companion_statMaxOrderByAggregateInput
    _min?: companion_statMinOrderByAggregateInput
    _sum?: companion_statSumOrderByAggregateInput
  }

  export type companion_statScalarWhereWithAggregatesInput = {
    AND?: Enumerable<companion_statScalarWhereWithAggregatesInput>
    OR?: Enumerable<companion_statScalarWhereWithAggregatesInput>
    NOT?: Enumerable<companion_statScalarWhereWithAggregatesInput>
    companion_id?: IntWithAggregatesFilter | number
    level?: IntWithAggregatesFilter | number
    atk?: IntWithAggregatesFilter | number
    hp?: IntWithAggregatesFilter | number
    vit?: IntWithAggregatesFilter | number
  }

  export type costumeWhereInput = {
    AND?: Enumerable<costumeWhereInput>
    OR?: Enumerable<costumeWhereInput>
    NOT?: Enumerable<costumeWhereInput>
    costume_id?: IntFilter | number
    character_id?: IntFilter | number
    emblem_id?: IntNullableFilter | number | null
    weapon_type?: StringNullableFilter | string | null
    rarity?: StringNullableFilter | string | null
    release_time?: DateTimeFilter | Date | string
    is_ex_costume?: BoolFilter | boolean
    slug?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    image_path_base?: StringNullableFilter | string | null
    character?: XOR<CharacterRelationFilter, characterWhereInput>
    emblem?: XOR<EmblemRelationFilter, emblemWhereInput> | null
    costume_ability_link?: Costume_ability_linkListRelationFilter
    costume_skill_link?: Costume_skill_linkListRelationFilter
    costume_stat?: Costume_statListRelationFilter
  }

  export type costumeOrderByWithRelationInput = {
    costume_id?: SortOrder
    character_id?: SortOrder
    emblem_id?: SortOrder
    weapon_type?: SortOrder
    rarity?: SortOrder
    release_time?: SortOrder
    is_ex_costume?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
    character?: characterOrderByWithRelationInput
    emblem?: emblemOrderByWithRelationInput
    costume_ability_link?: costume_ability_linkOrderByRelationAggregateInput
    costume_skill_link?: costume_skill_linkOrderByRelationAggregateInput
    costume_stat?: costume_statOrderByRelationAggregateInput
  }

  export type costumeWhereUniqueInput = {
    costume_id?: number
  }

  export type costumeOrderByWithAggregationInput = {
    costume_id?: SortOrder
    character_id?: SortOrder
    emblem_id?: SortOrder
    weapon_type?: SortOrder
    rarity?: SortOrder
    release_time?: SortOrder
    is_ex_costume?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
    _count?: costumeCountOrderByAggregateInput
    _avg?: costumeAvgOrderByAggregateInput
    _max?: costumeMaxOrderByAggregateInput
    _min?: costumeMinOrderByAggregateInput
    _sum?: costumeSumOrderByAggregateInput
  }

  export type costumeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<costumeScalarWhereWithAggregatesInput>
    OR?: Enumerable<costumeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<costumeScalarWhereWithAggregatesInput>
    costume_id?: IntWithAggregatesFilter | number
    character_id?: IntWithAggregatesFilter | number
    emblem_id?: IntNullableWithAggregatesFilter | number | null
    weapon_type?: StringNullableWithAggregatesFilter | string | null
    rarity?: StringNullableWithAggregatesFilter | string | null
    release_time?: DateTimeWithAggregatesFilter | Date | string
    is_ex_costume?: BoolWithAggregatesFilter | boolean
    slug?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    image_path_base?: StringNullableWithAggregatesFilter | string | null
  }

  export type costume_abilityWhereInput = {
    AND?: Enumerable<costume_abilityWhereInput>
    OR?: Enumerable<costume_abilityWhereInput>
    NOT?: Enumerable<costume_abilityWhereInput>
    ability_id?: IntFilter | number
    ability_level?: IntFilter | number
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    image_path_base?: StringNullableFilter | string | null
    costume_ability_link?: Costume_ability_linkListRelationFilter
  }

  export type costume_abilityOrderByWithRelationInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
    costume_ability_link?: costume_ability_linkOrderByRelationAggregateInput
  }

  export type costume_abilityWhereUniqueInput = {
    ability_id_ability_level?: costume_abilityAbility_idAbility_levelCompoundUniqueInput
  }

  export type costume_abilityOrderByWithAggregationInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
    _count?: costume_abilityCountOrderByAggregateInput
    _avg?: costume_abilityAvgOrderByAggregateInput
    _max?: costume_abilityMaxOrderByAggregateInput
    _min?: costume_abilityMinOrderByAggregateInput
    _sum?: costume_abilitySumOrderByAggregateInput
  }

  export type costume_abilityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<costume_abilityScalarWhereWithAggregatesInput>
    OR?: Enumerable<costume_abilityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<costume_abilityScalarWhereWithAggregatesInput>
    ability_id?: IntWithAggregatesFilter | number
    ability_level?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    image_path_base?: StringNullableWithAggregatesFilter | string | null
  }

  export type costume_ability_linkWhereInput = {
    AND?: Enumerable<costume_ability_linkWhereInput>
    OR?: Enumerable<costume_ability_linkWhereInput>
    NOT?: Enumerable<costume_ability_linkWhereInput>
    costume_id?: IntFilter | number
    ability_slot?: IntFilter | number
    ability_id?: IntFilter | number
    ability_level?: IntFilter | number
    costume_ability?: XOR<Costume_abilityRelationFilter, costume_abilityWhereInput>
    costume?: XOR<CostumeRelationFilter, costumeWhereInput>
  }

  export type costume_ability_linkOrderByWithRelationInput = {
    costume_id?: SortOrder
    ability_slot?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
    costume_ability?: costume_abilityOrderByWithRelationInput
    costume?: costumeOrderByWithRelationInput
  }

  export type costume_ability_linkWhereUniqueInput = {
    costume_id_ability_slot_ability_id_ability_level?: costume_ability_linkCostume_idAbility_slotAbility_idAbility_levelCompoundUniqueInput
  }

  export type costume_ability_linkOrderByWithAggregationInput = {
    costume_id?: SortOrder
    ability_slot?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
    _count?: costume_ability_linkCountOrderByAggregateInput
    _avg?: costume_ability_linkAvgOrderByAggregateInput
    _max?: costume_ability_linkMaxOrderByAggregateInput
    _min?: costume_ability_linkMinOrderByAggregateInput
    _sum?: costume_ability_linkSumOrderByAggregateInput
  }

  export type costume_ability_linkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<costume_ability_linkScalarWhereWithAggregatesInput>
    OR?: Enumerable<costume_ability_linkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<costume_ability_linkScalarWhereWithAggregatesInput>
    costume_id?: IntWithAggregatesFilter | number
    ability_slot?: IntWithAggregatesFilter | number
    ability_id?: IntWithAggregatesFilter | number
    ability_level?: IntWithAggregatesFilter | number
  }

  export type costume_skillWhereInput = {
    AND?: Enumerable<costume_skillWhereInput>
    OR?: Enumerable<costume_skillWhereInput>
    NOT?: Enumerable<costume_skillWhereInput>
    skill_id?: IntFilter | number
    skill_level?: IntFilter | number
    gauge_rise_speed?: StringNullableFilter | string | null
    cooldown_time?: IntFilter | number
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    short_description?: StringNullableFilter | string | null
    image_path?: StringNullableFilter | string | null
    costume_skill_link?: Costume_skill_linkListRelationFilter
  }

  export type costume_skillOrderByWithRelationInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    gauge_rise_speed?: SortOrder
    cooldown_time?: SortOrder
    name?: SortOrder
    description?: SortOrder
    short_description?: SortOrder
    image_path?: SortOrder
    costume_skill_link?: costume_skill_linkOrderByRelationAggregateInput
  }

  export type costume_skillWhereUniqueInput = {
    skill_id_skill_level?: costume_skillSkill_idSkill_levelCompoundUniqueInput
  }

  export type costume_skillOrderByWithAggregationInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    gauge_rise_speed?: SortOrder
    cooldown_time?: SortOrder
    name?: SortOrder
    description?: SortOrder
    short_description?: SortOrder
    image_path?: SortOrder
    _count?: costume_skillCountOrderByAggregateInput
    _avg?: costume_skillAvgOrderByAggregateInput
    _max?: costume_skillMaxOrderByAggregateInput
    _min?: costume_skillMinOrderByAggregateInput
    _sum?: costume_skillSumOrderByAggregateInput
  }

  export type costume_skillScalarWhereWithAggregatesInput = {
    AND?: Enumerable<costume_skillScalarWhereWithAggregatesInput>
    OR?: Enumerable<costume_skillScalarWhereWithAggregatesInput>
    NOT?: Enumerable<costume_skillScalarWhereWithAggregatesInput>
    skill_id?: IntWithAggregatesFilter | number
    skill_level?: IntWithAggregatesFilter | number
    gauge_rise_speed?: StringNullableWithAggregatesFilter | string | null
    cooldown_time?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    short_description?: StringNullableWithAggregatesFilter | string | null
    image_path?: StringNullableWithAggregatesFilter | string | null
  }

  export type costume_skill_linkWhereInput = {
    AND?: Enumerable<costume_skill_linkWhereInput>
    OR?: Enumerable<costume_skill_linkWhereInput>
    NOT?: Enumerable<costume_skill_linkWhereInput>
    costume_id?: IntFilter | number
    skill_id?: IntFilter | number
    skill_level?: IntFilter | number
    costume?: XOR<CostumeRelationFilter, costumeWhereInput>
    costume_skill?: XOR<Costume_skillRelationFilter, costume_skillWhereInput>
  }

  export type costume_skill_linkOrderByWithRelationInput = {
    costume_id?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
    costume?: costumeOrderByWithRelationInput
    costume_skill?: costume_skillOrderByWithRelationInput
  }

  export type costume_skill_linkWhereUniqueInput = {
    costume_id_skill_id_skill_level?: costume_skill_linkCostume_idSkill_idSkill_levelCompoundUniqueInput
  }

  export type costume_skill_linkOrderByWithAggregationInput = {
    costume_id?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
    _count?: costume_skill_linkCountOrderByAggregateInput
    _avg?: costume_skill_linkAvgOrderByAggregateInput
    _max?: costume_skill_linkMaxOrderByAggregateInput
    _min?: costume_skill_linkMinOrderByAggregateInput
    _sum?: costume_skill_linkSumOrderByAggregateInput
  }

  export type costume_skill_linkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<costume_skill_linkScalarWhereWithAggregatesInput>
    OR?: Enumerable<costume_skill_linkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<costume_skill_linkScalarWhereWithAggregatesInput>
    costume_id?: IntWithAggregatesFilter | number
    skill_id?: IntWithAggregatesFilter | number
    skill_level?: IntWithAggregatesFilter | number
  }

  export type costume_statWhereInput = {
    AND?: Enumerable<costume_statWhereInput>
    OR?: Enumerable<costume_statWhereInput>
    NOT?: Enumerable<costume_statWhereInput>
    costume_id?: IntFilter | number
    level?: IntFilter | number
    agi?: IntFilter | number
    atk?: IntFilter | number
    crit_atk?: IntFilter | number
    crit_rate?: IntFilter | number
    eva_rate?: IntFilter | number
    hp?: IntFilter | number
    vit?: IntFilter | number
    costume?: XOR<CostumeRelationFilter, costumeWhereInput>
  }

  export type costume_statOrderByWithRelationInput = {
    costume_id?: SortOrder
    level?: SortOrder
    agi?: SortOrder
    atk?: SortOrder
    crit_atk?: SortOrder
    crit_rate?: SortOrder
    eva_rate?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
    costume?: costumeOrderByWithRelationInput
  }

  export type costume_statWhereUniqueInput = {
    costume_id_level?: costume_statCostume_idLevelCompoundUniqueInput
  }

  export type costume_statOrderByWithAggregationInput = {
    costume_id?: SortOrder
    level?: SortOrder
    agi?: SortOrder
    atk?: SortOrder
    crit_atk?: SortOrder
    crit_rate?: SortOrder
    eva_rate?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
    _count?: costume_statCountOrderByAggregateInput
    _avg?: costume_statAvgOrderByAggregateInput
    _max?: costume_statMaxOrderByAggregateInput
    _min?: costume_statMinOrderByAggregateInput
    _sum?: costume_statSumOrderByAggregateInput
  }

  export type costume_statScalarWhereWithAggregatesInput = {
    AND?: Enumerable<costume_statScalarWhereWithAggregatesInput>
    OR?: Enumerable<costume_statScalarWhereWithAggregatesInput>
    NOT?: Enumerable<costume_statScalarWhereWithAggregatesInput>
    costume_id?: IntWithAggregatesFilter | number
    level?: IntWithAggregatesFilter | number
    agi?: IntWithAggregatesFilter | number
    atk?: IntWithAggregatesFilter | number
    crit_atk?: IntWithAggregatesFilter | number
    crit_rate?: IntWithAggregatesFilter | number
    eva_rate?: IntWithAggregatesFilter | number
    hp?: IntWithAggregatesFilter | number
    vit?: IntWithAggregatesFilter | number
  }

  export type emblemWhereInput = {
    AND?: Enumerable<emblemWhereInput>
    OR?: Enumerable<emblemWhereInput>
    NOT?: Enumerable<emblemWhereInput>
    emblem_id?: IntFilter | number
    name?: StringNullableFilter | string | null
    main_message?: StringNullableFilter | string | null
    small_messages?: StringNullableFilter | string | null
    image_path?: StringNullableFilter | string | null
    costume?: CostumeListRelationFilter
  }

  export type emblemOrderByWithRelationInput = {
    emblem_id?: SortOrder
    name?: SortOrder
    main_message?: SortOrder
    small_messages?: SortOrder
    image_path?: SortOrder
    costume?: costumeOrderByRelationAggregateInput
  }

  export type emblemWhereUniqueInput = {
    emblem_id?: number
  }

  export type emblemOrderByWithAggregationInput = {
    emblem_id?: SortOrder
    name?: SortOrder
    main_message?: SortOrder
    small_messages?: SortOrder
    image_path?: SortOrder
    _count?: emblemCountOrderByAggregateInput
    _avg?: emblemAvgOrderByAggregateInput
    _max?: emblemMaxOrderByAggregateInput
    _min?: emblemMinOrderByAggregateInput
    _sum?: emblemSumOrderByAggregateInput
  }

  export type emblemScalarWhereWithAggregatesInput = {
    AND?: Enumerable<emblemScalarWhereWithAggregatesInput>
    OR?: Enumerable<emblemScalarWhereWithAggregatesInput>
    NOT?: Enumerable<emblemScalarWhereWithAggregatesInput>
    emblem_id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    main_message?: StringNullableWithAggregatesFilter | string | null
    small_messages?: StringNullableWithAggregatesFilter | string | null
    image_path?: StringNullableWithAggregatesFilter | string | null
  }

  export type memoirWhereInput = {
    AND?: Enumerable<memoirWhereInput>
    OR?: Enumerable<memoirWhereInput>
    NOT?: Enumerable<memoirWhereInput>
    memoir_id?: IntFilter | number
    lottery_id?: IntFilter | number
    rarity?: StringNullableFilter | string | null
    release_time?: DateTimeFilter | Date | string
    name?: StringNullableFilter | string | null
    story?: StringNullableFilter | string | null
    image_path_base?: StringNullableFilter | string | null
    memoir_series_id?: IntNullableFilter | number | null
    memoir_series?: XOR<Memoir_seriesRelationFilter, memoir_seriesWhereInput> | null
  }

  export type memoirOrderByWithRelationInput = {
    memoir_id?: SortOrder
    lottery_id?: SortOrder
    rarity?: SortOrder
    release_time?: SortOrder
    name?: SortOrder
    story?: SortOrder
    image_path_base?: SortOrder
    memoir_series_id?: SortOrder
    memoir_series?: memoir_seriesOrderByWithRelationInput
  }

  export type memoirWhereUniqueInput = {
    memoir_id_lottery_id?: memoirMemoir_idLottery_idCompoundUniqueInput
  }

  export type memoirOrderByWithAggregationInput = {
    memoir_id?: SortOrder
    lottery_id?: SortOrder
    rarity?: SortOrder
    release_time?: SortOrder
    name?: SortOrder
    story?: SortOrder
    image_path_base?: SortOrder
    memoir_series_id?: SortOrder
    _count?: memoirCountOrderByAggregateInput
    _avg?: memoirAvgOrderByAggregateInput
    _max?: memoirMaxOrderByAggregateInput
    _min?: memoirMinOrderByAggregateInput
    _sum?: memoirSumOrderByAggregateInput
  }

  export type memoirScalarWhereWithAggregatesInput = {
    AND?: Enumerable<memoirScalarWhereWithAggregatesInput>
    OR?: Enumerable<memoirScalarWhereWithAggregatesInput>
    NOT?: Enumerable<memoirScalarWhereWithAggregatesInput>
    memoir_id?: IntWithAggregatesFilter | number
    lottery_id?: IntWithAggregatesFilter | number
    rarity?: StringNullableWithAggregatesFilter | string | null
    release_time?: DateTimeWithAggregatesFilter | Date | string
    name?: StringNullableWithAggregatesFilter | string | null
    story?: StringNullableWithAggregatesFilter | string | null
    image_path_base?: StringNullableWithAggregatesFilter | string | null
    memoir_series_id?: IntNullableWithAggregatesFilter | number | null
  }

  export type memoir_seriesWhereInput = {
    AND?: Enumerable<memoir_seriesWhereInput>
    OR?: Enumerable<memoir_seriesWhereInput>
    NOT?: Enumerable<memoir_seriesWhereInput>
    memoir_series_id?: IntFilter | number
    name?: StringNullableFilter | string | null
    small_set_description?: StringNullableFilter | string | null
    large_set_description?: StringNullableFilter | string | null
    memoir?: MemoirListRelationFilter
  }

  export type memoir_seriesOrderByWithRelationInput = {
    memoir_series_id?: SortOrder
    name?: SortOrder
    small_set_description?: SortOrder
    large_set_description?: SortOrder
    memoir?: memoirOrderByRelationAggregateInput
  }

  export type memoir_seriesWhereUniqueInput = {
    memoir_series_id?: number
  }

  export type memoir_seriesOrderByWithAggregationInput = {
    memoir_series_id?: SortOrder
    name?: SortOrder
    small_set_description?: SortOrder
    large_set_description?: SortOrder
    _count?: memoir_seriesCountOrderByAggregateInput
    _avg?: memoir_seriesAvgOrderByAggregateInput
    _max?: memoir_seriesMaxOrderByAggregateInput
    _min?: memoir_seriesMinOrderByAggregateInput
    _sum?: memoir_seriesSumOrderByAggregateInput
  }

  export type memoir_seriesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<memoir_seriesScalarWhereWithAggregatesInput>
    OR?: Enumerable<memoir_seriesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<memoir_seriesScalarWhereWithAggregatesInput>
    memoir_series_id?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    small_set_description?: StringNullableWithAggregatesFilter | string | null
    large_set_description?: StringNullableWithAggregatesFilter | string | null
  }

  export type weaponWhereInput = {
    AND?: Enumerable<weaponWhereInput>
    OR?: Enumerable<weaponWhereInput>
    NOT?: Enumerable<weaponWhereInput>
    weapon_id?: IntFilter | number
    evolution_group_id?: IntFilter | number
    evolution_order?: IntFilter | number
    weapon_type?: StringNullableFilter | string | null
    rarity?: StringNullableFilter | string | null
    attribute?: StringNullableFilter | string | null
    is_ex_weapon?: BoolFilter | boolean
    release_time?: DateTimeNullableFilter | Date | string | null
    slug?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    image_path?: StringNullableFilter | string | null
    weapon_ability_link?: Weapon_ability_linkListRelationFilter
    weapon_skill_link?: Weapon_skill_linkListRelationFilter
    weapon_stat?: Weapon_statListRelationFilter
    weapon_story_link?: Weapon_story_linkListRelationFilter
  }

  export type weaponOrderByWithRelationInput = {
    weapon_id?: SortOrder
    evolution_group_id?: SortOrder
    evolution_order?: SortOrder
    weapon_type?: SortOrder
    rarity?: SortOrder
    attribute?: SortOrder
    is_ex_weapon?: SortOrder
    release_time?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    image_path?: SortOrder
    weapon_ability_link?: weapon_ability_linkOrderByRelationAggregateInput
    weapon_skill_link?: weapon_skill_linkOrderByRelationAggregateInput
    weapon_stat?: weapon_statOrderByRelationAggregateInput
    weapon_story_link?: weapon_story_linkOrderByRelationAggregateInput
  }

  export type weaponWhereUniqueInput = {
    weapon_id?: number
    evolution_group_id_evolution_order?: weaponEvolution_group_idEvolution_orderCompoundUniqueInput
  }

  export type weaponOrderByWithAggregationInput = {
    weapon_id?: SortOrder
    evolution_group_id?: SortOrder
    evolution_order?: SortOrder
    weapon_type?: SortOrder
    rarity?: SortOrder
    attribute?: SortOrder
    is_ex_weapon?: SortOrder
    release_time?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    image_path?: SortOrder
    _count?: weaponCountOrderByAggregateInput
    _avg?: weaponAvgOrderByAggregateInput
    _max?: weaponMaxOrderByAggregateInput
    _min?: weaponMinOrderByAggregateInput
    _sum?: weaponSumOrderByAggregateInput
  }

  export type weaponScalarWhereWithAggregatesInput = {
    AND?: Enumerable<weaponScalarWhereWithAggregatesInput>
    OR?: Enumerable<weaponScalarWhereWithAggregatesInput>
    NOT?: Enumerable<weaponScalarWhereWithAggregatesInput>
    weapon_id?: IntWithAggregatesFilter | number
    evolution_group_id?: IntWithAggregatesFilter | number
    evolution_order?: IntWithAggregatesFilter | number
    weapon_type?: StringNullableWithAggregatesFilter | string | null
    rarity?: StringNullableWithAggregatesFilter | string | null
    attribute?: StringNullableWithAggregatesFilter | string | null
    is_ex_weapon?: BoolWithAggregatesFilter | boolean
    release_time?: DateTimeNullableWithAggregatesFilter | Date | string | null
    slug?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    image_path?: StringNullableWithAggregatesFilter | string | null
  }

  export type weapon_abilityWhereInput = {
    AND?: Enumerable<weapon_abilityWhereInput>
    OR?: Enumerable<weapon_abilityWhereInput>
    NOT?: Enumerable<weapon_abilityWhereInput>
    ability_id?: IntFilter | number
    ability_level?: IntFilter | number
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    image_path_base?: StringNullableFilter | string | null
    weapon_ability_link?: Weapon_ability_linkListRelationFilter
  }

  export type weapon_abilityOrderByWithRelationInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
    weapon_ability_link?: weapon_ability_linkOrderByRelationAggregateInput
  }

  export type weapon_abilityWhereUniqueInput = {
    ability_id_ability_level?: weapon_abilityAbility_idAbility_levelCompoundUniqueInput
  }

  export type weapon_abilityOrderByWithAggregationInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
    _count?: weapon_abilityCountOrderByAggregateInput
    _avg?: weapon_abilityAvgOrderByAggregateInput
    _max?: weapon_abilityMaxOrderByAggregateInput
    _min?: weapon_abilityMinOrderByAggregateInput
    _sum?: weapon_abilitySumOrderByAggregateInput
  }

  export type weapon_abilityScalarWhereWithAggregatesInput = {
    AND?: Enumerable<weapon_abilityScalarWhereWithAggregatesInput>
    OR?: Enumerable<weapon_abilityScalarWhereWithAggregatesInput>
    NOT?: Enumerable<weapon_abilityScalarWhereWithAggregatesInput>
    ability_id?: IntWithAggregatesFilter | number
    ability_level?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    image_path_base?: StringNullableWithAggregatesFilter | string | null
  }

  export type weapon_ability_linkWhereInput = {
    AND?: Enumerable<weapon_ability_linkWhereInput>
    OR?: Enumerable<weapon_ability_linkWhereInput>
    NOT?: Enumerable<weapon_ability_linkWhereInput>
    weapon_id?: IntFilter | number
    slot_number?: IntFilter | number
    ability_id?: IntFilter | number
    ability_level?: IntFilter | number
    weapon_ability?: XOR<Weapon_abilityRelationFilter, weapon_abilityWhereInput>
    weapon?: XOR<WeaponRelationFilter, weaponWhereInput>
  }

  export type weapon_ability_linkOrderByWithRelationInput = {
    weapon_id?: SortOrder
    slot_number?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
    weapon_ability?: weapon_abilityOrderByWithRelationInput
    weapon?: weaponOrderByWithRelationInput
  }

  export type weapon_ability_linkWhereUniqueInput = {
    weapon_id_slot_number_ability_id_ability_level?: weapon_ability_linkWeapon_idSlot_numberAbility_idAbility_levelCompoundUniqueInput
  }

  export type weapon_ability_linkOrderByWithAggregationInput = {
    weapon_id?: SortOrder
    slot_number?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
    _count?: weapon_ability_linkCountOrderByAggregateInput
    _avg?: weapon_ability_linkAvgOrderByAggregateInput
    _max?: weapon_ability_linkMaxOrderByAggregateInput
    _min?: weapon_ability_linkMinOrderByAggregateInput
    _sum?: weapon_ability_linkSumOrderByAggregateInput
  }

  export type weapon_ability_linkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<weapon_ability_linkScalarWhereWithAggregatesInput>
    OR?: Enumerable<weapon_ability_linkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<weapon_ability_linkScalarWhereWithAggregatesInput>
    weapon_id?: IntWithAggregatesFilter | number
    slot_number?: IntWithAggregatesFilter | number
    ability_id?: IntWithAggregatesFilter | number
    ability_level?: IntWithAggregatesFilter | number
  }

  export type weapon_skillWhereInput = {
    AND?: Enumerable<weapon_skillWhereInput>
    OR?: Enumerable<weapon_skillWhereInput>
    NOT?: Enumerable<weapon_skillWhereInput>
    skill_id?: IntFilter | number
    skill_level?: IntFilter | number
    cooldown_time?: IntFilter | number
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    short_description?: StringNullableFilter | string | null
    image_path?: StringNullableFilter | string | null
    weapon_skill_link?: Weapon_skill_linkListRelationFilter
  }

  export type weapon_skillOrderByWithRelationInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    cooldown_time?: SortOrder
    name?: SortOrder
    description?: SortOrder
    short_description?: SortOrder
    image_path?: SortOrder
    weapon_skill_link?: weapon_skill_linkOrderByRelationAggregateInput
  }

  export type weapon_skillWhereUniqueInput = {
    skill_id_skill_level?: weapon_skillSkill_idSkill_levelCompoundUniqueInput
  }

  export type weapon_skillOrderByWithAggregationInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    cooldown_time?: SortOrder
    name?: SortOrder
    description?: SortOrder
    short_description?: SortOrder
    image_path?: SortOrder
    _count?: weapon_skillCountOrderByAggregateInput
    _avg?: weapon_skillAvgOrderByAggregateInput
    _max?: weapon_skillMaxOrderByAggregateInput
    _min?: weapon_skillMinOrderByAggregateInput
    _sum?: weapon_skillSumOrderByAggregateInput
  }

  export type weapon_skillScalarWhereWithAggregatesInput = {
    AND?: Enumerable<weapon_skillScalarWhereWithAggregatesInput>
    OR?: Enumerable<weapon_skillScalarWhereWithAggregatesInput>
    NOT?: Enumerable<weapon_skillScalarWhereWithAggregatesInput>
    skill_id?: IntWithAggregatesFilter | number
    skill_level?: IntWithAggregatesFilter | number
    cooldown_time?: IntWithAggregatesFilter | number
    name?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    short_description?: StringNullableWithAggregatesFilter | string | null
    image_path?: StringNullableWithAggregatesFilter | string | null
  }

  export type weapon_skill_linkWhereInput = {
    AND?: Enumerable<weapon_skill_linkWhereInput>
    OR?: Enumerable<weapon_skill_linkWhereInput>
    NOT?: Enumerable<weapon_skill_linkWhereInput>
    weapon_id?: IntFilter | number
    slot_number?: IntFilter | number
    skill_id?: IntFilter | number
    skill_level?: IntFilter | number
    weapon_skill?: XOR<Weapon_skillRelationFilter, weapon_skillWhereInput>
    weapon?: XOR<WeaponRelationFilter, weaponWhereInput>
  }

  export type weapon_skill_linkOrderByWithRelationInput = {
    weapon_id?: SortOrder
    slot_number?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
    weapon_skill?: weapon_skillOrderByWithRelationInput
    weapon?: weaponOrderByWithRelationInput
  }

  export type weapon_skill_linkWhereUniqueInput = {
    weapon_id_slot_number_skill_id_skill_level?: weapon_skill_linkWeapon_idSlot_numberSkill_idSkill_levelCompoundUniqueInput
  }

  export type weapon_skill_linkOrderByWithAggregationInput = {
    weapon_id?: SortOrder
    slot_number?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
    _count?: weapon_skill_linkCountOrderByAggregateInput
    _avg?: weapon_skill_linkAvgOrderByAggregateInput
    _max?: weapon_skill_linkMaxOrderByAggregateInput
    _min?: weapon_skill_linkMinOrderByAggregateInput
    _sum?: weapon_skill_linkSumOrderByAggregateInput
  }

  export type weapon_skill_linkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<weapon_skill_linkScalarWhereWithAggregatesInput>
    OR?: Enumerable<weapon_skill_linkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<weapon_skill_linkScalarWhereWithAggregatesInput>
    weapon_id?: IntWithAggregatesFilter | number
    slot_number?: IntWithAggregatesFilter | number
    skill_id?: IntWithAggregatesFilter | number
    skill_level?: IntWithAggregatesFilter | number
  }

  export type weapon_statWhereInput = {
    AND?: Enumerable<weapon_statWhereInput>
    OR?: Enumerable<weapon_statWhereInput>
    NOT?: Enumerable<weapon_statWhereInput>
    weapon_id?: IntFilter | number
    level?: IntFilter | number
    atk?: IntFilter | number
    hp?: IntFilter | number
    vit?: IntFilter | number
    weapon?: XOR<WeaponRelationFilter, weaponWhereInput>
  }

  export type weapon_statOrderByWithRelationInput = {
    weapon_id?: SortOrder
    level?: SortOrder
    atk?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
    weapon?: weaponOrderByWithRelationInput
  }

  export type weapon_statWhereUniqueInput = {
    weapon_id_level?: weapon_statWeapon_idLevelCompoundUniqueInput
  }

  export type weapon_statOrderByWithAggregationInput = {
    weapon_id?: SortOrder
    level?: SortOrder
    atk?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
    _count?: weapon_statCountOrderByAggregateInput
    _avg?: weapon_statAvgOrderByAggregateInput
    _max?: weapon_statMaxOrderByAggregateInput
    _min?: weapon_statMinOrderByAggregateInput
    _sum?: weapon_statSumOrderByAggregateInput
  }

  export type weapon_statScalarWhereWithAggregatesInput = {
    AND?: Enumerable<weapon_statScalarWhereWithAggregatesInput>
    OR?: Enumerable<weapon_statScalarWhereWithAggregatesInput>
    NOT?: Enumerable<weapon_statScalarWhereWithAggregatesInput>
    weapon_id?: IntWithAggregatesFilter | number
    level?: IntWithAggregatesFilter | number
    atk?: IntWithAggregatesFilter | number
    hp?: IntWithAggregatesFilter | number
    vit?: IntWithAggregatesFilter | number
  }

  export type weapon_storyWhereInput = {
    AND?: Enumerable<weapon_storyWhereInput>
    OR?: Enumerable<weapon_storyWhereInput>
    NOT?: Enumerable<weapon_storyWhereInput>
    id?: IntFilter | number
    story?: StringNullableFilter | string | null
    weapon_story_link?: Weapon_story_linkListRelationFilter
  }

  export type weapon_storyOrderByWithRelationInput = {
    id?: SortOrder
    story?: SortOrder
    weapon_story_link?: weapon_story_linkOrderByRelationAggregateInput
  }

  export type weapon_storyWhereUniqueInput = {
    id?: number
  }

  export type weapon_storyOrderByWithAggregationInput = {
    id?: SortOrder
    story?: SortOrder
    _count?: weapon_storyCountOrderByAggregateInput
    _avg?: weapon_storyAvgOrderByAggregateInput
    _max?: weapon_storyMaxOrderByAggregateInput
    _min?: weapon_storyMinOrderByAggregateInput
    _sum?: weapon_storySumOrderByAggregateInput
  }

  export type weapon_storyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<weapon_storyScalarWhereWithAggregatesInput>
    OR?: Enumerable<weapon_storyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<weapon_storyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    story?: StringNullableWithAggregatesFilter | string | null
  }

  export type weapon_story_linkWhereInput = {
    AND?: Enumerable<weapon_story_linkWhereInput>
    OR?: Enumerable<weapon_story_linkWhereInput>
    NOT?: Enumerable<weapon_story_linkWhereInput>
    weapon_id?: IntFilter | number
    weapon_story_id?: IntFilter | number
    weapon?: XOR<WeaponRelationFilter, weaponWhereInput>
    weapon_story?: XOR<Weapon_storyRelationFilter, weapon_storyWhereInput>
  }

  export type weapon_story_linkOrderByWithRelationInput = {
    weapon_id?: SortOrder
    weapon_story_id?: SortOrder
    weapon?: weaponOrderByWithRelationInput
    weapon_story?: weapon_storyOrderByWithRelationInput
  }

  export type weapon_story_linkWhereUniqueInput = {
    weapon_id_weapon_story_id?: weapon_story_linkWeapon_idWeapon_story_idCompoundUniqueInput
  }

  export type weapon_story_linkOrderByWithAggregationInput = {
    weapon_id?: SortOrder
    weapon_story_id?: SortOrder
    _count?: weapon_story_linkCountOrderByAggregateInput
    _avg?: weapon_story_linkAvgOrderByAggregateInput
    _max?: weapon_story_linkMaxOrderByAggregateInput
    _min?: weapon_story_linkMinOrderByAggregateInput
    _sum?: weapon_story_linkSumOrderByAggregateInput
  }

  export type weapon_story_linkScalarWhereWithAggregatesInput = {
    AND?: Enumerable<weapon_story_linkScalarWhereWithAggregatesInput>
    OR?: Enumerable<weapon_story_linkScalarWhereWithAggregatesInput>
    NOT?: Enumerable<weapon_story_linkScalarWhereWithAggregatesInput>
    weapon_id?: IntWithAggregatesFilter | number
    weapon_story_id?: IntWithAggregatesFilter | number
  }

  export type debrisWhereInput = {
    AND?: Enumerable<debrisWhereInput>
    OR?: Enumerable<debrisWhereInput>
    NOT?: Enumerable<debrisWhereInput>
    debris_id?: IntFilter | number
    rarity?: IntFilter | number
    release_time?: DateTimeFilter | Date | string
    name?: StringNullableFilter | string | null
    image_path_base?: StringNullableFilter | string | null
  }

  export type debrisOrderByWithRelationInput = {
    debris_id?: SortOrder
    rarity?: SortOrder
    release_time?: SortOrder
    name?: SortOrder
    image_path_base?: SortOrder
  }

  export type debrisWhereUniqueInput = {
    debris_id?: number
  }

  export type debrisOrderByWithAggregationInput = {
    debris_id?: SortOrder
    rarity?: SortOrder
    release_time?: SortOrder
    name?: SortOrder
    image_path_base?: SortOrder
    _count?: debrisCountOrderByAggregateInput
    _avg?: debrisAvgOrderByAggregateInput
    _max?: debrisMaxOrderByAggregateInput
    _min?: debrisMinOrderByAggregateInput
    _sum?: debrisSumOrderByAggregateInput
  }

  export type debrisScalarWhereWithAggregatesInput = {
    AND?: Enumerable<debrisScalarWhereWithAggregatesInput>
    OR?: Enumerable<debrisScalarWhereWithAggregatesInput>
    NOT?: Enumerable<debrisScalarWhereWithAggregatesInput>
    debris_id?: IntWithAggregatesFilter | number
    rarity?: IntWithAggregatesFilter | number
    release_time?: DateTimeWithAggregatesFilter | Date | string
    name?: StringNullableWithAggregatesFilter | string | null
    image_path_base?: StringNullableWithAggregatesFilter | string | null
  }

  export type notificationWhereInput = {
    AND?: Enumerable<notificationWhereInput>
    OR?: Enumerable<notificationWhereInput>
    NOT?: Enumerable<notificationWhereInput>
    notification_id?: IntFilter | number
    information_type?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    body?: StringNullableFilter | string | null
    release_time?: DateTimeNullableFilter | Date | string | null
    thumbnail_path?: StringNullableFilter | string | null
  }

  export type notificationOrderByWithRelationInput = {
    notification_id?: SortOrder
    information_type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    release_time?: SortOrder
    thumbnail_path?: SortOrder
  }

  export type notificationWhereUniqueInput = {
    notification_id?: number
  }

  export type notificationOrderByWithAggregationInput = {
    notification_id?: SortOrder
    information_type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    release_time?: SortOrder
    thumbnail_path?: SortOrder
    _count?: notificationCountOrderByAggregateInput
    _avg?: notificationAvgOrderByAggregateInput
    _max?: notificationMaxOrderByAggregateInput
    _min?: notificationMinOrderByAggregateInput
    _sum?: notificationSumOrderByAggregateInput
  }

  export type notificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<notificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<notificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<notificationScalarWhereWithAggregatesInput>
    notification_id?: IntWithAggregatesFilter | number
    information_type?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    body?: StringNullableWithAggregatesFilter | string | null
    release_time?: DateTimeNullableWithAggregatesFilter | Date | string | null
    thumbnail_path?: StringNullableWithAggregatesFilter | string | null
  }

  export type characterCreateInput = {
    slug?: string | null
    name?: string | null
    image_path?: string | null
    character_rank_bonus?: character_rank_bonusCreateNestedManyWithoutCharacterInput
    costume?: costumeCreateNestedManyWithoutCharacterInput
  }

  export type characterUncheckedCreateInput = {
    character_id?: number
    slug?: string | null
    name?: string | null
    image_path?: string | null
    character_rank_bonus?: character_rank_bonusUncheckedCreateNestedManyWithoutCharacterInput
    costume?: costumeUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type characterUpdateInput = {
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    character_rank_bonus?: character_rank_bonusUpdateManyWithoutCharacterInput
    costume?: costumeUpdateManyWithoutCharacterInput
  }

  export type characterUncheckedUpdateInput = {
    character_id?: IntFieldUpdateOperationsInput | number
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    character_rank_bonus?: character_rank_bonusUncheckedUpdateManyWithoutCharacterInput
    costume?: costumeUncheckedUpdateManyWithoutCharacterInput
  }

  export type characterCreateManyInput = {
    character_id?: number
    slug?: string | null
    name?: string | null
    image_path?: string | null
  }

  export type characterUpdateManyMutationInput = {
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type characterUncheckedUpdateManyInput = {
    character_id?: IntFieldUpdateOperationsInput | number
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type character_rank_bonusCreateInput = {
    rank_bonus_id: number
    rank_bonus_level: number
    description?: string | null
    stat?: string | null
    type?: string | null
    amount: number
    character: characterCreateNestedOneWithoutCharacter_rank_bonusInput
  }

  export type character_rank_bonusUncheckedCreateInput = {
    rank_bonus_id: number
    rank_bonus_level: number
    character_id: number
    description?: string | null
    stat?: string | null
    type?: string | null
    amount: number
  }

  export type character_rank_bonusUpdateInput = {
    rank_bonus_id?: IntFieldUpdateOperationsInput | number
    rank_bonus_level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
    character?: characterUpdateOneRequiredWithoutCharacter_rank_bonusInput
  }

  export type character_rank_bonusUncheckedUpdateInput = {
    rank_bonus_id?: IntFieldUpdateOperationsInput | number
    rank_bonus_level?: IntFieldUpdateOperationsInput | number
    character_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type character_rank_bonusCreateManyInput = {
    rank_bonus_id: number
    rank_bonus_level: number
    character_id: number
    description?: string | null
    stat?: string | null
    type?: string | null
    amount: number
  }

  export type character_rank_bonusUpdateManyMutationInput = {
    rank_bonus_id?: IntFieldUpdateOperationsInput | number
    rank_bonus_level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type character_rank_bonusUncheckedUpdateManyInput = {
    rank_bonus_id?: IntFieldUpdateOperationsInput | number
    rank_bonus_level?: IntFieldUpdateOperationsInput | number
    character_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type companionCreateInput = {
    attribute?: string | null
    type?: string | null
    release_time: Date | string
    name?: string | null
    story?: string | null
    image_path_base?: string | null
    companion_ability_link?: companion_ability_linkCreateNestedManyWithoutCompanionInput
    companion_skill_link?: companion_skill_linkCreateNestedManyWithoutCompanionInput
    companion_stat?: companion_statCreateNestedManyWithoutCompanionInput
  }

  export type companionUncheckedCreateInput = {
    companion_id?: number
    attribute?: string | null
    type?: string | null
    release_time: Date | string
    name?: string | null
    story?: string | null
    image_path_base?: string | null
    companion_ability_link?: companion_ability_linkUncheckedCreateNestedManyWithoutCompanionInput
    companion_skill_link?: companion_skill_linkUncheckedCreateNestedManyWithoutCompanionInput
    companion_stat?: companion_statUncheckedCreateNestedManyWithoutCompanionInput
  }

  export type companionUpdateInput = {
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    companion_ability_link?: companion_ability_linkUpdateManyWithoutCompanionInput
    companion_skill_link?: companion_skill_linkUpdateManyWithoutCompanionInput
    companion_stat?: companion_statUpdateManyWithoutCompanionInput
  }

  export type companionUncheckedUpdateInput = {
    companion_id?: IntFieldUpdateOperationsInput | number
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    companion_ability_link?: companion_ability_linkUncheckedUpdateManyWithoutCompanionInput
    companion_skill_link?: companion_skill_linkUncheckedUpdateManyWithoutCompanionInput
    companion_stat?: companion_statUncheckedUpdateManyWithoutCompanionInput
  }

  export type companionCreateManyInput = {
    companion_id?: number
    attribute?: string | null
    type?: string | null
    release_time: Date | string
    name?: string | null
    story?: string | null
    image_path_base?: string | null
  }

  export type companionUpdateManyMutationInput = {
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type companionUncheckedUpdateManyInput = {
    companion_id?: IntFieldUpdateOperationsInput | number
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type companion_abilityCreateInput = {
    ability_id: number
    ability_level: number
    name?: string | null
    description?: string | null
    image_path_base?: string | null
    companion_ability_link?: companion_ability_linkCreateNestedManyWithoutCompanion_abilityInput
  }

  export type companion_abilityUncheckedCreateInput = {
    ability_id: number
    ability_level: number
    name?: string | null
    description?: string | null
    image_path_base?: string | null
    companion_ability_link?: companion_ability_linkUncheckedCreateNestedManyWithoutCompanion_abilityInput
  }

  export type companion_abilityUpdateInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    companion_ability_link?: companion_ability_linkUpdateManyWithoutCompanion_abilityInput
  }

  export type companion_abilityUncheckedUpdateInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    companion_ability_link?: companion_ability_linkUncheckedUpdateManyWithoutCompanion_abilityInput
  }

  export type companion_abilityCreateManyInput = {
    ability_id: number
    ability_level: number
    name?: string | null
    description?: string | null
    image_path_base?: string | null
  }

  export type companion_abilityUpdateManyMutationInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type companion_abilityUncheckedUpdateManyInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type companion_ability_linkCreateInput = {
    companion_level: number
    companion_ability: companion_abilityCreateNestedOneWithoutCompanion_ability_linkInput
    companion: companionCreateNestedOneWithoutCompanion_ability_linkInput
  }

  export type companion_ability_linkUncheckedCreateInput = {
    companion_id: number
    companion_level: number
    ability_id: number
    ability_level: number
  }

  export type companion_ability_linkUpdateInput = {
    companion_level?: IntFieldUpdateOperationsInput | number
    companion_ability?: companion_abilityUpdateOneRequiredWithoutCompanion_ability_linkInput
    companion?: companionUpdateOneRequiredWithoutCompanion_ability_linkInput
  }

  export type companion_ability_linkUncheckedUpdateInput = {
    companion_id?: IntFieldUpdateOperationsInput | number
    companion_level?: IntFieldUpdateOperationsInput | number
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
  }

  export type companion_ability_linkCreateManyInput = {
    companion_id: number
    companion_level: number
    ability_id: number
    ability_level: number
  }

  export type companion_ability_linkUpdateManyMutationInput = {
    companion_level?: IntFieldUpdateOperationsInput | number
  }

  export type companion_ability_linkUncheckedUpdateManyInput = {
    companion_id?: IntFieldUpdateOperationsInput | number
    companion_level?: IntFieldUpdateOperationsInput | number
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
  }

  export type companion_skillCreateInput = {
    skill_id: number
    skill_level: number
    cooldown_time: number
    name?: string | null
    description?: string | null
    short_description?: string | null
    image_path?: string | null
    companion_skill_link?: companion_skill_linkCreateNestedManyWithoutCompanion_skillInput
  }

  export type companion_skillUncheckedCreateInput = {
    skill_id: number
    skill_level: number
    cooldown_time: number
    name?: string | null
    description?: string | null
    short_description?: string | null
    image_path?: string | null
    companion_skill_link?: companion_skill_linkUncheckedCreateNestedManyWithoutCompanion_skillInput
  }

  export type companion_skillUpdateInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    companion_skill_link?: companion_skill_linkUpdateManyWithoutCompanion_skillInput
  }

  export type companion_skillUncheckedUpdateInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    companion_skill_link?: companion_skill_linkUncheckedUpdateManyWithoutCompanion_skillInput
  }

  export type companion_skillCreateManyInput = {
    skill_id: number
    skill_level: number
    cooldown_time: number
    name?: string | null
    description?: string | null
    short_description?: string | null
    image_path?: string | null
  }

  export type companion_skillUpdateManyMutationInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type companion_skillUncheckedUpdateManyInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type companion_skill_linkCreateInput = {
    companion_level: number
    companion: companionCreateNestedOneWithoutCompanion_skill_linkInput
    companion_skill: companion_skillCreateNestedOneWithoutCompanion_skill_linkInput
  }

  export type companion_skill_linkUncheckedCreateInput = {
    companion_id: number
    companion_level: number
    skill_id: number
    skill_level: number
  }

  export type companion_skill_linkUpdateInput = {
    companion_level?: IntFieldUpdateOperationsInput | number
    companion?: companionUpdateOneRequiredWithoutCompanion_skill_linkInput
    companion_skill?: companion_skillUpdateOneRequiredWithoutCompanion_skill_linkInput
  }

  export type companion_skill_linkUncheckedUpdateInput = {
    companion_id?: IntFieldUpdateOperationsInput | number
    companion_level?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
  }

  export type companion_skill_linkCreateManyInput = {
    companion_id: number
    companion_level: number
    skill_id: number
    skill_level: number
  }

  export type companion_skill_linkUpdateManyMutationInput = {
    companion_level?: IntFieldUpdateOperationsInput | number
  }

  export type companion_skill_linkUncheckedUpdateManyInput = {
    companion_id?: IntFieldUpdateOperationsInput | number
    companion_level?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
  }

  export type companion_statCreateInput = {
    level: number
    atk: number
    hp: number
    vit: number
    companion: companionCreateNestedOneWithoutCompanion_statInput
  }

  export type companion_statUncheckedCreateInput = {
    companion_id: number
    level: number
    atk: number
    hp: number
    vit: number
  }

  export type companion_statUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
    companion?: companionUpdateOneRequiredWithoutCompanion_statInput
  }

  export type companion_statUncheckedUpdateInput = {
    companion_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type companion_statCreateManyInput = {
    companion_id: number
    level: number
    atk: number
    hp: number
    vit: number
  }

  export type companion_statUpdateManyMutationInput = {
    level?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type companion_statUncheckedUpdateManyInput = {
    companion_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type costumeCreateInput = {
    weapon_type?: string | null
    rarity?: string | null
    release_time: Date | string
    is_ex_costume: boolean
    slug?: string | null
    title?: string | null
    description?: string | null
    image_path_base?: string | null
    character: characterCreateNestedOneWithoutCostumeInput
    emblem?: emblemCreateNestedOneWithoutCostumeInput
    costume_ability_link?: costume_ability_linkCreateNestedManyWithoutCostumeInput
    costume_skill_link?: costume_skill_linkCreateNestedManyWithoutCostumeInput
    costume_stat?: costume_statCreateNestedManyWithoutCostumeInput
  }

  export type costumeUncheckedCreateInput = {
    costume_id?: number
    character_id: number
    emblem_id?: number | null
    weapon_type?: string | null
    rarity?: string | null
    release_time: Date | string
    is_ex_costume: boolean
    slug?: string | null
    title?: string | null
    description?: string | null
    image_path_base?: string | null
    costume_ability_link?: costume_ability_linkUncheckedCreateNestedManyWithoutCostumeInput
    costume_skill_link?: costume_skill_linkUncheckedCreateNestedManyWithoutCostumeInput
    costume_stat?: costume_statUncheckedCreateNestedManyWithoutCostumeInput
  }

  export type costumeUpdateInput = {
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_ex_costume?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    character?: characterUpdateOneRequiredWithoutCostumeInput
    emblem?: emblemUpdateOneWithoutCostumeInput
    costume_ability_link?: costume_ability_linkUpdateManyWithoutCostumeInput
    costume_skill_link?: costume_skill_linkUpdateManyWithoutCostumeInput
    costume_stat?: costume_statUpdateManyWithoutCostumeInput
  }

  export type costumeUncheckedUpdateInput = {
    costume_id?: IntFieldUpdateOperationsInput | number
    character_id?: IntFieldUpdateOperationsInput | number
    emblem_id?: NullableIntFieldUpdateOperationsInput | number | null
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_ex_costume?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    costume_ability_link?: costume_ability_linkUncheckedUpdateManyWithoutCostumeInput
    costume_skill_link?: costume_skill_linkUncheckedUpdateManyWithoutCostumeInput
    costume_stat?: costume_statUncheckedUpdateManyWithoutCostumeInput
  }

  export type costumeCreateManyInput = {
    costume_id?: number
    character_id: number
    emblem_id?: number | null
    weapon_type?: string | null
    rarity?: string | null
    release_time: Date | string
    is_ex_costume: boolean
    slug?: string | null
    title?: string | null
    description?: string | null
    image_path_base?: string | null
  }

  export type costumeUpdateManyMutationInput = {
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_ex_costume?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type costumeUncheckedUpdateManyInput = {
    costume_id?: IntFieldUpdateOperationsInput | number
    character_id?: IntFieldUpdateOperationsInput | number
    emblem_id?: NullableIntFieldUpdateOperationsInput | number | null
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_ex_costume?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type costume_abilityCreateInput = {
    ability_id: number
    ability_level: number
    name?: string | null
    description?: string | null
    image_path_base?: string | null
    costume_ability_link?: costume_ability_linkCreateNestedManyWithoutCostume_abilityInput
  }

  export type costume_abilityUncheckedCreateInput = {
    ability_id: number
    ability_level: number
    name?: string | null
    description?: string | null
    image_path_base?: string | null
    costume_ability_link?: costume_ability_linkUncheckedCreateNestedManyWithoutCostume_abilityInput
  }

  export type costume_abilityUpdateInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    costume_ability_link?: costume_ability_linkUpdateManyWithoutCostume_abilityInput
  }

  export type costume_abilityUncheckedUpdateInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    costume_ability_link?: costume_ability_linkUncheckedUpdateManyWithoutCostume_abilityInput
  }

  export type costume_abilityCreateManyInput = {
    ability_id: number
    ability_level: number
    name?: string | null
    description?: string | null
    image_path_base?: string | null
  }

  export type costume_abilityUpdateManyMutationInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type costume_abilityUncheckedUpdateManyInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type costume_ability_linkCreateInput = {
    ability_slot: number
    costume_ability: costume_abilityCreateNestedOneWithoutCostume_ability_linkInput
    costume: costumeCreateNestedOneWithoutCostume_ability_linkInput
  }

  export type costume_ability_linkUncheckedCreateInput = {
    costume_id: number
    ability_slot: number
    ability_id: number
    ability_level: number
  }

  export type costume_ability_linkUpdateInput = {
    ability_slot?: IntFieldUpdateOperationsInput | number
    costume_ability?: costume_abilityUpdateOneRequiredWithoutCostume_ability_linkInput
    costume?: costumeUpdateOneRequiredWithoutCostume_ability_linkInput
  }

  export type costume_ability_linkUncheckedUpdateInput = {
    costume_id?: IntFieldUpdateOperationsInput | number
    ability_slot?: IntFieldUpdateOperationsInput | number
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
  }

  export type costume_ability_linkCreateManyInput = {
    costume_id: number
    ability_slot: number
    ability_id: number
    ability_level: number
  }

  export type costume_ability_linkUpdateManyMutationInput = {
    ability_slot?: IntFieldUpdateOperationsInput | number
  }

  export type costume_ability_linkUncheckedUpdateManyInput = {
    costume_id?: IntFieldUpdateOperationsInput | number
    ability_slot?: IntFieldUpdateOperationsInput | number
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
  }

  export type costume_skillCreateInput = {
    skill_id: number
    skill_level: number
    gauge_rise_speed?: string | null
    cooldown_time: number
    name?: string | null
    description?: string | null
    short_description?: string | null
    image_path?: string | null
    costume_skill_link?: costume_skill_linkCreateNestedManyWithoutCostume_skillInput
  }

  export type costume_skillUncheckedCreateInput = {
    skill_id: number
    skill_level: number
    gauge_rise_speed?: string | null
    cooldown_time: number
    name?: string | null
    description?: string | null
    short_description?: string | null
    image_path?: string | null
    costume_skill_link?: costume_skill_linkUncheckedCreateNestedManyWithoutCostume_skillInput
  }

  export type costume_skillUpdateInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    gauge_rise_speed?: NullableStringFieldUpdateOperationsInput | string | null
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    costume_skill_link?: costume_skill_linkUpdateManyWithoutCostume_skillInput
  }

  export type costume_skillUncheckedUpdateInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    gauge_rise_speed?: NullableStringFieldUpdateOperationsInput | string | null
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    costume_skill_link?: costume_skill_linkUncheckedUpdateManyWithoutCostume_skillInput
  }

  export type costume_skillCreateManyInput = {
    skill_id: number
    skill_level: number
    gauge_rise_speed?: string | null
    cooldown_time: number
    name?: string | null
    description?: string | null
    short_description?: string | null
    image_path?: string | null
  }

  export type costume_skillUpdateManyMutationInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    gauge_rise_speed?: NullableStringFieldUpdateOperationsInput | string | null
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type costume_skillUncheckedUpdateManyInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    gauge_rise_speed?: NullableStringFieldUpdateOperationsInput | string | null
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type costume_skill_linkCreateInput = {
    costume: costumeCreateNestedOneWithoutCostume_skill_linkInput
    costume_skill: costume_skillCreateNestedOneWithoutCostume_skill_linkInput
  }

  export type costume_skill_linkUncheckedCreateInput = {
    costume_id: number
    skill_id: number
    skill_level: number
  }

  export type costume_skill_linkUpdateInput = {
    costume?: costumeUpdateOneRequiredWithoutCostume_skill_linkInput
    costume_skill?: costume_skillUpdateOneRequiredWithoutCostume_skill_linkInput
  }

  export type costume_skill_linkUncheckedUpdateInput = {
    costume_id?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
  }

  export type costume_skill_linkCreateManyInput = {
    costume_id: number
    skill_id: number
    skill_level: number
  }

  export type costume_skill_linkUpdateManyMutationInput = {

  }

  export type costume_skill_linkUncheckedUpdateManyInput = {
    costume_id?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
  }

  export type costume_statCreateInput = {
    level: number
    agi: number
    atk: number
    crit_atk: number
    crit_rate: number
    eva_rate: number
    hp: number
    vit: number
    costume: costumeCreateNestedOneWithoutCostume_statInput
  }

  export type costume_statUncheckedCreateInput = {
    costume_id: number
    level: number
    agi: number
    atk: number
    crit_atk: number
    crit_rate: number
    eva_rate: number
    hp: number
    vit: number
  }

  export type costume_statUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    agi?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    crit_atk?: IntFieldUpdateOperationsInput | number
    crit_rate?: IntFieldUpdateOperationsInput | number
    eva_rate?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
    costume?: costumeUpdateOneRequiredWithoutCostume_statInput
  }

  export type costume_statUncheckedUpdateInput = {
    costume_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    agi?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    crit_atk?: IntFieldUpdateOperationsInput | number
    crit_rate?: IntFieldUpdateOperationsInput | number
    eva_rate?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type costume_statCreateManyInput = {
    costume_id: number
    level: number
    agi: number
    atk: number
    crit_atk: number
    crit_rate: number
    eva_rate: number
    hp: number
    vit: number
  }

  export type costume_statUpdateManyMutationInput = {
    level?: IntFieldUpdateOperationsInput | number
    agi?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    crit_atk?: IntFieldUpdateOperationsInput | number
    crit_rate?: IntFieldUpdateOperationsInput | number
    eva_rate?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type costume_statUncheckedUpdateManyInput = {
    costume_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    agi?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    crit_atk?: IntFieldUpdateOperationsInput | number
    crit_rate?: IntFieldUpdateOperationsInput | number
    eva_rate?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type emblemCreateInput = {
    name?: string | null
    main_message?: string | null
    small_messages?: string | null
    image_path?: string | null
    costume?: costumeCreateNestedManyWithoutEmblemInput
  }

  export type emblemUncheckedCreateInput = {
    emblem_id?: number
    name?: string | null
    main_message?: string | null
    small_messages?: string | null
    image_path?: string | null
    costume?: costumeUncheckedCreateNestedManyWithoutEmblemInput
  }

  export type emblemUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    main_message?: NullableStringFieldUpdateOperationsInput | string | null
    small_messages?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    costume?: costumeUpdateManyWithoutEmblemInput
  }

  export type emblemUncheckedUpdateInput = {
    emblem_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    main_message?: NullableStringFieldUpdateOperationsInput | string | null
    small_messages?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    costume?: costumeUncheckedUpdateManyWithoutEmblemInput
  }

  export type emblemCreateManyInput = {
    emblem_id?: number
    name?: string | null
    main_message?: string | null
    small_messages?: string | null
    image_path?: string | null
  }

  export type emblemUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    main_message?: NullableStringFieldUpdateOperationsInput | string | null
    small_messages?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type emblemUncheckedUpdateManyInput = {
    emblem_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    main_message?: NullableStringFieldUpdateOperationsInput | string | null
    small_messages?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type memoirCreateInput = {
    memoir_id: number
    lottery_id: number
    rarity?: string | null
    release_time: Date | string
    name?: string | null
    story?: string | null
    image_path_base?: string | null
    memoir_series?: memoir_seriesCreateNestedOneWithoutMemoirInput
  }

  export type memoirUncheckedCreateInput = {
    memoir_id: number
    lottery_id: number
    rarity?: string | null
    release_time: Date | string
    name?: string | null
    story?: string | null
    image_path_base?: string | null
    memoir_series_id?: number | null
  }

  export type memoirUpdateInput = {
    memoir_id?: IntFieldUpdateOperationsInput | number
    lottery_id?: IntFieldUpdateOperationsInput | number
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    memoir_series?: memoir_seriesUpdateOneWithoutMemoirInput
  }

  export type memoirUncheckedUpdateInput = {
    memoir_id?: IntFieldUpdateOperationsInput | number
    lottery_id?: IntFieldUpdateOperationsInput | number
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    memoir_series_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type memoirCreateManyInput = {
    memoir_id: number
    lottery_id: number
    rarity?: string | null
    release_time: Date | string
    name?: string | null
    story?: string | null
    image_path_base?: string | null
    memoir_series_id?: number | null
  }

  export type memoirUpdateManyMutationInput = {
    memoir_id?: IntFieldUpdateOperationsInput | number
    lottery_id?: IntFieldUpdateOperationsInput | number
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type memoirUncheckedUpdateManyInput = {
    memoir_id?: IntFieldUpdateOperationsInput | number
    lottery_id?: IntFieldUpdateOperationsInput | number
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    memoir_series_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type memoir_seriesCreateInput = {
    name?: string | null
    small_set_description?: string | null
    large_set_description?: string | null
    memoir?: memoirCreateNestedManyWithoutMemoir_seriesInput
  }

  export type memoir_seriesUncheckedCreateInput = {
    memoir_series_id?: number
    name?: string | null
    small_set_description?: string | null
    large_set_description?: string | null
    memoir?: memoirUncheckedCreateNestedManyWithoutMemoir_seriesInput
  }

  export type memoir_seriesUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    small_set_description?: NullableStringFieldUpdateOperationsInput | string | null
    large_set_description?: NullableStringFieldUpdateOperationsInput | string | null
    memoir?: memoirUpdateManyWithoutMemoir_seriesInput
  }

  export type memoir_seriesUncheckedUpdateInput = {
    memoir_series_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    small_set_description?: NullableStringFieldUpdateOperationsInput | string | null
    large_set_description?: NullableStringFieldUpdateOperationsInput | string | null
    memoir?: memoirUncheckedUpdateManyWithoutMemoir_seriesInput
  }

  export type memoir_seriesCreateManyInput = {
    memoir_series_id?: number
    name?: string | null
    small_set_description?: string | null
    large_set_description?: string | null
  }

  export type memoir_seriesUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    small_set_description?: NullableStringFieldUpdateOperationsInput | string | null
    large_set_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type memoir_seriesUncheckedUpdateManyInput = {
    memoir_series_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    small_set_description?: NullableStringFieldUpdateOperationsInput | string | null
    large_set_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type weaponCreateInput = {
    evolution_group_id: number
    evolution_order: number
    weapon_type?: string | null
    rarity?: string | null
    attribute?: string | null
    is_ex_weapon: boolean
    release_time?: Date | string | null
    slug?: string | null
    name?: string | null
    image_path?: string | null
    weapon_ability_link?: weapon_ability_linkCreateNestedManyWithoutWeaponInput
    weapon_skill_link?: weapon_skill_linkCreateNestedManyWithoutWeaponInput
    weapon_stat?: weapon_statCreateNestedManyWithoutWeaponInput
    weapon_story_link?: weapon_story_linkCreateNestedManyWithoutWeaponInput
  }

  export type weaponUncheckedCreateInput = {
    weapon_id?: number
    evolution_group_id: number
    evolution_order: number
    weapon_type?: string | null
    rarity?: string | null
    attribute?: string | null
    is_ex_weapon: boolean
    release_time?: Date | string | null
    slug?: string | null
    name?: string | null
    image_path?: string | null
    weapon_ability_link?: weapon_ability_linkUncheckedCreateNestedManyWithoutWeaponInput
    weapon_skill_link?: weapon_skill_linkUncheckedCreateNestedManyWithoutWeaponInput
    weapon_stat?: weapon_statUncheckedCreateNestedManyWithoutWeaponInput
    weapon_story_link?: weapon_story_linkUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type weaponUpdateInput = {
    evolution_group_id?: IntFieldUpdateOperationsInput | number
    evolution_order?: IntFieldUpdateOperationsInput | number
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    is_ex_weapon?: BoolFieldUpdateOperationsInput | boolean
    release_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    weapon_ability_link?: weapon_ability_linkUpdateManyWithoutWeaponInput
    weapon_skill_link?: weapon_skill_linkUpdateManyWithoutWeaponInput
    weapon_stat?: weapon_statUpdateManyWithoutWeaponInput
    weapon_story_link?: weapon_story_linkUpdateManyWithoutWeaponInput
  }

  export type weaponUncheckedUpdateInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
    evolution_group_id?: IntFieldUpdateOperationsInput | number
    evolution_order?: IntFieldUpdateOperationsInput | number
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    is_ex_weapon?: BoolFieldUpdateOperationsInput | boolean
    release_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    weapon_ability_link?: weapon_ability_linkUncheckedUpdateManyWithoutWeaponInput
    weapon_skill_link?: weapon_skill_linkUncheckedUpdateManyWithoutWeaponInput
    weapon_stat?: weapon_statUncheckedUpdateManyWithoutWeaponInput
    weapon_story_link?: weapon_story_linkUncheckedUpdateManyWithoutWeaponInput
  }

  export type weaponCreateManyInput = {
    weapon_id?: number
    evolution_group_id: number
    evolution_order: number
    weapon_type?: string | null
    rarity?: string | null
    attribute?: string | null
    is_ex_weapon: boolean
    release_time?: Date | string | null
    slug?: string | null
    name?: string | null
    image_path?: string | null
  }

  export type weaponUpdateManyMutationInput = {
    evolution_group_id?: IntFieldUpdateOperationsInput | number
    evolution_order?: IntFieldUpdateOperationsInput | number
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    is_ex_weapon?: BoolFieldUpdateOperationsInput | boolean
    release_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type weaponUncheckedUpdateManyInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
    evolution_group_id?: IntFieldUpdateOperationsInput | number
    evolution_order?: IntFieldUpdateOperationsInput | number
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    is_ex_weapon?: BoolFieldUpdateOperationsInput | boolean
    release_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type weapon_abilityCreateInput = {
    ability_id: number
    ability_level: number
    name?: string | null
    description?: string | null
    image_path_base?: string | null
    weapon_ability_link?: weapon_ability_linkCreateNestedManyWithoutWeapon_abilityInput
  }

  export type weapon_abilityUncheckedCreateInput = {
    ability_id: number
    ability_level: number
    name?: string | null
    description?: string | null
    image_path_base?: string | null
    weapon_ability_link?: weapon_ability_linkUncheckedCreateNestedManyWithoutWeapon_abilityInput
  }

  export type weapon_abilityUpdateInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    weapon_ability_link?: weapon_ability_linkUpdateManyWithoutWeapon_abilityInput
  }

  export type weapon_abilityUncheckedUpdateInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    weapon_ability_link?: weapon_ability_linkUncheckedUpdateManyWithoutWeapon_abilityInput
  }

  export type weapon_abilityCreateManyInput = {
    ability_id: number
    ability_level: number
    name?: string | null
    description?: string | null
    image_path_base?: string | null
  }

  export type weapon_abilityUpdateManyMutationInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type weapon_abilityUncheckedUpdateManyInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type weapon_ability_linkCreateInput = {
    slot_number: number
    weapon_ability: weapon_abilityCreateNestedOneWithoutWeapon_ability_linkInput
    weapon: weaponCreateNestedOneWithoutWeapon_ability_linkInput
  }

  export type weapon_ability_linkUncheckedCreateInput = {
    weapon_id: number
    slot_number: number
    ability_id: number
    ability_level: number
  }

  export type weapon_ability_linkUpdateInput = {
    slot_number?: IntFieldUpdateOperationsInput | number
    weapon_ability?: weapon_abilityUpdateOneRequiredWithoutWeapon_ability_linkInput
    weapon?: weaponUpdateOneRequiredWithoutWeapon_ability_linkInput
  }

  export type weapon_ability_linkUncheckedUpdateInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
    slot_number?: IntFieldUpdateOperationsInput | number
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_ability_linkCreateManyInput = {
    weapon_id: number
    slot_number: number
    ability_id: number
    ability_level: number
  }

  export type weapon_ability_linkUpdateManyMutationInput = {
    slot_number?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_ability_linkUncheckedUpdateManyInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
    slot_number?: IntFieldUpdateOperationsInput | number
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_skillCreateInput = {
    skill_id: number
    skill_level: number
    cooldown_time: number
    name?: string | null
    description?: string | null
    short_description?: string | null
    image_path?: string | null
    weapon_skill_link?: weapon_skill_linkCreateNestedManyWithoutWeapon_skillInput
  }

  export type weapon_skillUncheckedCreateInput = {
    skill_id: number
    skill_level: number
    cooldown_time: number
    name?: string | null
    description?: string | null
    short_description?: string | null
    image_path?: string | null
    weapon_skill_link?: weapon_skill_linkUncheckedCreateNestedManyWithoutWeapon_skillInput
  }

  export type weapon_skillUpdateInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    weapon_skill_link?: weapon_skill_linkUpdateManyWithoutWeapon_skillInput
  }

  export type weapon_skillUncheckedUpdateInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    weapon_skill_link?: weapon_skill_linkUncheckedUpdateManyWithoutWeapon_skillInput
  }

  export type weapon_skillCreateManyInput = {
    skill_id: number
    skill_level: number
    cooldown_time: number
    name?: string | null
    description?: string | null
    short_description?: string | null
    image_path?: string | null
  }

  export type weapon_skillUpdateManyMutationInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type weapon_skillUncheckedUpdateManyInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type weapon_skill_linkCreateInput = {
    slot_number: number
    weapon_skill: weapon_skillCreateNestedOneWithoutWeapon_skill_linkInput
    weapon: weaponCreateNestedOneWithoutWeapon_skill_linkInput
  }

  export type weapon_skill_linkUncheckedCreateInput = {
    weapon_id: number
    slot_number: number
    skill_id: number
    skill_level: number
  }

  export type weapon_skill_linkUpdateInput = {
    slot_number?: IntFieldUpdateOperationsInput | number
    weapon_skill?: weapon_skillUpdateOneRequiredWithoutWeapon_skill_linkInput
    weapon?: weaponUpdateOneRequiredWithoutWeapon_skill_linkInput
  }

  export type weapon_skill_linkUncheckedUpdateInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
    slot_number?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_skill_linkCreateManyInput = {
    weapon_id: number
    slot_number: number
    skill_id: number
    skill_level: number
  }

  export type weapon_skill_linkUpdateManyMutationInput = {
    slot_number?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_skill_linkUncheckedUpdateManyInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
    slot_number?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_statCreateInput = {
    level: number
    atk: number
    hp: number
    vit: number
    weapon: weaponCreateNestedOneWithoutWeapon_statInput
  }

  export type weapon_statUncheckedCreateInput = {
    weapon_id: number
    level: number
    atk: number
    hp: number
    vit: number
  }

  export type weapon_statUpdateInput = {
    level?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
    weapon?: weaponUpdateOneRequiredWithoutWeapon_statInput
  }

  export type weapon_statUncheckedUpdateInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_statCreateManyInput = {
    weapon_id: number
    level: number
    atk: number
    hp: number
    vit: number
  }

  export type weapon_statUpdateManyMutationInput = {
    level?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_statUncheckedUpdateManyInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_storyCreateInput = {
    story?: string | null
    weapon_story_link?: weapon_story_linkCreateNestedManyWithoutWeapon_storyInput
  }

  export type weapon_storyUncheckedCreateInput = {
    id?: number
    story?: string | null
    weapon_story_link?: weapon_story_linkUncheckedCreateNestedManyWithoutWeapon_storyInput
  }

  export type weapon_storyUpdateInput = {
    story?: NullableStringFieldUpdateOperationsInput | string | null
    weapon_story_link?: weapon_story_linkUpdateManyWithoutWeapon_storyInput
  }

  export type weapon_storyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    story?: NullableStringFieldUpdateOperationsInput | string | null
    weapon_story_link?: weapon_story_linkUncheckedUpdateManyWithoutWeapon_storyInput
  }

  export type weapon_storyCreateManyInput = {
    id?: number
    story?: string | null
  }

  export type weapon_storyUpdateManyMutationInput = {
    story?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type weapon_storyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    story?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type weapon_story_linkCreateInput = {
    weapon: weaponCreateNestedOneWithoutWeapon_story_linkInput
    weapon_story: weapon_storyCreateNestedOneWithoutWeapon_story_linkInput
  }

  export type weapon_story_linkUncheckedCreateInput = {
    weapon_id: number
    weapon_story_id: number
  }

  export type weapon_story_linkUpdateInput = {
    weapon?: weaponUpdateOneRequiredWithoutWeapon_story_linkInput
    weapon_story?: weapon_storyUpdateOneRequiredWithoutWeapon_story_linkInput
  }

  export type weapon_story_linkUncheckedUpdateInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
    weapon_story_id?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_story_linkCreateManyInput = {
    weapon_id: number
    weapon_story_id: number
  }

  export type weapon_story_linkUpdateManyMutationInput = {

  }

  export type weapon_story_linkUncheckedUpdateManyInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
    weapon_story_id?: IntFieldUpdateOperationsInput | number
  }

  export type debrisCreateInput = {
    rarity: number
    release_time: Date | string
    name?: string | null
    image_path_base?: string | null
  }

  export type debrisUncheckedCreateInput = {
    debris_id?: number
    rarity: number
    release_time: Date | string
    name?: string | null
    image_path_base?: string | null
  }

  export type debrisUpdateInput = {
    rarity?: IntFieldUpdateOperationsInput | number
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type debrisUncheckedUpdateInput = {
    debris_id?: IntFieldUpdateOperationsInput | number
    rarity?: IntFieldUpdateOperationsInput | number
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type debrisCreateManyInput = {
    debris_id?: number
    rarity: number
    release_time: Date | string
    name?: string | null
    image_path_base?: string | null
  }

  export type debrisUpdateManyMutationInput = {
    rarity?: IntFieldUpdateOperationsInput | number
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type debrisUncheckedUpdateManyInput = {
    debris_id?: IntFieldUpdateOperationsInput | number
    rarity?: IntFieldUpdateOperationsInput | number
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notificationCreateInput = {
    information_type?: string | null
    title?: string | null
    body?: string | null
    release_time?: Date | string | null
    thumbnail_path?: string | null
  }

  export type notificationUncheckedCreateInput = {
    notification_id?: number
    information_type?: string | null
    title?: string | null
    body?: string | null
    release_time?: Date | string | null
    thumbnail_path?: string | null
  }

  export type notificationUpdateInput = {
    information_type?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notificationUncheckedUpdateInput = {
    notification_id?: IntFieldUpdateOperationsInput | number
    information_type?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notificationCreateManyInput = {
    notification_id?: number
    information_type?: string | null
    title?: string | null
    body?: string | null
    release_time?: Date | string | null
    thumbnail_path?: string | null
  }

  export type notificationUpdateManyMutationInput = {
    information_type?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notificationUncheckedUpdateManyInput = {
    notification_id?: IntFieldUpdateOperationsInput | number
    information_type?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    body?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type Character_rank_bonusListRelationFilter = {
    every?: character_rank_bonusWhereInput
    some?: character_rank_bonusWhereInput
    none?: character_rank_bonusWhereInput
  }

  export type CostumeListRelationFilter = {
    every?: costumeWhereInput
    some?: costumeWhereInput
    none?: costumeWhereInput
  }

  export type character_rank_bonusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type costumeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type characterCountOrderByAggregateInput = {
    character_id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    image_path?: SortOrder
  }

  export type characterAvgOrderByAggregateInput = {
    character_id?: SortOrder
  }

  export type characterMaxOrderByAggregateInput = {
    character_id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    image_path?: SortOrder
  }

  export type characterMinOrderByAggregateInput = {
    character_id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    image_path?: SortOrder
  }

  export type characterSumOrderByAggregateInput = {
    character_id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type CharacterRelationFilter = {
    is?: characterWhereInput
    isNot?: characterWhereInput
  }

  export type character_rank_bonusRank_bonus_idRank_bonus_levelCompoundUniqueInput = {
    rank_bonus_id: number
    rank_bonus_level: number
  }

  export type character_rank_bonusCountOrderByAggregateInput = {
    rank_bonus_id?: SortOrder
    rank_bonus_level?: SortOrder
    character_id?: SortOrder
    description?: SortOrder
    stat?: SortOrder
    type?: SortOrder
    amount?: SortOrder
  }

  export type character_rank_bonusAvgOrderByAggregateInput = {
    rank_bonus_id?: SortOrder
    rank_bonus_level?: SortOrder
    character_id?: SortOrder
    amount?: SortOrder
  }

  export type character_rank_bonusMaxOrderByAggregateInput = {
    rank_bonus_id?: SortOrder
    rank_bonus_level?: SortOrder
    character_id?: SortOrder
    description?: SortOrder
    stat?: SortOrder
    type?: SortOrder
    amount?: SortOrder
  }

  export type character_rank_bonusMinOrderByAggregateInput = {
    rank_bonus_id?: SortOrder
    rank_bonus_level?: SortOrder
    character_id?: SortOrder
    description?: SortOrder
    stat?: SortOrder
    type?: SortOrder
    amount?: SortOrder
  }

  export type character_rank_bonusSumOrderByAggregateInput = {
    rank_bonus_id?: SortOrder
    rank_bonus_level?: SortOrder
    character_id?: SortOrder
    amount?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type Companion_ability_linkListRelationFilter = {
    every?: companion_ability_linkWhereInput
    some?: companion_ability_linkWhereInput
    none?: companion_ability_linkWhereInput
  }

  export type Companion_skill_linkListRelationFilter = {
    every?: companion_skill_linkWhereInput
    some?: companion_skill_linkWhereInput
    none?: companion_skill_linkWhereInput
  }

  export type Companion_statListRelationFilter = {
    every?: companion_statWhereInput
    some?: companion_statWhereInput
    none?: companion_statWhereInput
  }

  export type companion_ability_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companion_skill_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companion_statOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companionCountOrderByAggregateInput = {
    companion_id?: SortOrder
    attribute?: SortOrder
    type?: SortOrder
    release_time?: SortOrder
    name?: SortOrder
    story?: SortOrder
    image_path_base?: SortOrder
  }

  export type companionAvgOrderByAggregateInput = {
    companion_id?: SortOrder
  }

  export type companionMaxOrderByAggregateInput = {
    companion_id?: SortOrder
    attribute?: SortOrder
    type?: SortOrder
    release_time?: SortOrder
    name?: SortOrder
    story?: SortOrder
    image_path_base?: SortOrder
  }

  export type companionMinOrderByAggregateInput = {
    companion_id?: SortOrder
    attribute?: SortOrder
    type?: SortOrder
    release_time?: SortOrder
    name?: SortOrder
    story?: SortOrder
    image_path_base?: SortOrder
  }

  export type companionSumOrderByAggregateInput = {
    companion_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type companion_abilityAbility_idAbility_levelCompoundUniqueInput = {
    ability_id: number
    ability_level: number
  }

  export type companion_abilityCountOrderByAggregateInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
  }

  export type companion_abilityAvgOrderByAggregateInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type companion_abilityMaxOrderByAggregateInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
  }

  export type companion_abilityMinOrderByAggregateInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
  }

  export type companion_abilitySumOrderByAggregateInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type Companion_abilityRelationFilter = {
    is?: companion_abilityWhereInput
    isNot?: companion_abilityWhereInput
  }

  export type CompanionRelationFilter = {
    is?: companionWhereInput
    isNot?: companionWhereInput
  }

  export type companion_ability_linkCompanion_idCompanion_levelAbility_idAbility_levelCompoundUniqueInput = {
    companion_id: number
    companion_level: number
    ability_id: number
    ability_level: number
  }

  export type companion_ability_linkCountOrderByAggregateInput = {
    companion_id?: SortOrder
    companion_level?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type companion_ability_linkAvgOrderByAggregateInput = {
    companion_id?: SortOrder
    companion_level?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type companion_ability_linkMaxOrderByAggregateInput = {
    companion_id?: SortOrder
    companion_level?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type companion_ability_linkMinOrderByAggregateInput = {
    companion_id?: SortOrder
    companion_level?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type companion_ability_linkSumOrderByAggregateInput = {
    companion_id?: SortOrder
    companion_level?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type companion_skillSkill_idSkill_levelCompoundUniqueInput = {
    skill_id: number
    skill_level: number
  }

  export type companion_skillCountOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    cooldown_time?: SortOrder
    name?: SortOrder
    description?: SortOrder
    short_description?: SortOrder
    image_path?: SortOrder
  }

  export type companion_skillAvgOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    cooldown_time?: SortOrder
  }

  export type companion_skillMaxOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    cooldown_time?: SortOrder
    name?: SortOrder
    description?: SortOrder
    short_description?: SortOrder
    image_path?: SortOrder
  }

  export type companion_skillMinOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    cooldown_time?: SortOrder
    name?: SortOrder
    description?: SortOrder
    short_description?: SortOrder
    image_path?: SortOrder
  }

  export type companion_skillSumOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    cooldown_time?: SortOrder
  }

  export type Companion_skillRelationFilter = {
    is?: companion_skillWhereInput
    isNot?: companion_skillWhereInput
  }

  export type companion_skill_linkCompanion_idCompanion_levelSkill_idSkill_levelCompoundUniqueInput = {
    companion_id: number
    companion_level: number
    skill_id: number
    skill_level: number
  }

  export type companion_skill_linkCountOrderByAggregateInput = {
    companion_id?: SortOrder
    companion_level?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
  }

  export type companion_skill_linkAvgOrderByAggregateInput = {
    companion_id?: SortOrder
    companion_level?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
  }

  export type companion_skill_linkMaxOrderByAggregateInput = {
    companion_id?: SortOrder
    companion_level?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
  }

  export type companion_skill_linkMinOrderByAggregateInput = {
    companion_id?: SortOrder
    companion_level?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
  }

  export type companion_skill_linkSumOrderByAggregateInput = {
    companion_id?: SortOrder
    companion_level?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
  }

  export type companion_statCompanion_idLevelCompoundUniqueInput = {
    companion_id: number
    level: number
  }

  export type companion_statCountOrderByAggregateInput = {
    companion_id?: SortOrder
    level?: SortOrder
    atk?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
  }

  export type companion_statAvgOrderByAggregateInput = {
    companion_id?: SortOrder
    level?: SortOrder
    atk?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
  }

  export type companion_statMaxOrderByAggregateInput = {
    companion_id?: SortOrder
    level?: SortOrder
    atk?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
  }

  export type companion_statMinOrderByAggregateInput = {
    companion_id?: SortOrder
    level?: SortOrder
    atk?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
  }

  export type companion_statSumOrderByAggregateInput = {
    companion_id?: SortOrder
    level?: SortOrder
    atk?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type EmblemRelationFilter = {
    is?: emblemWhereInput | null
    isNot?: emblemWhereInput | null
  }

  export type Costume_ability_linkListRelationFilter = {
    every?: costume_ability_linkWhereInput
    some?: costume_ability_linkWhereInput
    none?: costume_ability_linkWhereInput
  }

  export type Costume_skill_linkListRelationFilter = {
    every?: costume_skill_linkWhereInput
    some?: costume_skill_linkWhereInput
    none?: costume_skill_linkWhereInput
  }

  export type Costume_statListRelationFilter = {
    every?: costume_statWhereInput
    some?: costume_statWhereInput
    none?: costume_statWhereInput
  }

  export type costume_ability_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type costume_skill_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type costume_statOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type costumeCountOrderByAggregateInput = {
    costume_id?: SortOrder
    character_id?: SortOrder
    emblem_id?: SortOrder
    weapon_type?: SortOrder
    rarity?: SortOrder
    release_time?: SortOrder
    is_ex_costume?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
  }

  export type costumeAvgOrderByAggregateInput = {
    costume_id?: SortOrder
    character_id?: SortOrder
    emblem_id?: SortOrder
  }

  export type costumeMaxOrderByAggregateInput = {
    costume_id?: SortOrder
    character_id?: SortOrder
    emblem_id?: SortOrder
    weapon_type?: SortOrder
    rarity?: SortOrder
    release_time?: SortOrder
    is_ex_costume?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
  }

  export type costumeMinOrderByAggregateInput = {
    costume_id?: SortOrder
    character_id?: SortOrder
    emblem_id?: SortOrder
    weapon_type?: SortOrder
    rarity?: SortOrder
    release_time?: SortOrder
    is_ex_costume?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
  }

  export type costumeSumOrderByAggregateInput = {
    costume_id?: SortOrder
    character_id?: SortOrder
    emblem_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type costume_abilityAbility_idAbility_levelCompoundUniqueInput = {
    ability_id: number
    ability_level: number
  }

  export type costume_abilityCountOrderByAggregateInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
  }

  export type costume_abilityAvgOrderByAggregateInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type costume_abilityMaxOrderByAggregateInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
  }

  export type costume_abilityMinOrderByAggregateInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
  }

  export type costume_abilitySumOrderByAggregateInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type Costume_abilityRelationFilter = {
    is?: costume_abilityWhereInput
    isNot?: costume_abilityWhereInput
  }

  export type CostumeRelationFilter = {
    is?: costumeWhereInput
    isNot?: costumeWhereInput
  }

  export type costume_ability_linkCostume_idAbility_slotAbility_idAbility_levelCompoundUniqueInput = {
    costume_id: number
    ability_slot: number
    ability_id: number
    ability_level: number
  }

  export type costume_ability_linkCountOrderByAggregateInput = {
    costume_id?: SortOrder
    ability_slot?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type costume_ability_linkAvgOrderByAggregateInput = {
    costume_id?: SortOrder
    ability_slot?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type costume_ability_linkMaxOrderByAggregateInput = {
    costume_id?: SortOrder
    ability_slot?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type costume_ability_linkMinOrderByAggregateInput = {
    costume_id?: SortOrder
    ability_slot?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type costume_ability_linkSumOrderByAggregateInput = {
    costume_id?: SortOrder
    ability_slot?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type costume_skillSkill_idSkill_levelCompoundUniqueInput = {
    skill_id: number
    skill_level: number
  }

  export type costume_skillCountOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    gauge_rise_speed?: SortOrder
    cooldown_time?: SortOrder
    name?: SortOrder
    description?: SortOrder
    short_description?: SortOrder
    image_path?: SortOrder
  }

  export type costume_skillAvgOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    cooldown_time?: SortOrder
  }

  export type costume_skillMaxOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    gauge_rise_speed?: SortOrder
    cooldown_time?: SortOrder
    name?: SortOrder
    description?: SortOrder
    short_description?: SortOrder
    image_path?: SortOrder
  }

  export type costume_skillMinOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    gauge_rise_speed?: SortOrder
    cooldown_time?: SortOrder
    name?: SortOrder
    description?: SortOrder
    short_description?: SortOrder
    image_path?: SortOrder
  }

  export type costume_skillSumOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    cooldown_time?: SortOrder
  }

  export type Costume_skillRelationFilter = {
    is?: costume_skillWhereInput
    isNot?: costume_skillWhereInput
  }

  export type costume_skill_linkCostume_idSkill_idSkill_levelCompoundUniqueInput = {
    costume_id: number
    skill_id: number
    skill_level: number
  }

  export type costume_skill_linkCountOrderByAggregateInput = {
    costume_id?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
  }

  export type costume_skill_linkAvgOrderByAggregateInput = {
    costume_id?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
  }

  export type costume_skill_linkMaxOrderByAggregateInput = {
    costume_id?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
  }

  export type costume_skill_linkMinOrderByAggregateInput = {
    costume_id?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
  }

  export type costume_skill_linkSumOrderByAggregateInput = {
    costume_id?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
  }

  export type costume_statCostume_idLevelCompoundUniqueInput = {
    costume_id: number
    level: number
  }

  export type costume_statCountOrderByAggregateInput = {
    costume_id?: SortOrder
    level?: SortOrder
    agi?: SortOrder
    atk?: SortOrder
    crit_atk?: SortOrder
    crit_rate?: SortOrder
    eva_rate?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
  }

  export type costume_statAvgOrderByAggregateInput = {
    costume_id?: SortOrder
    level?: SortOrder
    agi?: SortOrder
    atk?: SortOrder
    crit_atk?: SortOrder
    crit_rate?: SortOrder
    eva_rate?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
  }

  export type costume_statMaxOrderByAggregateInput = {
    costume_id?: SortOrder
    level?: SortOrder
    agi?: SortOrder
    atk?: SortOrder
    crit_atk?: SortOrder
    crit_rate?: SortOrder
    eva_rate?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
  }

  export type costume_statMinOrderByAggregateInput = {
    costume_id?: SortOrder
    level?: SortOrder
    agi?: SortOrder
    atk?: SortOrder
    crit_atk?: SortOrder
    crit_rate?: SortOrder
    eva_rate?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
  }

  export type costume_statSumOrderByAggregateInput = {
    costume_id?: SortOrder
    level?: SortOrder
    agi?: SortOrder
    atk?: SortOrder
    crit_atk?: SortOrder
    crit_rate?: SortOrder
    eva_rate?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
  }

  export type emblemCountOrderByAggregateInput = {
    emblem_id?: SortOrder
    name?: SortOrder
    main_message?: SortOrder
    small_messages?: SortOrder
    image_path?: SortOrder
  }

  export type emblemAvgOrderByAggregateInput = {
    emblem_id?: SortOrder
  }

  export type emblemMaxOrderByAggregateInput = {
    emblem_id?: SortOrder
    name?: SortOrder
    main_message?: SortOrder
    small_messages?: SortOrder
    image_path?: SortOrder
  }

  export type emblemMinOrderByAggregateInput = {
    emblem_id?: SortOrder
    name?: SortOrder
    main_message?: SortOrder
    small_messages?: SortOrder
    image_path?: SortOrder
  }

  export type emblemSumOrderByAggregateInput = {
    emblem_id?: SortOrder
  }

  export type Memoir_seriesRelationFilter = {
    is?: memoir_seriesWhereInput | null
    isNot?: memoir_seriesWhereInput | null
  }

  export type memoirMemoir_idLottery_idCompoundUniqueInput = {
    memoir_id: number
    lottery_id: number
  }

  export type memoirCountOrderByAggregateInput = {
    memoir_id?: SortOrder
    lottery_id?: SortOrder
    rarity?: SortOrder
    release_time?: SortOrder
    name?: SortOrder
    story?: SortOrder
    image_path_base?: SortOrder
    memoir_series_id?: SortOrder
  }

  export type memoirAvgOrderByAggregateInput = {
    memoir_id?: SortOrder
    lottery_id?: SortOrder
    memoir_series_id?: SortOrder
  }

  export type memoirMaxOrderByAggregateInput = {
    memoir_id?: SortOrder
    lottery_id?: SortOrder
    rarity?: SortOrder
    release_time?: SortOrder
    name?: SortOrder
    story?: SortOrder
    image_path_base?: SortOrder
    memoir_series_id?: SortOrder
  }

  export type memoirMinOrderByAggregateInput = {
    memoir_id?: SortOrder
    lottery_id?: SortOrder
    rarity?: SortOrder
    release_time?: SortOrder
    name?: SortOrder
    story?: SortOrder
    image_path_base?: SortOrder
    memoir_series_id?: SortOrder
  }

  export type memoirSumOrderByAggregateInput = {
    memoir_id?: SortOrder
    lottery_id?: SortOrder
    memoir_series_id?: SortOrder
  }

  export type MemoirListRelationFilter = {
    every?: memoirWhereInput
    some?: memoirWhereInput
    none?: memoirWhereInput
  }

  export type memoirOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type memoir_seriesCountOrderByAggregateInput = {
    memoir_series_id?: SortOrder
    name?: SortOrder
    small_set_description?: SortOrder
    large_set_description?: SortOrder
  }

  export type memoir_seriesAvgOrderByAggregateInput = {
    memoir_series_id?: SortOrder
  }

  export type memoir_seriesMaxOrderByAggregateInput = {
    memoir_series_id?: SortOrder
    name?: SortOrder
    small_set_description?: SortOrder
    large_set_description?: SortOrder
  }

  export type memoir_seriesMinOrderByAggregateInput = {
    memoir_series_id?: SortOrder
    name?: SortOrder
    small_set_description?: SortOrder
    large_set_description?: SortOrder
  }

  export type memoir_seriesSumOrderByAggregateInput = {
    memoir_series_id?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type Weapon_ability_linkListRelationFilter = {
    every?: weapon_ability_linkWhereInput
    some?: weapon_ability_linkWhereInput
    none?: weapon_ability_linkWhereInput
  }

  export type Weapon_skill_linkListRelationFilter = {
    every?: weapon_skill_linkWhereInput
    some?: weapon_skill_linkWhereInput
    none?: weapon_skill_linkWhereInput
  }

  export type Weapon_statListRelationFilter = {
    every?: weapon_statWhereInput
    some?: weapon_statWhereInput
    none?: weapon_statWhereInput
  }

  export type Weapon_story_linkListRelationFilter = {
    every?: weapon_story_linkWhereInput
    some?: weapon_story_linkWhereInput
    none?: weapon_story_linkWhereInput
  }

  export type weapon_ability_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type weapon_skill_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type weapon_statOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type weapon_story_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type weaponEvolution_group_idEvolution_orderCompoundUniqueInput = {
    evolution_group_id: number
    evolution_order: number
  }

  export type weaponCountOrderByAggregateInput = {
    weapon_id?: SortOrder
    evolution_group_id?: SortOrder
    evolution_order?: SortOrder
    weapon_type?: SortOrder
    rarity?: SortOrder
    attribute?: SortOrder
    is_ex_weapon?: SortOrder
    release_time?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    image_path?: SortOrder
  }

  export type weaponAvgOrderByAggregateInput = {
    weapon_id?: SortOrder
    evolution_group_id?: SortOrder
    evolution_order?: SortOrder
  }

  export type weaponMaxOrderByAggregateInput = {
    weapon_id?: SortOrder
    evolution_group_id?: SortOrder
    evolution_order?: SortOrder
    weapon_type?: SortOrder
    rarity?: SortOrder
    attribute?: SortOrder
    is_ex_weapon?: SortOrder
    release_time?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    image_path?: SortOrder
  }

  export type weaponMinOrderByAggregateInput = {
    weapon_id?: SortOrder
    evolution_group_id?: SortOrder
    evolution_order?: SortOrder
    weapon_type?: SortOrder
    rarity?: SortOrder
    attribute?: SortOrder
    is_ex_weapon?: SortOrder
    release_time?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    image_path?: SortOrder
  }

  export type weaponSumOrderByAggregateInput = {
    weapon_id?: SortOrder
    evolution_group_id?: SortOrder
    evolution_order?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type weapon_abilityAbility_idAbility_levelCompoundUniqueInput = {
    ability_id: number
    ability_level: number
  }

  export type weapon_abilityCountOrderByAggregateInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
  }

  export type weapon_abilityAvgOrderByAggregateInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type weapon_abilityMaxOrderByAggregateInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
  }

  export type weapon_abilityMinOrderByAggregateInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image_path_base?: SortOrder
  }

  export type weapon_abilitySumOrderByAggregateInput = {
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type Weapon_abilityRelationFilter = {
    is?: weapon_abilityWhereInput
    isNot?: weapon_abilityWhereInput
  }

  export type WeaponRelationFilter = {
    is?: weaponWhereInput
    isNot?: weaponWhereInput
  }

  export type weapon_ability_linkWeapon_idSlot_numberAbility_idAbility_levelCompoundUniqueInput = {
    weapon_id: number
    slot_number: number
    ability_id: number
    ability_level: number
  }

  export type weapon_ability_linkCountOrderByAggregateInput = {
    weapon_id?: SortOrder
    slot_number?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type weapon_ability_linkAvgOrderByAggregateInput = {
    weapon_id?: SortOrder
    slot_number?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type weapon_ability_linkMaxOrderByAggregateInput = {
    weapon_id?: SortOrder
    slot_number?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type weapon_ability_linkMinOrderByAggregateInput = {
    weapon_id?: SortOrder
    slot_number?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type weapon_ability_linkSumOrderByAggregateInput = {
    weapon_id?: SortOrder
    slot_number?: SortOrder
    ability_id?: SortOrder
    ability_level?: SortOrder
  }

  export type weapon_skillSkill_idSkill_levelCompoundUniqueInput = {
    skill_id: number
    skill_level: number
  }

  export type weapon_skillCountOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    cooldown_time?: SortOrder
    name?: SortOrder
    description?: SortOrder
    short_description?: SortOrder
    image_path?: SortOrder
  }

  export type weapon_skillAvgOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    cooldown_time?: SortOrder
  }

  export type weapon_skillMaxOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    cooldown_time?: SortOrder
    name?: SortOrder
    description?: SortOrder
    short_description?: SortOrder
    image_path?: SortOrder
  }

  export type weapon_skillMinOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    cooldown_time?: SortOrder
    name?: SortOrder
    description?: SortOrder
    short_description?: SortOrder
    image_path?: SortOrder
  }

  export type weapon_skillSumOrderByAggregateInput = {
    skill_id?: SortOrder
    skill_level?: SortOrder
    cooldown_time?: SortOrder
  }

  export type Weapon_skillRelationFilter = {
    is?: weapon_skillWhereInput
    isNot?: weapon_skillWhereInput
  }

  export type weapon_skill_linkWeapon_idSlot_numberSkill_idSkill_levelCompoundUniqueInput = {
    weapon_id: number
    slot_number: number
    skill_id: number
    skill_level: number
  }

  export type weapon_skill_linkCountOrderByAggregateInput = {
    weapon_id?: SortOrder
    slot_number?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
  }

  export type weapon_skill_linkAvgOrderByAggregateInput = {
    weapon_id?: SortOrder
    slot_number?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
  }

  export type weapon_skill_linkMaxOrderByAggregateInput = {
    weapon_id?: SortOrder
    slot_number?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
  }

  export type weapon_skill_linkMinOrderByAggregateInput = {
    weapon_id?: SortOrder
    slot_number?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
  }

  export type weapon_skill_linkSumOrderByAggregateInput = {
    weapon_id?: SortOrder
    slot_number?: SortOrder
    skill_id?: SortOrder
    skill_level?: SortOrder
  }

  export type weapon_statWeapon_idLevelCompoundUniqueInput = {
    weapon_id: number
    level: number
  }

  export type weapon_statCountOrderByAggregateInput = {
    weapon_id?: SortOrder
    level?: SortOrder
    atk?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
  }

  export type weapon_statAvgOrderByAggregateInput = {
    weapon_id?: SortOrder
    level?: SortOrder
    atk?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
  }

  export type weapon_statMaxOrderByAggregateInput = {
    weapon_id?: SortOrder
    level?: SortOrder
    atk?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
  }

  export type weapon_statMinOrderByAggregateInput = {
    weapon_id?: SortOrder
    level?: SortOrder
    atk?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
  }

  export type weapon_statSumOrderByAggregateInput = {
    weapon_id?: SortOrder
    level?: SortOrder
    atk?: SortOrder
    hp?: SortOrder
    vit?: SortOrder
  }

  export type weapon_storyCountOrderByAggregateInput = {
    id?: SortOrder
    story?: SortOrder
  }

  export type weapon_storyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type weapon_storyMaxOrderByAggregateInput = {
    id?: SortOrder
    story?: SortOrder
  }

  export type weapon_storyMinOrderByAggregateInput = {
    id?: SortOrder
    story?: SortOrder
  }

  export type weapon_storySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Weapon_storyRelationFilter = {
    is?: weapon_storyWhereInput
    isNot?: weapon_storyWhereInput
  }

  export type weapon_story_linkWeapon_idWeapon_story_idCompoundUniqueInput = {
    weapon_id: number
    weapon_story_id: number
  }

  export type weapon_story_linkCountOrderByAggregateInput = {
    weapon_id?: SortOrder
    weapon_story_id?: SortOrder
  }

  export type weapon_story_linkAvgOrderByAggregateInput = {
    weapon_id?: SortOrder
    weapon_story_id?: SortOrder
  }

  export type weapon_story_linkMaxOrderByAggregateInput = {
    weapon_id?: SortOrder
    weapon_story_id?: SortOrder
  }

  export type weapon_story_linkMinOrderByAggregateInput = {
    weapon_id?: SortOrder
    weapon_story_id?: SortOrder
  }

  export type weapon_story_linkSumOrderByAggregateInput = {
    weapon_id?: SortOrder
    weapon_story_id?: SortOrder
  }

  export type debrisCountOrderByAggregateInput = {
    debris_id?: SortOrder
    rarity?: SortOrder
    release_time?: SortOrder
    name?: SortOrder
    image_path_base?: SortOrder
  }

  export type debrisAvgOrderByAggregateInput = {
    debris_id?: SortOrder
    rarity?: SortOrder
  }

  export type debrisMaxOrderByAggregateInput = {
    debris_id?: SortOrder
    rarity?: SortOrder
    release_time?: SortOrder
    name?: SortOrder
    image_path_base?: SortOrder
  }

  export type debrisMinOrderByAggregateInput = {
    debris_id?: SortOrder
    rarity?: SortOrder
    release_time?: SortOrder
    name?: SortOrder
    image_path_base?: SortOrder
  }

  export type debrisSumOrderByAggregateInput = {
    debris_id?: SortOrder
    rarity?: SortOrder
  }

  export type notificationCountOrderByAggregateInput = {
    notification_id?: SortOrder
    information_type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    release_time?: SortOrder
    thumbnail_path?: SortOrder
  }

  export type notificationAvgOrderByAggregateInput = {
    notification_id?: SortOrder
  }

  export type notificationMaxOrderByAggregateInput = {
    notification_id?: SortOrder
    information_type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    release_time?: SortOrder
    thumbnail_path?: SortOrder
  }

  export type notificationMinOrderByAggregateInput = {
    notification_id?: SortOrder
    information_type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    release_time?: SortOrder
    thumbnail_path?: SortOrder
  }

  export type notificationSumOrderByAggregateInput = {
    notification_id?: SortOrder
  }

  export type character_rank_bonusCreateNestedManyWithoutCharacterInput = {
    create?: XOR<Enumerable<character_rank_bonusCreateWithoutCharacterInput>, Enumerable<character_rank_bonusUncheckedCreateWithoutCharacterInput>>
    connectOrCreate?: Enumerable<character_rank_bonusCreateOrConnectWithoutCharacterInput>
    createMany?: character_rank_bonusCreateManyCharacterInputEnvelope
    connect?: Enumerable<character_rank_bonusWhereUniqueInput>
  }

  export type costumeCreateNestedManyWithoutCharacterInput = {
    create?: XOR<Enumerable<costumeCreateWithoutCharacterInput>, Enumerable<costumeUncheckedCreateWithoutCharacterInput>>
    connectOrCreate?: Enumerable<costumeCreateOrConnectWithoutCharacterInput>
    createMany?: costumeCreateManyCharacterInputEnvelope
    connect?: Enumerable<costumeWhereUniqueInput>
  }

  export type character_rank_bonusUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<Enumerable<character_rank_bonusCreateWithoutCharacterInput>, Enumerable<character_rank_bonusUncheckedCreateWithoutCharacterInput>>
    connectOrCreate?: Enumerable<character_rank_bonusCreateOrConnectWithoutCharacterInput>
    createMany?: character_rank_bonusCreateManyCharacterInputEnvelope
    connect?: Enumerable<character_rank_bonusWhereUniqueInput>
  }

  export type costumeUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<Enumerable<costumeCreateWithoutCharacterInput>, Enumerable<costumeUncheckedCreateWithoutCharacterInput>>
    connectOrCreate?: Enumerable<costumeCreateOrConnectWithoutCharacterInput>
    createMany?: costumeCreateManyCharacterInputEnvelope
    connect?: Enumerable<costumeWhereUniqueInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type character_rank_bonusUpdateManyWithoutCharacterInput = {
    create?: XOR<Enumerable<character_rank_bonusCreateWithoutCharacterInput>, Enumerable<character_rank_bonusUncheckedCreateWithoutCharacterInput>>
    connectOrCreate?: Enumerable<character_rank_bonusCreateOrConnectWithoutCharacterInput>
    upsert?: Enumerable<character_rank_bonusUpsertWithWhereUniqueWithoutCharacterInput>
    createMany?: character_rank_bonusCreateManyCharacterInputEnvelope
    set?: Enumerable<character_rank_bonusWhereUniqueInput>
    disconnect?: Enumerable<character_rank_bonusWhereUniqueInput>
    delete?: Enumerable<character_rank_bonusWhereUniqueInput>
    connect?: Enumerable<character_rank_bonusWhereUniqueInput>
    update?: Enumerable<character_rank_bonusUpdateWithWhereUniqueWithoutCharacterInput>
    updateMany?: Enumerable<character_rank_bonusUpdateManyWithWhereWithoutCharacterInput>
    deleteMany?: Enumerable<character_rank_bonusScalarWhereInput>
  }

  export type costumeUpdateManyWithoutCharacterInput = {
    create?: XOR<Enumerable<costumeCreateWithoutCharacterInput>, Enumerable<costumeUncheckedCreateWithoutCharacterInput>>
    connectOrCreate?: Enumerable<costumeCreateOrConnectWithoutCharacterInput>
    upsert?: Enumerable<costumeUpsertWithWhereUniqueWithoutCharacterInput>
    createMany?: costumeCreateManyCharacterInputEnvelope
    set?: Enumerable<costumeWhereUniqueInput>
    disconnect?: Enumerable<costumeWhereUniqueInput>
    delete?: Enumerable<costumeWhereUniqueInput>
    connect?: Enumerable<costumeWhereUniqueInput>
    update?: Enumerable<costumeUpdateWithWhereUniqueWithoutCharacterInput>
    updateMany?: Enumerable<costumeUpdateManyWithWhereWithoutCharacterInput>
    deleteMany?: Enumerable<costumeScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type character_rank_bonusUncheckedUpdateManyWithoutCharacterInput = {
    create?: XOR<Enumerable<character_rank_bonusCreateWithoutCharacterInput>, Enumerable<character_rank_bonusUncheckedCreateWithoutCharacterInput>>
    connectOrCreate?: Enumerable<character_rank_bonusCreateOrConnectWithoutCharacterInput>
    upsert?: Enumerable<character_rank_bonusUpsertWithWhereUniqueWithoutCharacterInput>
    createMany?: character_rank_bonusCreateManyCharacterInputEnvelope
    set?: Enumerable<character_rank_bonusWhereUniqueInput>
    disconnect?: Enumerable<character_rank_bonusWhereUniqueInput>
    delete?: Enumerable<character_rank_bonusWhereUniqueInput>
    connect?: Enumerable<character_rank_bonusWhereUniqueInput>
    update?: Enumerable<character_rank_bonusUpdateWithWhereUniqueWithoutCharacterInput>
    updateMany?: Enumerable<character_rank_bonusUpdateManyWithWhereWithoutCharacterInput>
    deleteMany?: Enumerable<character_rank_bonusScalarWhereInput>
  }

  export type costumeUncheckedUpdateManyWithoutCharacterInput = {
    create?: XOR<Enumerable<costumeCreateWithoutCharacterInput>, Enumerable<costumeUncheckedCreateWithoutCharacterInput>>
    connectOrCreate?: Enumerable<costumeCreateOrConnectWithoutCharacterInput>
    upsert?: Enumerable<costumeUpsertWithWhereUniqueWithoutCharacterInput>
    createMany?: costumeCreateManyCharacterInputEnvelope
    set?: Enumerable<costumeWhereUniqueInput>
    disconnect?: Enumerable<costumeWhereUniqueInput>
    delete?: Enumerable<costumeWhereUniqueInput>
    connect?: Enumerable<costumeWhereUniqueInput>
    update?: Enumerable<costumeUpdateWithWhereUniqueWithoutCharacterInput>
    updateMany?: Enumerable<costumeUpdateManyWithWhereWithoutCharacterInput>
    deleteMany?: Enumerable<costumeScalarWhereInput>
  }

  export type characterCreateNestedOneWithoutCharacter_rank_bonusInput = {
    create?: XOR<characterCreateWithoutCharacter_rank_bonusInput, characterUncheckedCreateWithoutCharacter_rank_bonusInput>
    connectOrCreate?: characterCreateOrConnectWithoutCharacter_rank_bonusInput
    connect?: characterWhereUniqueInput
  }

  export type characterUpdateOneRequiredWithoutCharacter_rank_bonusInput = {
    create?: XOR<characterCreateWithoutCharacter_rank_bonusInput, characterUncheckedCreateWithoutCharacter_rank_bonusInput>
    connectOrCreate?: characterCreateOrConnectWithoutCharacter_rank_bonusInput
    upsert?: characterUpsertWithoutCharacter_rank_bonusInput
    connect?: characterWhereUniqueInput
    update?: XOR<characterUpdateWithoutCharacter_rank_bonusInput, characterUncheckedUpdateWithoutCharacter_rank_bonusInput>
  }

  export type companion_ability_linkCreateNestedManyWithoutCompanionInput = {
    create?: XOR<Enumerable<companion_ability_linkCreateWithoutCompanionInput>, Enumerable<companion_ability_linkUncheckedCreateWithoutCompanionInput>>
    connectOrCreate?: Enumerable<companion_ability_linkCreateOrConnectWithoutCompanionInput>
    createMany?: companion_ability_linkCreateManyCompanionInputEnvelope
    connect?: Enumerable<companion_ability_linkWhereUniqueInput>
  }

  export type companion_skill_linkCreateNestedManyWithoutCompanionInput = {
    create?: XOR<Enumerable<companion_skill_linkCreateWithoutCompanionInput>, Enumerable<companion_skill_linkUncheckedCreateWithoutCompanionInput>>
    connectOrCreate?: Enumerable<companion_skill_linkCreateOrConnectWithoutCompanionInput>
    createMany?: companion_skill_linkCreateManyCompanionInputEnvelope
    connect?: Enumerable<companion_skill_linkWhereUniqueInput>
  }

  export type companion_statCreateNestedManyWithoutCompanionInput = {
    create?: XOR<Enumerable<companion_statCreateWithoutCompanionInput>, Enumerable<companion_statUncheckedCreateWithoutCompanionInput>>
    connectOrCreate?: Enumerable<companion_statCreateOrConnectWithoutCompanionInput>
    createMany?: companion_statCreateManyCompanionInputEnvelope
    connect?: Enumerable<companion_statWhereUniqueInput>
  }

  export type companion_ability_linkUncheckedCreateNestedManyWithoutCompanionInput = {
    create?: XOR<Enumerable<companion_ability_linkCreateWithoutCompanionInput>, Enumerable<companion_ability_linkUncheckedCreateWithoutCompanionInput>>
    connectOrCreate?: Enumerable<companion_ability_linkCreateOrConnectWithoutCompanionInput>
    createMany?: companion_ability_linkCreateManyCompanionInputEnvelope
    connect?: Enumerable<companion_ability_linkWhereUniqueInput>
  }

  export type companion_skill_linkUncheckedCreateNestedManyWithoutCompanionInput = {
    create?: XOR<Enumerable<companion_skill_linkCreateWithoutCompanionInput>, Enumerable<companion_skill_linkUncheckedCreateWithoutCompanionInput>>
    connectOrCreate?: Enumerable<companion_skill_linkCreateOrConnectWithoutCompanionInput>
    createMany?: companion_skill_linkCreateManyCompanionInputEnvelope
    connect?: Enumerable<companion_skill_linkWhereUniqueInput>
  }

  export type companion_statUncheckedCreateNestedManyWithoutCompanionInput = {
    create?: XOR<Enumerable<companion_statCreateWithoutCompanionInput>, Enumerable<companion_statUncheckedCreateWithoutCompanionInput>>
    connectOrCreate?: Enumerable<companion_statCreateOrConnectWithoutCompanionInput>
    createMany?: companion_statCreateManyCompanionInputEnvelope
    connect?: Enumerable<companion_statWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type companion_ability_linkUpdateManyWithoutCompanionInput = {
    create?: XOR<Enumerable<companion_ability_linkCreateWithoutCompanionInput>, Enumerable<companion_ability_linkUncheckedCreateWithoutCompanionInput>>
    connectOrCreate?: Enumerable<companion_ability_linkCreateOrConnectWithoutCompanionInput>
    upsert?: Enumerable<companion_ability_linkUpsertWithWhereUniqueWithoutCompanionInput>
    createMany?: companion_ability_linkCreateManyCompanionInputEnvelope
    set?: Enumerable<companion_ability_linkWhereUniqueInput>
    disconnect?: Enumerable<companion_ability_linkWhereUniqueInput>
    delete?: Enumerable<companion_ability_linkWhereUniqueInput>
    connect?: Enumerable<companion_ability_linkWhereUniqueInput>
    update?: Enumerable<companion_ability_linkUpdateWithWhereUniqueWithoutCompanionInput>
    updateMany?: Enumerable<companion_ability_linkUpdateManyWithWhereWithoutCompanionInput>
    deleteMany?: Enumerable<companion_ability_linkScalarWhereInput>
  }

  export type companion_skill_linkUpdateManyWithoutCompanionInput = {
    create?: XOR<Enumerable<companion_skill_linkCreateWithoutCompanionInput>, Enumerable<companion_skill_linkUncheckedCreateWithoutCompanionInput>>
    connectOrCreate?: Enumerable<companion_skill_linkCreateOrConnectWithoutCompanionInput>
    upsert?: Enumerable<companion_skill_linkUpsertWithWhereUniqueWithoutCompanionInput>
    createMany?: companion_skill_linkCreateManyCompanionInputEnvelope
    set?: Enumerable<companion_skill_linkWhereUniqueInput>
    disconnect?: Enumerable<companion_skill_linkWhereUniqueInput>
    delete?: Enumerable<companion_skill_linkWhereUniqueInput>
    connect?: Enumerable<companion_skill_linkWhereUniqueInput>
    update?: Enumerable<companion_skill_linkUpdateWithWhereUniqueWithoutCompanionInput>
    updateMany?: Enumerable<companion_skill_linkUpdateManyWithWhereWithoutCompanionInput>
    deleteMany?: Enumerable<companion_skill_linkScalarWhereInput>
  }

  export type companion_statUpdateManyWithoutCompanionInput = {
    create?: XOR<Enumerable<companion_statCreateWithoutCompanionInput>, Enumerable<companion_statUncheckedCreateWithoutCompanionInput>>
    connectOrCreate?: Enumerable<companion_statCreateOrConnectWithoutCompanionInput>
    upsert?: Enumerable<companion_statUpsertWithWhereUniqueWithoutCompanionInput>
    createMany?: companion_statCreateManyCompanionInputEnvelope
    set?: Enumerable<companion_statWhereUniqueInput>
    disconnect?: Enumerable<companion_statWhereUniqueInput>
    delete?: Enumerable<companion_statWhereUniqueInput>
    connect?: Enumerable<companion_statWhereUniqueInput>
    update?: Enumerable<companion_statUpdateWithWhereUniqueWithoutCompanionInput>
    updateMany?: Enumerable<companion_statUpdateManyWithWhereWithoutCompanionInput>
    deleteMany?: Enumerable<companion_statScalarWhereInput>
  }

  export type companion_ability_linkUncheckedUpdateManyWithoutCompanionInput = {
    create?: XOR<Enumerable<companion_ability_linkCreateWithoutCompanionInput>, Enumerable<companion_ability_linkUncheckedCreateWithoutCompanionInput>>
    connectOrCreate?: Enumerable<companion_ability_linkCreateOrConnectWithoutCompanionInput>
    upsert?: Enumerable<companion_ability_linkUpsertWithWhereUniqueWithoutCompanionInput>
    createMany?: companion_ability_linkCreateManyCompanionInputEnvelope
    set?: Enumerable<companion_ability_linkWhereUniqueInput>
    disconnect?: Enumerable<companion_ability_linkWhereUniqueInput>
    delete?: Enumerable<companion_ability_linkWhereUniqueInput>
    connect?: Enumerable<companion_ability_linkWhereUniqueInput>
    update?: Enumerable<companion_ability_linkUpdateWithWhereUniqueWithoutCompanionInput>
    updateMany?: Enumerable<companion_ability_linkUpdateManyWithWhereWithoutCompanionInput>
    deleteMany?: Enumerable<companion_ability_linkScalarWhereInput>
  }

  export type companion_skill_linkUncheckedUpdateManyWithoutCompanionInput = {
    create?: XOR<Enumerable<companion_skill_linkCreateWithoutCompanionInput>, Enumerable<companion_skill_linkUncheckedCreateWithoutCompanionInput>>
    connectOrCreate?: Enumerable<companion_skill_linkCreateOrConnectWithoutCompanionInput>
    upsert?: Enumerable<companion_skill_linkUpsertWithWhereUniqueWithoutCompanionInput>
    createMany?: companion_skill_linkCreateManyCompanionInputEnvelope
    set?: Enumerable<companion_skill_linkWhereUniqueInput>
    disconnect?: Enumerable<companion_skill_linkWhereUniqueInput>
    delete?: Enumerable<companion_skill_linkWhereUniqueInput>
    connect?: Enumerable<companion_skill_linkWhereUniqueInput>
    update?: Enumerable<companion_skill_linkUpdateWithWhereUniqueWithoutCompanionInput>
    updateMany?: Enumerable<companion_skill_linkUpdateManyWithWhereWithoutCompanionInput>
    deleteMany?: Enumerable<companion_skill_linkScalarWhereInput>
  }

  export type companion_statUncheckedUpdateManyWithoutCompanionInput = {
    create?: XOR<Enumerable<companion_statCreateWithoutCompanionInput>, Enumerable<companion_statUncheckedCreateWithoutCompanionInput>>
    connectOrCreate?: Enumerable<companion_statCreateOrConnectWithoutCompanionInput>
    upsert?: Enumerable<companion_statUpsertWithWhereUniqueWithoutCompanionInput>
    createMany?: companion_statCreateManyCompanionInputEnvelope
    set?: Enumerable<companion_statWhereUniqueInput>
    disconnect?: Enumerable<companion_statWhereUniqueInput>
    delete?: Enumerable<companion_statWhereUniqueInput>
    connect?: Enumerable<companion_statWhereUniqueInput>
    update?: Enumerable<companion_statUpdateWithWhereUniqueWithoutCompanionInput>
    updateMany?: Enumerable<companion_statUpdateManyWithWhereWithoutCompanionInput>
    deleteMany?: Enumerable<companion_statScalarWhereInput>
  }

  export type companion_ability_linkCreateNestedManyWithoutCompanion_abilityInput = {
    create?: XOR<Enumerable<companion_ability_linkCreateWithoutCompanion_abilityInput>, Enumerable<companion_ability_linkUncheckedCreateWithoutCompanion_abilityInput>>
    connectOrCreate?: Enumerable<companion_ability_linkCreateOrConnectWithoutCompanion_abilityInput>
    createMany?: companion_ability_linkCreateManyCompanion_abilityInputEnvelope
    connect?: Enumerable<companion_ability_linkWhereUniqueInput>
  }

  export type companion_ability_linkUncheckedCreateNestedManyWithoutCompanion_abilityInput = {
    create?: XOR<Enumerable<companion_ability_linkCreateWithoutCompanion_abilityInput>, Enumerable<companion_ability_linkUncheckedCreateWithoutCompanion_abilityInput>>
    connectOrCreate?: Enumerable<companion_ability_linkCreateOrConnectWithoutCompanion_abilityInput>
    createMany?: companion_ability_linkCreateManyCompanion_abilityInputEnvelope
    connect?: Enumerable<companion_ability_linkWhereUniqueInput>
  }

  export type companion_ability_linkUpdateManyWithoutCompanion_abilityInput = {
    create?: XOR<Enumerable<companion_ability_linkCreateWithoutCompanion_abilityInput>, Enumerable<companion_ability_linkUncheckedCreateWithoutCompanion_abilityInput>>
    connectOrCreate?: Enumerable<companion_ability_linkCreateOrConnectWithoutCompanion_abilityInput>
    upsert?: Enumerable<companion_ability_linkUpsertWithWhereUniqueWithoutCompanion_abilityInput>
    createMany?: companion_ability_linkCreateManyCompanion_abilityInputEnvelope
    set?: Enumerable<companion_ability_linkWhereUniqueInput>
    disconnect?: Enumerable<companion_ability_linkWhereUniqueInput>
    delete?: Enumerable<companion_ability_linkWhereUniqueInput>
    connect?: Enumerable<companion_ability_linkWhereUniqueInput>
    update?: Enumerable<companion_ability_linkUpdateWithWhereUniqueWithoutCompanion_abilityInput>
    updateMany?: Enumerable<companion_ability_linkUpdateManyWithWhereWithoutCompanion_abilityInput>
    deleteMany?: Enumerable<companion_ability_linkScalarWhereInput>
  }

  export type companion_ability_linkUncheckedUpdateManyWithoutCompanion_abilityInput = {
    create?: XOR<Enumerable<companion_ability_linkCreateWithoutCompanion_abilityInput>, Enumerable<companion_ability_linkUncheckedCreateWithoutCompanion_abilityInput>>
    connectOrCreate?: Enumerable<companion_ability_linkCreateOrConnectWithoutCompanion_abilityInput>
    upsert?: Enumerable<companion_ability_linkUpsertWithWhereUniqueWithoutCompanion_abilityInput>
    createMany?: companion_ability_linkCreateManyCompanion_abilityInputEnvelope
    set?: Enumerable<companion_ability_linkWhereUniqueInput>
    disconnect?: Enumerable<companion_ability_linkWhereUniqueInput>
    delete?: Enumerable<companion_ability_linkWhereUniqueInput>
    connect?: Enumerable<companion_ability_linkWhereUniqueInput>
    update?: Enumerable<companion_ability_linkUpdateWithWhereUniqueWithoutCompanion_abilityInput>
    updateMany?: Enumerable<companion_ability_linkUpdateManyWithWhereWithoutCompanion_abilityInput>
    deleteMany?: Enumerable<companion_ability_linkScalarWhereInput>
  }

  export type companion_abilityCreateNestedOneWithoutCompanion_ability_linkInput = {
    create?: XOR<companion_abilityCreateWithoutCompanion_ability_linkInput, companion_abilityUncheckedCreateWithoutCompanion_ability_linkInput>
    connectOrCreate?: companion_abilityCreateOrConnectWithoutCompanion_ability_linkInput
    connect?: companion_abilityWhereUniqueInput
  }

  export type companionCreateNestedOneWithoutCompanion_ability_linkInput = {
    create?: XOR<companionCreateWithoutCompanion_ability_linkInput, companionUncheckedCreateWithoutCompanion_ability_linkInput>
    connectOrCreate?: companionCreateOrConnectWithoutCompanion_ability_linkInput
    connect?: companionWhereUniqueInput
  }

  export type companion_abilityUpdateOneRequiredWithoutCompanion_ability_linkInput = {
    create?: XOR<companion_abilityCreateWithoutCompanion_ability_linkInput, companion_abilityUncheckedCreateWithoutCompanion_ability_linkInput>
    connectOrCreate?: companion_abilityCreateOrConnectWithoutCompanion_ability_linkInput
    upsert?: companion_abilityUpsertWithoutCompanion_ability_linkInput
    connect?: companion_abilityWhereUniqueInput
    update?: XOR<companion_abilityUpdateWithoutCompanion_ability_linkInput, companion_abilityUncheckedUpdateWithoutCompanion_ability_linkInput>
  }

  export type companionUpdateOneRequiredWithoutCompanion_ability_linkInput = {
    create?: XOR<companionCreateWithoutCompanion_ability_linkInput, companionUncheckedCreateWithoutCompanion_ability_linkInput>
    connectOrCreate?: companionCreateOrConnectWithoutCompanion_ability_linkInput
    upsert?: companionUpsertWithoutCompanion_ability_linkInput
    connect?: companionWhereUniqueInput
    update?: XOR<companionUpdateWithoutCompanion_ability_linkInput, companionUncheckedUpdateWithoutCompanion_ability_linkInput>
  }

  export type companion_skill_linkCreateNestedManyWithoutCompanion_skillInput = {
    create?: XOR<Enumerable<companion_skill_linkCreateWithoutCompanion_skillInput>, Enumerable<companion_skill_linkUncheckedCreateWithoutCompanion_skillInput>>
    connectOrCreate?: Enumerable<companion_skill_linkCreateOrConnectWithoutCompanion_skillInput>
    createMany?: companion_skill_linkCreateManyCompanion_skillInputEnvelope
    connect?: Enumerable<companion_skill_linkWhereUniqueInput>
  }

  export type companion_skill_linkUncheckedCreateNestedManyWithoutCompanion_skillInput = {
    create?: XOR<Enumerable<companion_skill_linkCreateWithoutCompanion_skillInput>, Enumerable<companion_skill_linkUncheckedCreateWithoutCompanion_skillInput>>
    connectOrCreate?: Enumerable<companion_skill_linkCreateOrConnectWithoutCompanion_skillInput>
    createMany?: companion_skill_linkCreateManyCompanion_skillInputEnvelope
    connect?: Enumerable<companion_skill_linkWhereUniqueInput>
  }

  export type companion_skill_linkUpdateManyWithoutCompanion_skillInput = {
    create?: XOR<Enumerable<companion_skill_linkCreateWithoutCompanion_skillInput>, Enumerable<companion_skill_linkUncheckedCreateWithoutCompanion_skillInput>>
    connectOrCreate?: Enumerable<companion_skill_linkCreateOrConnectWithoutCompanion_skillInput>
    upsert?: Enumerable<companion_skill_linkUpsertWithWhereUniqueWithoutCompanion_skillInput>
    createMany?: companion_skill_linkCreateManyCompanion_skillInputEnvelope
    set?: Enumerable<companion_skill_linkWhereUniqueInput>
    disconnect?: Enumerable<companion_skill_linkWhereUniqueInput>
    delete?: Enumerable<companion_skill_linkWhereUniqueInput>
    connect?: Enumerable<companion_skill_linkWhereUniqueInput>
    update?: Enumerable<companion_skill_linkUpdateWithWhereUniqueWithoutCompanion_skillInput>
    updateMany?: Enumerable<companion_skill_linkUpdateManyWithWhereWithoutCompanion_skillInput>
    deleteMany?: Enumerable<companion_skill_linkScalarWhereInput>
  }

  export type companion_skill_linkUncheckedUpdateManyWithoutCompanion_skillInput = {
    create?: XOR<Enumerable<companion_skill_linkCreateWithoutCompanion_skillInput>, Enumerable<companion_skill_linkUncheckedCreateWithoutCompanion_skillInput>>
    connectOrCreate?: Enumerable<companion_skill_linkCreateOrConnectWithoutCompanion_skillInput>
    upsert?: Enumerable<companion_skill_linkUpsertWithWhereUniqueWithoutCompanion_skillInput>
    createMany?: companion_skill_linkCreateManyCompanion_skillInputEnvelope
    set?: Enumerable<companion_skill_linkWhereUniqueInput>
    disconnect?: Enumerable<companion_skill_linkWhereUniqueInput>
    delete?: Enumerable<companion_skill_linkWhereUniqueInput>
    connect?: Enumerable<companion_skill_linkWhereUniqueInput>
    update?: Enumerable<companion_skill_linkUpdateWithWhereUniqueWithoutCompanion_skillInput>
    updateMany?: Enumerable<companion_skill_linkUpdateManyWithWhereWithoutCompanion_skillInput>
    deleteMany?: Enumerable<companion_skill_linkScalarWhereInput>
  }

  export type companionCreateNestedOneWithoutCompanion_skill_linkInput = {
    create?: XOR<companionCreateWithoutCompanion_skill_linkInput, companionUncheckedCreateWithoutCompanion_skill_linkInput>
    connectOrCreate?: companionCreateOrConnectWithoutCompanion_skill_linkInput
    connect?: companionWhereUniqueInput
  }

  export type companion_skillCreateNestedOneWithoutCompanion_skill_linkInput = {
    create?: XOR<companion_skillCreateWithoutCompanion_skill_linkInput, companion_skillUncheckedCreateWithoutCompanion_skill_linkInput>
    connectOrCreate?: companion_skillCreateOrConnectWithoutCompanion_skill_linkInput
    connect?: companion_skillWhereUniqueInput
  }

  export type companionUpdateOneRequiredWithoutCompanion_skill_linkInput = {
    create?: XOR<companionCreateWithoutCompanion_skill_linkInput, companionUncheckedCreateWithoutCompanion_skill_linkInput>
    connectOrCreate?: companionCreateOrConnectWithoutCompanion_skill_linkInput
    upsert?: companionUpsertWithoutCompanion_skill_linkInput
    connect?: companionWhereUniqueInput
    update?: XOR<companionUpdateWithoutCompanion_skill_linkInput, companionUncheckedUpdateWithoutCompanion_skill_linkInput>
  }

  export type companion_skillUpdateOneRequiredWithoutCompanion_skill_linkInput = {
    create?: XOR<companion_skillCreateWithoutCompanion_skill_linkInput, companion_skillUncheckedCreateWithoutCompanion_skill_linkInput>
    connectOrCreate?: companion_skillCreateOrConnectWithoutCompanion_skill_linkInput
    upsert?: companion_skillUpsertWithoutCompanion_skill_linkInput
    connect?: companion_skillWhereUniqueInput
    update?: XOR<companion_skillUpdateWithoutCompanion_skill_linkInput, companion_skillUncheckedUpdateWithoutCompanion_skill_linkInput>
  }

  export type companionCreateNestedOneWithoutCompanion_statInput = {
    create?: XOR<companionCreateWithoutCompanion_statInput, companionUncheckedCreateWithoutCompanion_statInput>
    connectOrCreate?: companionCreateOrConnectWithoutCompanion_statInput
    connect?: companionWhereUniqueInput
  }

  export type companionUpdateOneRequiredWithoutCompanion_statInput = {
    create?: XOR<companionCreateWithoutCompanion_statInput, companionUncheckedCreateWithoutCompanion_statInput>
    connectOrCreate?: companionCreateOrConnectWithoutCompanion_statInput
    upsert?: companionUpsertWithoutCompanion_statInput
    connect?: companionWhereUniqueInput
    update?: XOR<companionUpdateWithoutCompanion_statInput, companionUncheckedUpdateWithoutCompanion_statInput>
  }

  export type characterCreateNestedOneWithoutCostumeInput = {
    create?: XOR<characterCreateWithoutCostumeInput, characterUncheckedCreateWithoutCostumeInput>
    connectOrCreate?: characterCreateOrConnectWithoutCostumeInput
    connect?: characterWhereUniqueInput
  }

  export type emblemCreateNestedOneWithoutCostumeInput = {
    create?: XOR<emblemCreateWithoutCostumeInput, emblemUncheckedCreateWithoutCostumeInput>
    connectOrCreate?: emblemCreateOrConnectWithoutCostumeInput
    connect?: emblemWhereUniqueInput
  }

  export type costume_ability_linkCreateNestedManyWithoutCostumeInput = {
    create?: XOR<Enumerable<costume_ability_linkCreateWithoutCostumeInput>, Enumerable<costume_ability_linkUncheckedCreateWithoutCostumeInput>>
    connectOrCreate?: Enumerable<costume_ability_linkCreateOrConnectWithoutCostumeInput>
    createMany?: costume_ability_linkCreateManyCostumeInputEnvelope
    connect?: Enumerable<costume_ability_linkWhereUniqueInput>
  }

  export type costume_skill_linkCreateNestedManyWithoutCostumeInput = {
    create?: XOR<Enumerable<costume_skill_linkCreateWithoutCostumeInput>, Enumerable<costume_skill_linkUncheckedCreateWithoutCostumeInput>>
    connectOrCreate?: Enumerable<costume_skill_linkCreateOrConnectWithoutCostumeInput>
    createMany?: costume_skill_linkCreateManyCostumeInputEnvelope
    connect?: Enumerable<costume_skill_linkWhereUniqueInput>
  }

  export type costume_statCreateNestedManyWithoutCostumeInput = {
    create?: XOR<Enumerable<costume_statCreateWithoutCostumeInput>, Enumerable<costume_statUncheckedCreateWithoutCostumeInput>>
    connectOrCreate?: Enumerable<costume_statCreateOrConnectWithoutCostumeInput>
    createMany?: costume_statCreateManyCostumeInputEnvelope
    connect?: Enumerable<costume_statWhereUniqueInput>
  }

  export type costume_ability_linkUncheckedCreateNestedManyWithoutCostumeInput = {
    create?: XOR<Enumerable<costume_ability_linkCreateWithoutCostumeInput>, Enumerable<costume_ability_linkUncheckedCreateWithoutCostumeInput>>
    connectOrCreate?: Enumerable<costume_ability_linkCreateOrConnectWithoutCostumeInput>
    createMany?: costume_ability_linkCreateManyCostumeInputEnvelope
    connect?: Enumerable<costume_ability_linkWhereUniqueInput>
  }

  export type costume_skill_linkUncheckedCreateNestedManyWithoutCostumeInput = {
    create?: XOR<Enumerable<costume_skill_linkCreateWithoutCostumeInput>, Enumerable<costume_skill_linkUncheckedCreateWithoutCostumeInput>>
    connectOrCreate?: Enumerable<costume_skill_linkCreateOrConnectWithoutCostumeInput>
    createMany?: costume_skill_linkCreateManyCostumeInputEnvelope
    connect?: Enumerable<costume_skill_linkWhereUniqueInput>
  }

  export type costume_statUncheckedCreateNestedManyWithoutCostumeInput = {
    create?: XOR<Enumerable<costume_statCreateWithoutCostumeInput>, Enumerable<costume_statUncheckedCreateWithoutCostumeInput>>
    connectOrCreate?: Enumerable<costume_statCreateOrConnectWithoutCostumeInput>
    createMany?: costume_statCreateManyCostumeInputEnvelope
    connect?: Enumerable<costume_statWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type characterUpdateOneRequiredWithoutCostumeInput = {
    create?: XOR<characterCreateWithoutCostumeInput, characterUncheckedCreateWithoutCostumeInput>
    connectOrCreate?: characterCreateOrConnectWithoutCostumeInput
    upsert?: characterUpsertWithoutCostumeInput
    connect?: characterWhereUniqueInput
    update?: XOR<characterUpdateWithoutCostumeInput, characterUncheckedUpdateWithoutCostumeInput>
  }

  export type emblemUpdateOneWithoutCostumeInput = {
    create?: XOR<emblemCreateWithoutCostumeInput, emblemUncheckedCreateWithoutCostumeInput>
    connectOrCreate?: emblemCreateOrConnectWithoutCostumeInput
    upsert?: emblemUpsertWithoutCostumeInput
    disconnect?: boolean
    delete?: boolean
    connect?: emblemWhereUniqueInput
    update?: XOR<emblemUpdateWithoutCostumeInput, emblemUncheckedUpdateWithoutCostumeInput>
  }

  export type costume_ability_linkUpdateManyWithoutCostumeInput = {
    create?: XOR<Enumerable<costume_ability_linkCreateWithoutCostumeInput>, Enumerable<costume_ability_linkUncheckedCreateWithoutCostumeInput>>
    connectOrCreate?: Enumerable<costume_ability_linkCreateOrConnectWithoutCostumeInput>
    upsert?: Enumerable<costume_ability_linkUpsertWithWhereUniqueWithoutCostumeInput>
    createMany?: costume_ability_linkCreateManyCostumeInputEnvelope
    set?: Enumerable<costume_ability_linkWhereUniqueInput>
    disconnect?: Enumerable<costume_ability_linkWhereUniqueInput>
    delete?: Enumerable<costume_ability_linkWhereUniqueInput>
    connect?: Enumerable<costume_ability_linkWhereUniqueInput>
    update?: Enumerable<costume_ability_linkUpdateWithWhereUniqueWithoutCostumeInput>
    updateMany?: Enumerable<costume_ability_linkUpdateManyWithWhereWithoutCostumeInput>
    deleteMany?: Enumerable<costume_ability_linkScalarWhereInput>
  }

  export type costume_skill_linkUpdateManyWithoutCostumeInput = {
    create?: XOR<Enumerable<costume_skill_linkCreateWithoutCostumeInput>, Enumerable<costume_skill_linkUncheckedCreateWithoutCostumeInput>>
    connectOrCreate?: Enumerable<costume_skill_linkCreateOrConnectWithoutCostumeInput>
    upsert?: Enumerable<costume_skill_linkUpsertWithWhereUniqueWithoutCostumeInput>
    createMany?: costume_skill_linkCreateManyCostumeInputEnvelope
    set?: Enumerable<costume_skill_linkWhereUniqueInput>
    disconnect?: Enumerable<costume_skill_linkWhereUniqueInput>
    delete?: Enumerable<costume_skill_linkWhereUniqueInput>
    connect?: Enumerable<costume_skill_linkWhereUniqueInput>
    update?: Enumerable<costume_skill_linkUpdateWithWhereUniqueWithoutCostumeInput>
    updateMany?: Enumerable<costume_skill_linkUpdateManyWithWhereWithoutCostumeInput>
    deleteMany?: Enumerable<costume_skill_linkScalarWhereInput>
  }

  export type costume_statUpdateManyWithoutCostumeInput = {
    create?: XOR<Enumerable<costume_statCreateWithoutCostumeInput>, Enumerable<costume_statUncheckedCreateWithoutCostumeInput>>
    connectOrCreate?: Enumerable<costume_statCreateOrConnectWithoutCostumeInput>
    upsert?: Enumerable<costume_statUpsertWithWhereUniqueWithoutCostumeInput>
    createMany?: costume_statCreateManyCostumeInputEnvelope
    set?: Enumerable<costume_statWhereUniqueInput>
    disconnect?: Enumerable<costume_statWhereUniqueInput>
    delete?: Enumerable<costume_statWhereUniqueInput>
    connect?: Enumerable<costume_statWhereUniqueInput>
    update?: Enumerable<costume_statUpdateWithWhereUniqueWithoutCostumeInput>
    updateMany?: Enumerable<costume_statUpdateManyWithWhereWithoutCostumeInput>
    deleteMany?: Enumerable<costume_statScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type costume_ability_linkUncheckedUpdateManyWithoutCostumeInput = {
    create?: XOR<Enumerable<costume_ability_linkCreateWithoutCostumeInput>, Enumerable<costume_ability_linkUncheckedCreateWithoutCostumeInput>>
    connectOrCreate?: Enumerable<costume_ability_linkCreateOrConnectWithoutCostumeInput>
    upsert?: Enumerable<costume_ability_linkUpsertWithWhereUniqueWithoutCostumeInput>
    createMany?: costume_ability_linkCreateManyCostumeInputEnvelope
    set?: Enumerable<costume_ability_linkWhereUniqueInput>
    disconnect?: Enumerable<costume_ability_linkWhereUniqueInput>
    delete?: Enumerable<costume_ability_linkWhereUniqueInput>
    connect?: Enumerable<costume_ability_linkWhereUniqueInput>
    update?: Enumerable<costume_ability_linkUpdateWithWhereUniqueWithoutCostumeInput>
    updateMany?: Enumerable<costume_ability_linkUpdateManyWithWhereWithoutCostumeInput>
    deleteMany?: Enumerable<costume_ability_linkScalarWhereInput>
  }

  export type costume_skill_linkUncheckedUpdateManyWithoutCostumeInput = {
    create?: XOR<Enumerable<costume_skill_linkCreateWithoutCostumeInput>, Enumerable<costume_skill_linkUncheckedCreateWithoutCostumeInput>>
    connectOrCreate?: Enumerable<costume_skill_linkCreateOrConnectWithoutCostumeInput>
    upsert?: Enumerable<costume_skill_linkUpsertWithWhereUniqueWithoutCostumeInput>
    createMany?: costume_skill_linkCreateManyCostumeInputEnvelope
    set?: Enumerable<costume_skill_linkWhereUniqueInput>
    disconnect?: Enumerable<costume_skill_linkWhereUniqueInput>
    delete?: Enumerable<costume_skill_linkWhereUniqueInput>
    connect?: Enumerable<costume_skill_linkWhereUniqueInput>
    update?: Enumerable<costume_skill_linkUpdateWithWhereUniqueWithoutCostumeInput>
    updateMany?: Enumerable<costume_skill_linkUpdateManyWithWhereWithoutCostumeInput>
    deleteMany?: Enumerable<costume_skill_linkScalarWhereInput>
  }

  export type costume_statUncheckedUpdateManyWithoutCostumeInput = {
    create?: XOR<Enumerable<costume_statCreateWithoutCostumeInput>, Enumerable<costume_statUncheckedCreateWithoutCostumeInput>>
    connectOrCreate?: Enumerable<costume_statCreateOrConnectWithoutCostumeInput>
    upsert?: Enumerable<costume_statUpsertWithWhereUniqueWithoutCostumeInput>
    createMany?: costume_statCreateManyCostumeInputEnvelope
    set?: Enumerable<costume_statWhereUniqueInput>
    disconnect?: Enumerable<costume_statWhereUniqueInput>
    delete?: Enumerable<costume_statWhereUniqueInput>
    connect?: Enumerable<costume_statWhereUniqueInput>
    update?: Enumerable<costume_statUpdateWithWhereUniqueWithoutCostumeInput>
    updateMany?: Enumerable<costume_statUpdateManyWithWhereWithoutCostumeInput>
    deleteMany?: Enumerable<costume_statScalarWhereInput>
  }

  export type costume_ability_linkCreateNestedManyWithoutCostume_abilityInput = {
    create?: XOR<Enumerable<costume_ability_linkCreateWithoutCostume_abilityInput>, Enumerable<costume_ability_linkUncheckedCreateWithoutCostume_abilityInput>>
    connectOrCreate?: Enumerable<costume_ability_linkCreateOrConnectWithoutCostume_abilityInput>
    createMany?: costume_ability_linkCreateManyCostume_abilityInputEnvelope
    connect?: Enumerable<costume_ability_linkWhereUniqueInput>
  }

  export type costume_ability_linkUncheckedCreateNestedManyWithoutCostume_abilityInput = {
    create?: XOR<Enumerable<costume_ability_linkCreateWithoutCostume_abilityInput>, Enumerable<costume_ability_linkUncheckedCreateWithoutCostume_abilityInput>>
    connectOrCreate?: Enumerable<costume_ability_linkCreateOrConnectWithoutCostume_abilityInput>
    createMany?: costume_ability_linkCreateManyCostume_abilityInputEnvelope
    connect?: Enumerable<costume_ability_linkWhereUniqueInput>
  }

  export type costume_ability_linkUpdateManyWithoutCostume_abilityInput = {
    create?: XOR<Enumerable<costume_ability_linkCreateWithoutCostume_abilityInput>, Enumerable<costume_ability_linkUncheckedCreateWithoutCostume_abilityInput>>
    connectOrCreate?: Enumerable<costume_ability_linkCreateOrConnectWithoutCostume_abilityInput>
    upsert?: Enumerable<costume_ability_linkUpsertWithWhereUniqueWithoutCostume_abilityInput>
    createMany?: costume_ability_linkCreateManyCostume_abilityInputEnvelope
    set?: Enumerable<costume_ability_linkWhereUniqueInput>
    disconnect?: Enumerable<costume_ability_linkWhereUniqueInput>
    delete?: Enumerable<costume_ability_linkWhereUniqueInput>
    connect?: Enumerable<costume_ability_linkWhereUniqueInput>
    update?: Enumerable<costume_ability_linkUpdateWithWhereUniqueWithoutCostume_abilityInput>
    updateMany?: Enumerable<costume_ability_linkUpdateManyWithWhereWithoutCostume_abilityInput>
    deleteMany?: Enumerable<costume_ability_linkScalarWhereInput>
  }

  export type costume_ability_linkUncheckedUpdateManyWithoutCostume_abilityInput = {
    create?: XOR<Enumerable<costume_ability_linkCreateWithoutCostume_abilityInput>, Enumerable<costume_ability_linkUncheckedCreateWithoutCostume_abilityInput>>
    connectOrCreate?: Enumerable<costume_ability_linkCreateOrConnectWithoutCostume_abilityInput>
    upsert?: Enumerable<costume_ability_linkUpsertWithWhereUniqueWithoutCostume_abilityInput>
    createMany?: costume_ability_linkCreateManyCostume_abilityInputEnvelope
    set?: Enumerable<costume_ability_linkWhereUniqueInput>
    disconnect?: Enumerable<costume_ability_linkWhereUniqueInput>
    delete?: Enumerable<costume_ability_linkWhereUniqueInput>
    connect?: Enumerable<costume_ability_linkWhereUniqueInput>
    update?: Enumerable<costume_ability_linkUpdateWithWhereUniqueWithoutCostume_abilityInput>
    updateMany?: Enumerable<costume_ability_linkUpdateManyWithWhereWithoutCostume_abilityInput>
    deleteMany?: Enumerable<costume_ability_linkScalarWhereInput>
  }

  export type costume_abilityCreateNestedOneWithoutCostume_ability_linkInput = {
    create?: XOR<costume_abilityCreateWithoutCostume_ability_linkInput, costume_abilityUncheckedCreateWithoutCostume_ability_linkInput>
    connectOrCreate?: costume_abilityCreateOrConnectWithoutCostume_ability_linkInput
    connect?: costume_abilityWhereUniqueInput
  }

  export type costumeCreateNestedOneWithoutCostume_ability_linkInput = {
    create?: XOR<costumeCreateWithoutCostume_ability_linkInput, costumeUncheckedCreateWithoutCostume_ability_linkInput>
    connectOrCreate?: costumeCreateOrConnectWithoutCostume_ability_linkInput
    connect?: costumeWhereUniqueInput
  }

  export type costume_abilityUpdateOneRequiredWithoutCostume_ability_linkInput = {
    create?: XOR<costume_abilityCreateWithoutCostume_ability_linkInput, costume_abilityUncheckedCreateWithoutCostume_ability_linkInput>
    connectOrCreate?: costume_abilityCreateOrConnectWithoutCostume_ability_linkInput
    upsert?: costume_abilityUpsertWithoutCostume_ability_linkInput
    connect?: costume_abilityWhereUniqueInput
    update?: XOR<costume_abilityUpdateWithoutCostume_ability_linkInput, costume_abilityUncheckedUpdateWithoutCostume_ability_linkInput>
  }

  export type costumeUpdateOneRequiredWithoutCostume_ability_linkInput = {
    create?: XOR<costumeCreateWithoutCostume_ability_linkInput, costumeUncheckedCreateWithoutCostume_ability_linkInput>
    connectOrCreate?: costumeCreateOrConnectWithoutCostume_ability_linkInput
    upsert?: costumeUpsertWithoutCostume_ability_linkInput
    connect?: costumeWhereUniqueInput
    update?: XOR<costumeUpdateWithoutCostume_ability_linkInput, costumeUncheckedUpdateWithoutCostume_ability_linkInput>
  }

  export type costume_skill_linkCreateNestedManyWithoutCostume_skillInput = {
    create?: XOR<Enumerable<costume_skill_linkCreateWithoutCostume_skillInput>, Enumerable<costume_skill_linkUncheckedCreateWithoutCostume_skillInput>>
    connectOrCreate?: Enumerable<costume_skill_linkCreateOrConnectWithoutCostume_skillInput>
    createMany?: costume_skill_linkCreateManyCostume_skillInputEnvelope
    connect?: Enumerable<costume_skill_linkWhereUniqueInput>
  }

  export type costume_skill_linkUncheckedCreateNestedManyWithoutCostume_skillInput = {
    create?: XOR<Enumerable<costume_skill_linkCreateWithoutCostume_skillInput>, Enumerable<costume_skill_linkUncheckedCreateWithoutCostume_skillInput>>
    connectOrCreate?: Enumerable<costume_skill_linkCreateOrConnectWithoutCostume_skillInput>
    createMany?: costume_skill_linkCreateManyCostume_skillInputEnvelope
    connect?: Enumerable<costume_skill_linkWhereUniqueInput>
  }

  export type costume_skill_linkUpdateManyWithoutCostume_skillInput = {
    create?: XOR<Enumerable<costume_skill_linkCreateWithoutCostume_skillInput>, Enumerable<costume_skill_linkUncheckedCreateWithoutCostume_skillInput>>
    connectOrCreate?: Enumerable<costume_skill_linkCreateOrConnectWithoutCostume_skillInput>
    upsert?: Enumerable<costume_skill_linkUpsertWithWhereUniqueWithoutCostume_skillInput>
    createMany?: costume_skill_linkCreateManyCostume_skillInputEnvelope
    set?: Enumerable<costume_skill_linkWhereUniqueInput>
    disconnect?: Enumerable<costume_skill_linkWhereUniqueInput>
    delete?: Enumerable<costume_skill_linkWhereUniqueInput>
    connect?: Enumerable<costume_skill_linkWhereUniqueInput>
    update?: Enumerable<costume_skill_linkUpdateWithWhereUniqueWithoutCostume_skillInput>
    updateMany?: Enumerable<costume_skill_linkUpdateManyWithWhereWithoutCostume_skillInput>
    deleteMany?: Enumerable<costume_skill_linkScalarWhereInput>
  }

  export type costume_skill_linkUncheckedUpdateManyWithoutCostume_skillInput = {
    create?: XOR<Enumerable<costume_skill_linkCreateWithoutCostume_skillInput>, Enumerable<costume_skill_linkUncheckedCreateWithoutCostume_skillInput>>
    connectOrCreate?: Enumerable<costume_skill_linkCreateOrConnectWithoutCostume_skillInput>
    upsert?: Enumerable<costume_skill_linkUpsertWithWhereUniqueWithoutCostume_skillInput>
    createMany?: costume_skill_linkCreateManyCostume_skillInputEnvelope
    set?: Enumerable<costume_skill_linkWhereUniqueInput>
    disconnect?: Enumerable<costume_skill_linkWhereUniqueInput>
    delete?: Enumerable<costume_skill_linkWhereUniqueInput>
    connect?: Enumerable<costume_skill_linkWhereUniqueInput>
    update?: Enumerable<costume_skill_linkUpdateWithWhereUniqueWithoutCostume_skillInput>
    updateMany?: Enumerable<costume_skill_linkUpdateManyWithWhereWithoutCostume_skillInput>
    deleteMany?: Enumerable<costume_skill_linkScalarWhereInput>
  }

  export type costumeCreateNestedOneWithoutCostume_skill_linkInput = {
    create?: XOR<costumeCreateWithoutCostume_skill_linkInput, costumeUncheckedCreateWithoutCostume_skill_linkInput>
    connectOrCreate?: costumeCreateOrConnectWithoutCostume_skill_linkInput
    connect?: costumeWhereUniqueInput
  }

  export type costume_skillCreateNestedOneWithoutCostume_skill_linkInput = {
    create?: XOR<costume_skillCreateWithoutCostume_skill_linkInput, costume_skillUncheckedCreateWithoutCostume_skill_linkInput>
    connectOrCreate?: costume_skillCreateOrConnectWithoutCostume_skill_linkInput
    connect?: costume_skillWhereUniqueInput
  }

  export type costumeUpdateOneRequiredWithoutCostume_skill_linkInput = {
    create?: XOR<costumeCreateWithoutCostume_skill_linkInput, costumeUncheckedCreateWithoutCostume_skill_linkInput>
    connectOrCreate?: costumeCreateOrConnectWithoutCostume_skill_linkInput
    upsert?: costumeUpsertWithoutCostume_skill_linkInput
    connect?: costumeWhereUniqueInput
    update?: XOR<costumeUpdateWithoutCostume_skill_linkInput, costumeUncheckedUpdateWithoutCostume_skill_linkInput>
  }

  export type costume_skillUpdateOneRequiredWithoutCostume_skill_linkInput = {
    create?: XOR<costume_skillCreateWithoutCostume_skill_linkInput, costume_skillUncheckedCreateWithoutCostume_skill_linkInput>
    connectOrCreate?: costume_skillCreateOrConnectWithoutCostume_skill_linkInput
    upsert?: costume_skillUpsertWithoutCostume_skill_linkInput
    connect?: costume_skillWhereUniqueInput
    update?: XOR<costume_skillUpdateWithoutCostume_skill_linkInput, costume_skillUncheckedUpdateWithoutCostume_skill_linkInput>
  }

  export type costumeCreateNestedOneWithoutCostume_statInput = {
    create?: XOR<costumeCreateWithoutCostume_statInput, costumeUncheckedCreateWithoutCostume_statInput>
    connectOrCreate?: costumeCreateOrConnectWithoutCostume_statInput
    connect?: costumeWhereUniqueInput
  }

  export type costumeUpdateOneRequiredWithoutCostume_statInput = {
    create?: XOR<costumeCreateWithoutCostume_statInput, costumeUncheckedCreateWithoutCostume_statInput>
    connectOrCreate?: costumeCreateOrConnectWithoutCostume_statInput
    upsert?: costumeUpsertWithoutCostume_statInput
    connect?: costumeWhereUniqueInput
    update?: XOR<costumeUpdateWithoutCostume_statInput, costumeUncheckedUpdateWithoutCostume_statInput>
  }

  export type costumeCreateNestedManyWithoutEmblemInput = {
    create?: XOR<Enumerable<costumeCreateWithoutEmblemInput>, Enumerable<costumeUncheckedCreateWithoutEmblemInput>>
    connectOrCreate?: Enumerable<costumeCreateOrConnectWithoutEmblemInput>
    createMany?: costumeCreateManyEmblemInputEnvelope
    connect?: Enumerable<costumeWhereUniqueInput>
  }

  export type costumeUncheckedCreateNestedManyWithoutEmblemInput = {
    create?: XOR<Enumerable<costumeCreateWithoutEmblemInput>, Enumerable<costumeUncheckedCreateWithoutEmblemInput>>
    connectOrCreate?: Enumerable<costumeCreateOrConnectWithoutEmblemInput>
    createMany?: costumeCreateManyEmblemInputEnvelope
    connect?: Enumerable<costumeWhereUniqueInput>
  }

  export type costumeUpdateManyWithoutEmblemInput = {
    create?: XOR<Enumerable<costumeCreateWithoutEmblemInput>, Enumerable<costumeUncheckedCreateWithoutEmblemInput>>
    connectOrCreate?: Enumerable<costumeCreateOrConnectWithoutEmblemInput>
    upsert?: Enumerable<costumeUpsertWithWhereUniqueWithoutEmblemInput>
    createMany?: costumeCreateManyEmblemInputEnvelope
    set?: Enumerable<costumeWhereUniqueInput>
    disconnect?: Enumerable<costumeWhereUniqueInput>
    delete?: Enumerable<costumeWhereUniqueInput>
    connect?: Enumerable<costumeWhereUniqueInput>
    update?: Enumerable<costumeUpdateWithWhereUniqueWithoutEmblemInput>
    updateMany?: Enumerable<costumeUpdateManyWithWhereWithoutEmblemInput>
    deleteMany?: Enumerable<costumeScalarWhereInput>
  }

  export type costumeUncheckedUpdateManyWithoutEmblemInput = {
    create?: XOR<Enumerable<costumeCreateWithoutEmblemInput>, Enumerable<costumeUncheckedCreateWithoutEmblemInput>>
    connectOrCreate?: Enumerable<costumeCreateOrConnectWithoutEmblemInput>
    upsert?: Enumerable<costumeUpsertWithWhereUniqueWithoutEmblemInput>
    createMany?: costumeCreateManyEmblemInputEnvelope
    set?: Enumerable<costumeWhereUniqueInput>
    disconnect?: Enumerable<costumeWhereUniqueInput>
    delete?: Enumerable<costumeWhereUniqueInput>
    connect?: Enumerable<costumeWhereUniqueInput>
    update?: Enumerable<costumeUpdateWithWhereUniqueWithoutEmblemInput>
    updateMany?: Enumerable<costumeUpdateManyWithWhereWithoutEmblemInput>
    deleteMany?: Enumerable<costumeScalarWhereInput>
  }

  export type memoir_seriesCreateNestedOneWithoutMemoirInput = {
    create?: XOR<memoir_seriesCreateWithoutMemoirInput, memoir_seriesUncheckedCreateWithoutMemoirInput>
    connectOrCreate?: memoir_seriesCreateOrConnectWithoutMemoirInput
    connect?: memoir_seriesWhereUniqueInput
  }

  export type memoir_seriesUpdateOneWithoutMemoirInput = {
    create?: XOR<memoir_seriesCreateWithoutMemoirInput, memoir_seriesUncheckedCreateWithoutMemoirInput>
    connectOrCreate?: memoir_seriesCreateOrConnectWithoutMemoirInput
    upsert?: memoir_seriesUpsertWithoutMemoirInput
    disconnect?: boolean
    delete?: boolean
    connect?: memoir_seriesWhereUniqueInput
    update?: XOR<memoir_seriesUpdateWithoutMemoirInput, memoir_seriesUncheckedUpdateWithoutMemoirInput>
  }

  export type memoirCreateNestedManyWithoutMemoir_seriesInput = {
    create?: XOR<Enumerable<memoirCreateWithoutMemoir_seriesInput>, Enumerable<memoirUncheckedCreateWithoutMemoir_seriesInput>>
    connectOrCreate?: Enumerable<memoirCreateOrConnectWithoutMemoir_seriesInput>
    createMany?: memoirCreateManyMemoir_seriesInputEnvelope
    connect?: Enumerable<memoirWhereUniqueInput>
  }

  export type memoirUncheckedCreateNestedManyWithoutMemoir_seriesInput = {
    create?: XOR<Enumerable<memoirCreateWithoutMemoir_seriesInput>, Enumerable<memoirUncheckedCreateWithoutMemoir_seriesInput>>
    connectOrCreate?: Enumerable<memoirCreateOrConnectWithoutMemoir_seriesInput>
    createMany?: memoirCreateManyMemoir_seriesInputEnvelope
    connect?: Enumerable<memoirWhereUniqueInput>
  }

  export type memoirUpdateManyWithoutMemoir_seriesInput = {
    create?: XOR<Enumerable<memoirCreateWithoutMemoir_seriesInput>, Enumerable<memoirUncheckedCreateWithoutMemoir_seriesInput>>
    connectOrCreate?: Enumerable<memoirCreateOrConnectWithoutMemoir_seriesInput>
    upsert?: Enumerable<memoirUpsertWithWhereUniqueWithoutMemoir_seriesInput>
    createMany?: memoirCreateManyMemoir_seriesInputEnvelope
    set?: Enumerable<memoirWhereUniqueInput>
    disconnect?: Enumerable<memoirWhereUniqueInput>
    delete?: Enumerable<memoirWhereUniqueInput>
    connect?: Enumerable<memoirWhereUniqueInput>
    update?: Enumerable<memoirUpdateWithWhereUniqueWithoutMemoir_seriesInput>
    updateMany?: Enumerable<memoirUpdateManyWithWhereWithoutMemoir_seriesInput>
    deleteMany?: Enumerable<memoirScalarWhereInput>
  }

  export type memoirUncheckedUpdateManyWithoutMemoir_seriesInput = {
    create?: XOR<Enumerable<memoirCreateWithoutMemoir_seriesInput>, Enumerable<memoirUncheckedCreateWithoutMemoir_seriesInput>>
    connectOrCreate?: Enumerable<memoirCreateOrConnectWithoutMemoir_seriesInput>
    upsert?: Enumerable<memoirUpsertWithWhereUniqueWithoutMemoir_seriesInput>
    createMany?: memoirCreateManyMemoir_seriesInputEnvelope
    set?: Enumerable<memoirWhereUniqueInput>
    disconnect?: Enumerable<memoirWhereUniqueInput>
    delete?: Enumerable<memoirWhereUniqueInput>
    connect?: Enumerable<memoirWhereUniqueInput>
    update?: Enumerable<memoirUpdateWithWhereUniqueWithoutMemoir_seriesInput>
    updateMany?: Enumerable<memoirUpdateManyWithWhereWithoutMemoir_seriesInput>
    deleteMany?: Enumerable<memoirScalarWhereInput>
  }

  export type weapon_ability_linkCreateNestedManyWithoutWeaponInput = {
    create?: XOR<Enumerable<weapon_ability_linkCreateWithoutWeaponInput>, Enumerable<weapon_ability_linkUncheckedCreateWithoutWeaponInput>>
    connectOrCreate?: Enumerable<weapon_ability_linkCreateOrConnectWithoutWeaponInput>
    createMany?: weapon_ability_linkCreateManyWeaponInputEnvelope
    connect?: Enumerable<weapon_ability_linkWhereUniqueInput>
  }

  export type weapon_skill_linkCreateNestedManyWithoutWeaponInput = {
    create?: XOR<Enumerable<weapon_skill_linkCreateWithoutWeaponInput>, Enumerable<weapon_skill_linkUncheckedCreateWithoutWeaponInput>>
    connectOrCreate?: Enumerable<weapon_skill_linkCreateOrConnectWithoutWeaponInput>
    createMany?: weapon_skill_linkCreateManyWeaponInputEnvelope
    connect?: Enumerable<weapon_skill_linkWhereUniqueInput>
  }

  export type weapon_statCreateNestedManyWithoutWeaponInput = {
    create?: XOR<Enumerable<weapon_statCreateWithoutWeaponInput>, Enumerable<weapon_statUncheckedCreateWithoutWeaponInput>>
    connectOrCreate?: Enumerable<weapon_statCreateOrConnectWithoutWeaponInput>
    createMany?: weapon_statCreateManyWeaponInputEnvelope
    connect?: Enumerable<weapon_statWhereUniqueInput>
  }

  export type weapon_story_linkCreateNestedManyWithoutWeaponInput = {
    create?: XOR<Enumerable<weapon_story_linkCreateWithoutWeaponInput>, Enumerable<weapon_story_linkUncheckedCreateWithoutWeaponInput>>
    connectOrCreate?: Enumerable<weapon_story_linkCreateOrConnectWithoutWeaponInput>
    createMany?: weapon_story_linkCreateManyWeaponInputEnvelope
    connect?: Enumerable<weapon_story_linkWhereUniqueInput>
  }

  export type weapon_ability_linkUncheckedCreateNestedManyWithoutWeaponInput = {
    create?: XOR<Enumerable<weapon_ability_linkCreateWithoutWeaponInput>, Enumerable<weapon_ability_linkUncheckedCreateWithoutWeaponInput>>
    connectOrCreate?: Enumerable<weapon_ability_linkCreateOrConnectWithoutWeaponInput>
    createMany?: weapon_ability_linkCreateManyWeaponInputEnvelope
    connect?: Enumerable<weapon_ability_linkWhereUniqueInput>
  }

  export type weapon_skill_linkUncheckedCreateNestedManyWithoutWeaponInput = {
    create?: XOR<Enumerable<weapon_skill_linkCreateWithoutWeaponInput>, Enumerable<weapon_skill_linkUncheckedCreateWithoutWeaponInput>>
    connectOrCreate?: Enumerable<weapon_skill_linkCreateOrConnectWithoutWeaponInput>
    createMany?: weapon_skill_linkCreateManyWeaponInputEnvelope
    connect?: Enumerable<weapon_skill_linkWhereUniqueInput>
  }

  export type weapon_statUncheckedCreateNestedManyWithoutWeaponInput = {
    create?: XOR<Enumerable<weapon_statCreateWithoutWeaponInput>, Enumerable<weapon_statUncheckedCreateWithoutWeaponInput>>
    connectOrCreate?: Enumerable<weapon_statCreateOrConnectWithoutWeaponInput>
    createMany?: weapon_statCreateManyWeaponInputEnvelope
    connect?: Enumerable<weapon_statWhereUniqueInput>
  }

  export type weapon_story_linkUncheckedCreateNestedManyWithoutWeaponInput = {
    create?: XOR<Enumerable<weapon_story_linkCreateWithoutWeaponInput>, Enumerable<weapon_story_linkUncheckedCreateWithoutWeaponInput>>
    connectOrCreate?: Enumerable<weapon_story_linkCreateOrConnectWithoutWeaponInput>
    createMany?: weapon_story_linkCreateManyWeaponInputEnvelope
    connect?: Enumerable<weapon_story_linkWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type weapon_ability_linkUpdateManyWithoutWeaponInput = {
    create?: XOR<Enumerable<weapon_ability_linkCreateWithoutWeaponInput>, Enumerable<weapon_ability_linkUncheckedCreateWithoutWeaponInput>>
    connectOrCreate?: Enumerable<weapon_ability_linkCreateOrConnectWithoutWeaponInput>
    upsert?: Enumerable<weapon_ability_linkUpsertWithWhereUniqueWithoutWeaponInput>
    createMany?: weapon_ability_linkCreateManyWeaponInputEnvelope
    set?: Enumerable<weapon_ability_linkWhereUniqueInput>
    disconnect?: Enumerable<weapon_ability_linkWhereUniqueInput>
    delete?: Enumerable<weapon_ability_linkWhereUniqueInput>
    connect?: Enumerable<weapon_ability_linkWhereUniqueInput>
    update?: Enumerable<weapon_ability_linkUpdateWithWhereUniqueWithoutWeaponInput>
    updateMany?: Enumerable<weapon_ability_linkUpdateManyWithWhereWithoutWeaponInput>
    deleteMany?: Enumerable<weapon_ability_linkScalarWhereInput>
  }

  export type weapon_skill_linkUpdateManyWithoutWeaponInput = {
    create?: XOR<Enumerable<weapon_skill_linkCreateWithoutWeaponInput>, Enumerable<weapon_skill_linkUncheckedCreateWithoutWeaponInput>>
    connectOrCreate?: Enumerable<weapon_skill_linkCreateOrConnectWithoutWeaponInput>
    upsert?: Enumerable<weapon_skill_linkUpsertWithWhereUniqueWithoutWeaponInput>
    createMany?: weapon_skill_linkCreateManyWeaponInputEnvelope
    set?: Enumerable<weapon_skill_linkWhereUniqueInput>
    disconnect?: Enumerable<weapon_skill_linkWhereUniqueInput>
    delete?: Enumerable<weapon_skill_linkWhereUniqueInput>
    connect?: Enumerable<weapon_skill_linkWhereUniqueInput>
    update?: Enumerable<weapon_skill_linkUpdateWithWhereUniqueWithoutWeaponInput>
    updateMany?: Enumerable<weapon_skill_linkUpdateManyWithWhereWithoutWeaponInput>
    deleteMany?: Enumerable<weapon_skill_linkScalarWhereInput>
  }

  export type weapon_statUpdateManyWithoutWeaponInput = {
    create?: XOR<Enumerable<weapon_statCreateWithoutWeaponInput>, Enumerable<weapon_statUncheckedCreateWithoutWeaponInput>>
    connectOrCreate?: Enumerable<weapon_statCreateOrConnectWithoutWeaponInput>
    upsert?: Enumerable<weapon_statUpsertWithWhereUniqueWithoutWeaponInput>
    createMany?: weapon_statCreateManyWeaponInputEnvelope
    set?: Enumerable<weapon_statWhereUniqueInput>
    disconnect?: Enumerable<weapon_statWhereUniqueInput>
    delete?: Enumerable<weapon_statWhereUniqueInput>
    connect?: Enumerable<weapon_statWhereUniqueInput>
    update?: Enumerable<weapon_statUpdateWithWhereUniqueWithoutWeaponInput>
    updateMany?: Enumerable<weapon_statUpdateManyWithWhereWithoutWeaponInput>
    deleteMany?: Enumerable<weapon_statScalarWhereInput>
  }

  export type weapon_story_linkUpdateManyWithoutWeaponInput = {
    create?: XOR<Enumerable<weapon_story_linkCreateWithoutWeaponInput>, Enumerable<weapon_story_linkUncheckedCreateWithoutWeaponInput>>
    connectOrCreate?: Enumerable<weapon_story_linkCreateOrConnectWithoutWeaponInput>
    upsert?: Enumerable<weapon_story_linkUpsertWithWhereUniqueWithoutWeaponInput>
    createMany?: weapon_story_linkCreateManyWeaponInputEnvelope
    set?: Enumerable<weapon_story_linkWhereUniqueInput>
    disconnect?: Enumerable<weapon_story_linkWhereUniqueInput>
    delete?: Enumerable<weapon_story_linkWhereUniqueInput>
    connect?: Enumerable<weapon_story_linkWhereUniqueInput>
    update?: Enumerable<weapon_story_linkUpdateWithWhereUniqueWithoutWeaponInput>
    updateMany?: Enumerable<weapon_story_linkUpdateManyWithWhereWithoutWeaponInput>
    deleteMany?: Enumerable<weapon_story_linkScalarWhereInput>
  }

  export type weapon_ability_linkUncheckedUpdateManyWithoutWeaponInput = {
    create?: XOR<Enumerable<weapon_ability_linkCreateWithoutWeaponInput>, Enumerable<weapon_ability_linkUncheckedCreateWithoutWeaponInput>>
    connectOrCreate?: Enumerable<weapon_ability_linkCreateOrConnectWithoutWeaponInput>
    upsert?: Enumerable<weapon_ability_linkUpsertWithWhereUniqueWithoutWeaponInput>
    createMany?: weapon_ability_linkCreateManyWeaponInputEnvelope
    set?: Enumerable<weapon_ability_linkWhereUniqueInput>
    disconnect?: Enumerable<weapon_ability_linkWhereUniqueInput>
    delete?: Enumerable<weapon_ability_linkWhereUniqueInput>
    connect?: Enumerable<weapon_ability_linkWhereUniqueInput>
    update?: Enumerable<weapon_ability_linkUpdateWithWhereUniqueWithoutWeaponInput>
    updateMany?: Enumerable<weapon_ability_linkUpdateManyWithWhereWithoutWeaponInput>
    deleteMany?: Enumerable<weapon_ability_linkScalarWhereInput>
  }

  export type weapon_skill_linkUncheckedUpdateManyWithoutWeaponInput = {
    create?: XOR<Enumerable<weapon_skill_linkCreateWithoutWeaponInput>, Enumerable<weapon_skill_linkUncheckedCreateWithoutWeaponInput>>
    connectOrCreate?: Enumerable<weapon_skill_linkCreateOrConnectWithoutWeaponInput>
    upsert?: Enumerable<weapon_skill_linkUpsertWithWhereUniqueWithoutWeaponInput>
    createMany?: weapon_skill_linkCreateManyWeaponInputEnvelope
    set?: Enumerable<weapon_skill_linkWhereUniqueInput>
    disconnect?: Enumerable<weapon_skill_linkWhereUniqueInput>
    delete?: Enumerable<weapon_skill_linkWhereUniqueInput>
    connect?: Enumerable<weapon_skill_linkWhereUniqueInput>
    update?: Enumerable<weapon_skill_linkUpdateWithWhereUniqueWithoutWeaponInput>
    updateMany?: Enumerable<weapon_skill_linkUpdateManyWithWhereWithoutWeaponInput>
    deleteMany?: Enumerable<weapon_skill_linkScalarWhereInput>
  }

  export type weapon_statUncheckedUpdateManyWithoutWeaponInput = {
    create?: XOR<Enumerable<weapon_statCreateWithoutWeaponInput>, Enumerable<weapon_statUncheckedCreateWithoutWeaponInput>>
    connectOrCreate?: Enumerable<weapon_statCreateOrConnectWithoutWeaponInput>
    upsert?: Enumerable<weapon_statUpsertWithWhereUniqueWithoutWeaponInput>
    createMany?: weapon_statCreateManyWeaponInputEnvelope
    set?: Enumerable<weapon_statWhereUniqueInput>
    disconnect?: Enumerable<weapon_statWhereUniqueInput>
    delete?: Enumerable<weapon_statWhereUniqueInput>
    connect?: Enumerable<weapon_statWhereUniqueInput>
    update?: Enumerable<weapon_statUpdateWithWhereUniqueWithoutWeaponInput>
    updateMany?: Enumerable<weapon_statUpdateManyWithWhereWithoutWeaponInput>
    deleteMany?: Enumerable<weapon_statScalarWhereInput>
  }

  export type weapon_story_linkUncheckedUpdateManyWithoutWeaponInput = {
    create?: XOR<Enumerable<weapon_story_linkCreateWithoutWeaponInput>, Enumerable<weapon_story_linkUncheckedCreateWithoutWeaponInput>>
    connectOrCreate?: Enumerable<weapon_story_linkCreateOrConnectWithoutWeaponInput>
    upsert?: Enumerable<weapon_story_linkUpsertWithWhereUniqueWithoutWeaponInput>
    createMany?: weapon_story_linkCreateManyWeaponInputEnvelope
    set?: Enumerable<weapon_story_linkWhereUniqueInput>
    disconnect?: Enumerable<weapon_story_linkWhereUniqueInput>
    delete?: Enumerable<weapon_story_linkWhereUniqueInput>
    connect?: Enumerable<weapon_story_linkWhereUniqueInput>
    update?: Enumerable<weapon_story_linkUpdateWithWhereUniqueWithoutWeaponInput>
    updateMany?: Enumerable<weapon_story_linkUpdateManyWithWhereWithoutWeaponInput>
    deleteMany?: Enumerable<weapon_story_linkScalarWhereInput>
  }

  export type weapon_ability_linkCreateNestedManyWithoutWeapon_abilityInput = {
    create?: XOR<Enumerable<weapon_ability_linkCreateWithoutWeapon_abilityInput>, Enumerable<weapon_ability_linkUncheckedCreateWithoutWeapon_abilityInput>>
    connectOrCreate?: Enumerable<weapon_ability_linkCreateOrConnectWithoutWeapon_abilityInput>
    createMany?: weapon_ability_linkCreateManyWeapon_abilityInputEnvelope
    connect?: Enumerable<weapon_ability_linkWhereUniqueInput>
  }

  export type weapon_ability_linkUncheckedCreateNestedManyWithoutWeapon_abilityInput = {
    create?: XOR<Enumerable<weapon_ability_linkCreateWithoutWeapon_abilityInput>, Enumerable<weapon_ability_linkUncheckedCreateWithoutWeapon_abilityInput>>
    connectOrCreate?: Enumerable<weapon_ability_linkCreateOrConnectWithoutWeapon_abilityInput>
    createMany?: weapon_ability_linkCreateManyWeapon_abilityInputEnvelope
    connect?: Enumerable<weapon_ability_linkWhereUniqueInput>
  }

  export type weapon_ability_linkUpdateManyWithoutWeapon_abilityInput = {
    create?: XOR<Enumerable<weapon_ability_linkCreateWithoutWeapon_abilityInput>, Enumerable<weapon_ability_linkUncheckedCreateWithoutWeapon_abilityInput>>
    connectOrCreate?: Enumerable<weapon_ability_linkCreateOrConnectWithoutWeapon_abilityInput>
    upsert?: Enumerable<weapon_ability_linkUpsertWithWhereUniqueWithoutWeapon_abilityInput>
    createMany?: weapon_ability_linkCreateManyWeapon_abilityInputEnvelope
    set?: Enumerable<weapon_ability_linkWhereUniqueInput>
    disconnect?: Enumerable<weapon_ability_linkWhereUniqueInput>
    delete?: Enumerable<weapon_ability_linkWhereUniqueInput>
    connect?: Enumerable<weapon_ability_linkWhereUniqueInput>
    update?: Enumerable<weapon_ability_linkUpdateWithWhereUniqueWithoutWeapon_abilityInput>
    updateMany?: Enumerable<weapon_ability_linkUpdateManyWithWhereWithoutWeapon_abilityInput>
    deleteMany?: Enumerable<weapon_ability_linkScalarWhereInput>
  }

  export type weapon_ability_linkUncheckedUpdateManyWithoutWeapon_abilityInput = {
    create?: XOR<Enumerable<weapon_ability_linkCreateWithoutWeapon_abilityInput>, Enumerable<weapon_ability_linkUncheckedCreateWithoutWeapon_abilityInput>>
    connectOrCreate?: Enumerable<weapon_ability_linkCreateOrConnectWithoutWeapon_abilityInput>
    upsert?: Enumerable<weapon_ability_linkUpsertWithWhereUniqueWithoutWeapon_abilityInput>
    createMany?: weapon_ability_linkCreateManyWeapon_abilityInputEnvelope
    set?: Enumerable<weapon_ability_linkWhereUniqueInput>
    disconnect?: Enumerable<weapon_ability_linkWhereUniqueInput>
    delete?: Enumerable<weapon_ability_linkWhereUniqueInput>
    connect?: Enumerable<weapon_ability_linkWhereUniqueInput>
    update?: Enumerable<weapon_ability_linkUpdateWithWhereUniqueWithoutWeapon_abilityInput>
    updateMany?: Enumerable<weapon_ability_linkUpdateManyWithWhereWithoutWeapon_abilityInput>
    deleteMany?: Enumerable<weapon_ability_linkScalarWhereInput>
  }

  export type weapon_abilityCreateNestedOneWithoutWeapon_ability_linkInput = {
    create?: XOR<weapon_abilityCreateWithoutWeapon_ability_linkInput, weapon_abilityUncheckedCreateWithoutWeapon_ability_linkInput>
    connectOrCreate?: weapon_abilityCreateOrConnectWithoutWeapon_ability_linkInput
    connect?: weapon_abilityWhereUniqueInput
  }

  export type weaponCreateNestedOneWithoutWeapon_ability_linkInput = {
    create?: XOR<weaponCreateWithoutWeapon_ability_linkInput, weaponUncheckedCreateWithoutWeapon_ability_linkInput>
    connectOrCreate?: weaponCreateOrConnectWithoutWeapon_ability_linkInput
    connect?: weaponWhereUniqueInput
  }

  export type weapon_abilityUpdateOneRequiredWithoutWeapon_ability_linkInput = {
    create?: XOR<weapon_abilityCreateWithoutWeapon_ability_linkInput, weapon_abilityUncheckedCreateWithoutWeapon_ability_linkInput>
    connectOrCreate?: weapon_abilityCreateOrConnectWithoutWeapon_ability_linkInput
    upsert?: weapon_abilityUpsertWithoutWeapon_ability_linkInput
    connect?: weapon_abilityWhereUniqueInput
    update?: XOR<weapon_abilityUpdateWithoutWeapon_ability_linkInput, weapon_abilityUncheckedUpdateWithoutWeapon_ability_linkInput>
  }

  export type weaponUpdateOneRequiredWithoutWeapon_ability_linkInput = {
    create?: XOR<weaponCreateWithoutWeapon_ability_linkInput, weaponUncheckedCreateWithoutWeapon_ability_linkInput>
    connectOrCreate?: weaponCreateOrConnectWithoutWeapon_ability_linkInput
    upsert?: weaponUpsertWithoutWeapon_ability_linkInput
    connect?: weaponWhereUniqueInput
    update?: XOR<weaponUpdateWithoutWeapon_ability_linkInput, weaponUncheckedUpdateWithoutWeapon_ability_linkInput>
  }

  export type weapon_skill_linkCreateNestedManyWithoutWeapon_skillInput = {
    create?: XOR<Enumerable<weapon_skill_linkCreateWithoutWeapon_skillInput>, Enumerable<weapon_skill_linkUncheckedCreateWithoutWeapon_skillInput>>
    connectOrCreate?: Enumerable<weapon_skill_linkCreateOrConnectWithoutWeapon_skillInput>
    createMany?: weapon_skill_linkCreateManyWeapon_skillInputEnvelope
    connect?: Enumerable<weapon_skill_linkWhereUniqueInput>
  }

  export type weapon_skill_linkUncheckedCreateNestedManyWithoutWeapon_skillInput = {
    create?: XOR<Enumerable<weapon_skill_linkCreateWithoutWeapon_skillInput>, Enumerable<weapon_skill_linkUncheckedCreateWithoutWeapon_skillInput>>
    connectOrCreate?: Enumerable<weapon_skill_linkCreateOrConnectWithoutWeapon_skillInput>
    createMany?: weapon_skill_linkCreateManyWeapon_skillInputEnvelope
    connect?: Enumerable<weapon_skill_linkWhereUniqueInput>
  }

  export type weapon_skill_linkUpdateManyWithoutWeapon_skillInput = {
    create?: XOR<Enumerable<weapon_skill_linkCreateWithoutWeapon_skillInput>, Enumerable<weapon_skill_linkUncheckedCreateWithoutWeapon_skillInput>>
    connectOrCreate?: Enumerable<weapon_skill_linkCreateOrConnectWithoutWeapon_skillInput>
    upsert?: Enumerable<weapon_skill_linkUpsertWithWhereUniqueWithoutWeapon_skillInput>
    createMany?: weapon_skill_linkCreateManyWeapon_skillInputEnvelope
    set?: Enumerable<weapon_skill_linkWhereUniqueInput>
    disconnect?: Enumerable<weapon_skill_linkWhereUniqueInput>
    delete?: Enumerable<weapon_skill_linkWhereUniqueInput>
    connect?: Enumerable<weapon_skill_linkWhereUniqueInput>
    update?: Enumerable<weapon_skill_linkUpdateWithWhereUniqueWithoutWeapon_skillInput>
    updateMany?: Enumerable<weapon_skill_linkUpdateManyWithWhereWithoutWeapon_skillInput>
    deleteMany?: Enumerable<weapon_skill_linkScalarWhereInput>
  }

  export type weapon_skill_linkUncheckedUpdateManyWithoutWeapon_skillInput = {
    create?: XOR<Enumerable<weapon_skill_linkCreateWithoutWeapon_skillInput>, Enumerable<weapon_skill_linkUncheckedCreateWithoutWeapon_skillInput>>
    connectOrCreate?: Enumerable<weapon_skill_linkCreateOrConnectWithoutWeapon_skillInput>
    upsert?: Enumerable<weapon_skill_linkUpsertWithWhereUniqueWithoutWeapon_skillInput>
    createMany?: weapon_skill_linkCreateManyWeapon_skillInputEnvelope
    set?: Enumerable<weapon_skill_linkWhereUniqueInput>
    disconnect?: Enumerable<weapon_skill_linkWhereUniqueInput>
    delete?: Enumerable<weapon_skill_linkWhereUniqueInput>
    connect?: Enumerable<weapon_skill_linkWhereUniqueInput>
    update?: Enumerable<weapon_skill_linkUpdateWithWhereUniqueWithoutWeapon_skillInput>
    updateMany?: Enumerable<weapon_skill_linkUpdateManyWithWhereWithoutWeapon_skillInput>
    deleteMany?: Enumerable<weapon_skill_linkScalarWhereInput>
  }

  export type weapon_skillCreateNestedOneWithoutWeapon_skill_linkInput = {
    create?: XOR<weapon_skillCreateWithoutWeapon_skill_linkInput, weapon_skillUncheckedCreateWithoutWeapon_skill_linkInput>
    connectOrCreate?: weapon_skillCreateOrConnectWithoutWeapon_skill_linkInput
    connect?: weapon_skillWhereUniqueInput
  }

  export type weaponCreateNestedOneWithoutWeapon_skill_linkInput = {
    create?: XOR<weaponCreateWithoutWeapon_skill_linkInput, weaponUncheckedCreateWithoutWeapon_skill_linkInput>
    connectOrCreate?: weaponCreateOrConnectWithoutWeapon_skill_linkInput
    connect?: weaponWhereUniqueInput
  }

  export type weapon_skillUpdateOneRequiredWithoutWeapon_skill_linkInput = {
    create?: XOR<weapon_skillCreateWithoutWeapon_skill_linkInput, weapon_skillUncheckedCreateWithoutWeapon_skill_linkInput>
    connectOrCreate?: weapon_skillCreateOrConnectWithoutWeapon_skill_linkInput
    upsert?: weapon_skillUpsertWithoutWeapon_skill_linkInput
    connect?: weapon_skillWhereUniqueInput
    update?: XOR<weapon_skillUpdateWithoutWeapon_skill_linkInput, weapon_skillUncheckedUpdateWithoutWeapon_skill_linkInput>
  }

  export type weaponUpdateOneRequiredWithoutWeapon_skill_linkInput = {
    create?: XOR<weaponCreateWithoutWeapon_skill_linkInput, weaponUncheckedCreateWithoutWeapon_skill_linkInput>
    connectOrCreate?: weaponCreateOrConnectWithoutWeapon_skill_linkInput
    upsert?: weaponUpsertWithoutWeapon_skill_linkInput
    connect?: weaponWhereUniqueInput
    update?: XOR<weaponUpdateWithoutWeapon_skill_linkInput, weaponUncheckedUpdateWithoutWeapon_skill_linkInput>
  }

  export type weaponCreateNestedOneWithoutWeapon_statInput = {
    create?: XOR<weaponCreateWithoutWeapon_statInput, weaponUncheckedCreateWithoutWeapon_statInput>
    connectOrCreate?: weaponCreateOrConnectWithoutWeapon_statInput
    connect?: weaponWhereUniqueInput
  }

  export type weaponUpdateOneRequiredWithoutWeapon_statInput = {
    create?: XOR<weaponCreateWithoutWeapon_statInput, weaponUncheckedCreateWithoutWeapon_statInput>
    connectOrCreate?: weaponCreateOrConnectWithoutWeapon_statInput
    upsert?: weaponUpsertWithoutWeapon_statInput
    connect?: weaponWhereUniqueInput
    update?: XOR<weaponUpdateWithoutWeapon_statInput, weaponUncheckedUpdateWithoutWeapon_statInput>
  }

  export type weapon_story_linkCreateNestedManyWithoutWeapon_storyInput = {
    create?: XOR<Enumerable<weapon_story_linkCreateWithoutWeapon_storyInput>, Enumerable<weapon_story_linkUncheckedCreateWithoutWeapon_storyInput>>
    connectOrCreate?: Enumerable<weapon_story_linkCreateOrConnectWithoutWeapon_storyInput>
    createMany?: weapon_story_linkCreateManyWeapon_storyInputEnvelope
    connect?: Enumerable<weapon_story_linkWhereUniqueInput>
  }

  export type weapon_story_linkUncheckedCreateNestedManyWithoutWeapon_storyInput = {
    create?: XOR<Enumerable<weapon_story_linkCreateWithoutWeapon_storyInput>, Enumerable<weapon_story_linkUncheckedCreateWithoutWeapon_storyInput>>
    connectOrCreate?: Enumerable<weapon_story_linkCreateOrConnectWithoutWeapon_storyInput>
    createMany?: weapon_story_linkCreateManyWeapon_storyInputEnvelope
    connect?: Enumerable<weapon_story_linkWhereUniqueInput>
  }

  export type weapon_story_linkUpdateManyWithoutWeapon_storyInput = {
    create?: XOR<Enumerable<weapon_story_linkCreateWithoutWeapon_storyInput>, Enumerable<weapon_story_linkUncheckedCreateWithoutWeapon_storyInput>>
    connectOrCreate?: Enumerable<weapon_story_linkCreateOrConnectWithoutWeapon_storyInput>
    upsert?: Enumerable<weapon_story_linkUpsertWithWhereUniqueWithoutWeapon_storyInput>
    createMany?: weapon_story_linkCreateManyWeapon_storyInputEnvelope
    set?: Enumerable<weapon_story_linkWhereUniqueInput>
    disconnect?: Enumerable<weapon_story_linkWhereUniqueInput>
    delete?: Enumerable<weapon_story_linkWhereUniqueInput>
    connect?: Enumerable<weapon_story_linkWhereUniqueInput>
    update?: Enumerable<weapon_story_linkUpdateWithWhereUniqueWithoutWeapon_storyInput>
    updateMany?: Enumerable<weapon_story_linkUpdateManyWithWhereWithoutWeapon_storyInput>
    deleteMany?: Enumerable<weapon_story_linkScalarWhereInput>
  }

  export type weapon_story_linkUncheckedUpdateManyWithoutWeapon_storyInput = {
    create?: XOR<Enumerable<weapon_story_linkCreateWithoutWeapon_storyInput>, Enumerable<weapon_story_linkUncheckedCreateWithoutWeapon_storyInput>>
    connectOrCreate?: Enumerable<weapon_story_linkCreateOrConnectWithoutWeapon_storyInput>
    upsert?: Enumerable<weapon_story_linkUpsertWithWhereUniqueWithoutWeapon_storyInput>
    createMany?: weapon_story_linkCreateManyWeapon_storyInputEnvelope
    set?: Enumerable<weapon_story_linkWhereUniqueInput>
    disconnect?: Enumerable<weapon_story_linkWhereUniqueInput>
    delete?: Enumerable<weapon_story_linkWhereUniqueInput>
    connect?: Enumerable<weapon_story_linkWhereUniqueInput>
    update?: Enumerable<weapon_story_linkUpdateWithWhereUniqueWithoutWeapon_storyInput>
    updateMany?: Enumerable<weapon_story_linkUpdateManyWithWhereWithoutWeapon_storyInput>
    deleteMany?: Enumerable<weapon_story_linkScalarWhereInput>
  }

  export type weaponCreateNestedOneWithoutWeapon_story_linkInput = {
    create?: XOR<weaponCreateWithoutWeapon_story_linkInput, weaponUncheckedCreateWithoutWeapon_story_linkInput>
    connectOrCreate?: weaponCreateOrConnectWithoutWeapon_story_linkInput
    connect?: weaponWhereUniqueInput
  }

  export type weapon_storyCreateNestedOneWithoutWeapon_story_linkInput = {
    create?: XOR<weapon_storyCreateWithoutWeapon_story_linkInput, weapon_storyUncheckedCreateWithoutWeapon_story_linkInput>
    connectOrCreate?: weapon_storyCreateOrConnectWithoutWeapon_story_linkInput
    connect?: weapon_storyWhereUniqueInput
  }

  export type weaponUpdateOneRequiredWithoutWeapon_story_linkInput = {
    create?: XOR<weaponCreateWithoutWeapon_story_linkInput, weaponUncheckedCreateWithoutWeapon_story_linkInput>
    connectOrCreate?: weaponCreateOrConnectWithoutWeapon_story_linkInput
    upsert?: weaponUpsertWithoutWeapon_story_linkInput
    connect?: weaponWhereUniqueInput
    update?: XOR<weaponUpdateWithoutWeapon_story_linkInput, weaponUncheckedUpdateWithoutWeapon_story_linkInput>
  }

  export type weapon_storyUpdateOneRequiredWithoutWeapon_story_linkInput = {
    create?: XOR<weapon_storyCreateWithoutWeapon_story_linkInput, weapon_storyUncheckedCreateWithoutWeapon_story_linkInput>
    connectOrCreate?: weapon_storyCreateOrConnectWithoutWeapon_story_linkInput
    upsert?: weapon_storyUpsertWithoutWeapon_story_linkInput
    connect?: weapon_storyWhereUniqueInput
    update?: XOR<weapon_storyUpdateWithoutWeapon_story_linkInput, weapon_storyUncheckedUpdateWithoutWeapon_story_linkInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type character_rank_bonusCreateWithoutCharacterInput = {
    rank_bonus_id: number
    rank_bonus_level: number
    description?: string | null
    stat?: string | null
    type?: string | null
    amount: number
  }

  export type character_rank_bonusUncheckedCreateWithoutCharacterInput = {
    rank_bonus_id: number
    rank_bonus_level: number
    description?: string | null
    stat?: string | null
    type?: string | null
    amount: number
  }

  export type character_rank_bonusCreateOrConnectWithoutCharacterInput = {
    where: character_rank_bonusWhereUniqueInput
    create: XOR<character_rank_bonusCreateWithoutCharacterInput, character_rank_bonusUncheckedCreateWithoutCharacterInput>
  }

  export type character_rank_bonusCreateManyCharacterInputEnvelope = {
    data: Enumerable<character_rank_bonusCreateManyCharacterInput>
    skipDuplicates?: boolean
  }

  export type costumeCreateWithoutCharacterInput = {
    weapon_type?: string | null
    rarity?: string | null
    release_time: Date | string
    is_ex_costume: boolean
    slug?: string | null
    title?: string | null
    description?: string | null
    image_path_base?: string | null
    emblem?: emblemCreateNestedOneWithoutCostumeInput
    costume_ability_link?: costume_ability_linkCreateNestedManyWithoutCostumeInput
    costume_skill_link?: costume_skill_linkCreateNestedManyWithoutCostumeInput
    costume_stat?: costume_statCreateNestedManyWithoutCostumeInput
  }

  export type costumeUncheckedCreateWithoutCharacterInput = {
    costume_id?: number
    emblem_id?: number | null
    weapon_type?: string | null
    rarity?: string | null
    release_time: Date | string
    is_ex_costume: boolean
    slug?: string | null
    title?: string | null
    description?: string | null
    image_path_base?: string | null
    costume_ability_link?: costume_ability_linkUncheckedCreateNestedManyWithoutCostumeInput
    costume_skill_link?: costume_skill_linkUncheckedCreateNestedManyWithoutCostumeInput
    costume_stat?: costume_statUncheckedCreateNestedManyWithoutCostumeInput
  }

  export type costumeCreateOrConnectWithoutCharacterInput = {
    where: costumeWhereUniqueInput
    create: XOR<costumeCreateWithoutCharacterInput, costumeUncheckedCreateWithoutCharacterInput>
  }

  export type costumeCreateManyCharacterInputEnvelope = {
    data: Enumerable<costumeCreateManyCharacterInput>
    skipDuplicates?: boolean
  }

  export type character_rank_bonusUpsertWithWhereUniqueWithoutCharacterInput = {
    where: character_rank_bonusWhereUniqueInput
    update: XOR<character_rank_bonusUpdateWithoutCharacterInput, character_rank_bonusUncheckedUpdateWithoutCharacterInput>
    create: XOR<character_rank_bonusCreateWithoutCharacterInput, character_rank_bonusUncheckedCreateWithoutCharacterInput>
  }

  export type character_rank_bonusUpdateWithWhereUniqueWithoutCharacterInput = {
    where: character_rank_bonusWhereUniqueInput
    data: XOR<character_rank_bonusUpdateWithoutCharacterInput, character_rank_bonusUncheckedUpdateWithoutCharacterInput>
  }

  export type character_rank_bonusUpdateManyWithWhereWithoutCharacterInput = {
    where: character_rank_bonusScalarWhereInput
    data: XOR<character_rank_bonusUpdateManyMutationInput, character_rank_bonusUncheckedUpdateManyWithoutCharacter_rank_bonusInput>
  }

  export type character_rank_bonusScalarWhereInput = {
    AND?: Enumerable<character_rank_bonusScalarWhereInput>
    OR?: Enumerable<character_rank_bonusScalarWhereInput>
    NOT?: Enumerable<character_rank_bonusScalarWhereInput>
    rank_bonus_id?: IntFilter | number
    rank_bonus_level?: IntFilter | number
    character_id?: IntFilter | number
    description?: StringNullableFilter | string | null
    stat?: StringNullableFilter | string | null
    type?: StringNullableFilter | string | null
    amount?: IntFilter | number
  }

  export type costumeUpsertWithWhereUniqueWithoutCharacterInput = {
    where: costumeWhereUniqueInput
    update: XOR<costumeUpdateWithoutCharacterInput, costumeUncheckedUpdateWithoutCharacterInput>
    create: XOR<costumeCreateWithoutCharacterInput, costumeUncheckedCreateWithoutCharacterInput>
  }

  export type costumeUpdateWithWhereUniqueWithoutCharacterInput = {
    where: costumeWhereUniqueInput
    data: XOR<costumeUpdateWithoutCharacterInput, costumeUncheckedUpdateWithoutCharacterInput>
  }

  export type costumeUpdateManyWithWhereWithoutCharacterInput = {
    where: costumeScalarWhereInput
    data: XOR<costumeUpdateManyMutationInput, costumeUncheckedUpdateManyWithoutCostumeInput>
  }

  export type costumeScalarWhereInput = {
    AND?: Enumerable<costumeScalarWhereInput>
    OR?: Enumerable<costumeScalarWhereInput>
    NOT?: Enumerable<costumeScalarWhereInput>
    costume_id?: IntFilter | number
    character_id?: IntFilter | number
    emblem_id?: IntNullableFilter | number | null
    weapon_type?: StringNullableFilter | string | null
    rarity?: StringNullableFilter | string | null
    release_time?: DateTimeFilter | Date | string
    is_ex_costume?: BoolFilter | boolean
    slug?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    image_path_base?: StringNullableFilter | string | null
  }

  export type characterCreateWithoutCharacter_rank_bonusInput = {
    slug?: string | null
    name?: string | null
    image_path?: string | null
    costume?: costumeCreateNestedManyWithoutCharacterInput
  }

  export type characterUncheckedCreateWithoutCharacter_rank_bonusInput = {
    character_id?: number
    slug?: string | null
    name?: string | null
    image_path?: string | null
    costume?: costumeUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type characterCreateOrConnectWithoutCharacter_rank_bonusInput = {
    where: characterWhereUniqueInput
    create: XOR<characterCreateWithoutCharacter_rank_bonusInput, characterUncheckedCreateWithoutCharacter_rank_bonusInput>
  }

  export type characterUpsertWithoutCharacter_rank_bonusInput = {
    update: XOR<characterUpdateWithoutCharacter_rank_bonusInput, characterUncheckedUpdateWithoutCharacter_rank_bonusInput>
    create: XOR<characterCreateWithoutCharacter_rank_bonusInput, characterUncheckedCreateWithoutCharacter_rank_bonusInput>
  }

  export type characterUpdateWithoutCharacter_rank_bonusInput = {
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    costume?: costumeUpdateManyWithoutCharacterInput
  }

  export type characterUncheckedUpdateWithoutCharacter_rank_bonusInput = {
    character_id?: IntFieldUpdateOperationsInput | number
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    costume?: costumeUncheckedUpdateManyWithoutCharacterInput
  }

  export type companion_ability_linkCreateWithoutCompanionInput = {
    companion_level: number
    companion_ability: companion_abilityCreateNestedOneWithoutCompanion_ability_linkInput
  }

  export type companion_ability_linkUncheckedCreateWithoutCompanionInput = {
    companion_level: number
    ability_id: number
    ability_level: number
  }

  export type companion_ability_linkCreateOrConnectWithoutCompanionInput = {
    where: companion_ability_linkWhereUniqueInput
    create: XOR<companion_ability_linkCreateWithoutCompanionInput, companion_ability_linkUncheckedCreateWithoutCompanionInput>
  }

  export type companion_ability_linkCreateManyCompanionInputEnvelope = {
    data: Enumerable<companion_ability_linkCreateManyCompanionInput>
    skipDuplicates?: boolean
  }

  export type companion_skill_linkCreateWithoutCompanionInput = {
    companion_level: number
    companion_skill: companion_skillCreateNestedOneWithoutCompanion_skill_linkInput
  }

  export type companion_skill_linkUncheckedCreateWithoutCompanionInput = {
    companion_level: number
    skill_id: number
    skill_level: number
  }

  export type companion_skill_linkCreateOrConnectWithoutCompanionInput = {
    where: companion_skill_linkWhereUniqueInput
    create: XOR<companion_skill_linkCreateWithoutCompanionInput, companion_skill_linkUncheckedCreateWithoutCompanionInput>
  }

  export type companion_skill_linkCreateManyCompanionInputEnvelope = {
    data: Enumerable<companion_skill_linkCreateManyCompanionInput>
    skipDuplicates?: boolean
  }

  export type companion_statCreateWithoutCompanionInput = {
    level: number
    atk: number
    hp: number
    vit: number
  }

  export type companion_statUncheckedCreateWithoutCompanionInput = {
    level: number
    atk: number
    hp: number
    vit: number
  }

  export type companion_statCreateOrConnectWithoutCompanionInput = {
    where: companion_statWhereUniqueInput
    create: XOR<companion_statCreateWithoutCompanionInput, companion_statUncheckedCreateWithoutCompanionInput>
  }

  export type companion_statCreateManyCompanionInputEnvelope = {
    data: Enumerable<companion_statCreateManyCompanionInput>
    skipDuplicates?: boolean
  }

  export type companion_ability_linkUpsertWithWhereUniqueWithoutCompanionInput = {
    where: companion_ability_linkWhereUniqueInput
    update: XOR<companion_ability_linkUpdateWithoutCompanionInput, companion_ability_linkUncheckedUpdateWithoutCompanionInput>
    create: XOR<companion_ability_linkCreateWithoutCompanionInput, companion_ability_linkUncheckedCreateWithoutCompanionInput>
  }

  export type companion_ability_linkUpdateWithWhereUniqueWithoutCompanionInput = {
    where: companion_ability_linkWhereUniqueInput
    data: XOR<companion_ability_linkUpdateWithoutCompanionInput, companion_ability_linkUncheckedUpdateWithoutCompanionInput>
  }

  export type companion_ability_linkUpdateManyWithWhereWithoutCompanionInput = {
    where: companion_ability_linkScalarWhereInput
    data: XOR<companion_ability_linkUpdateManyMutationInput, companion_ability_linkUncheckedUpdateManyWithoutCompanion_ability_linkInput>
  }

  export type companion_ability_linkScalarWhereInput = {
    AND?: Enumerable<companion_ability_linkScalarWhereInput>
    OR?: Enumerable<companion_ability_linkScalarWhereInput>
    NOT?: Enumerable<companion_ability_linkScalarWhereInput>
    companion_id?: IntFilter | number
    companion_level?: IntFilter | number
    ability_id?: IntFilter | number
    ability_level?: IntFilter | number
  }

  export type companion_skill_linkUpsertWithWhereUniqueWithoutCompanionInput = {
    where: companion_skill_linkWhereUniqueInput
    update: XOR<companion_skill_linkUpdateWithoutCompanionInput, companion_skill_linkUncheckedUpdateWithoutCompanionInput>
    create: XOR<companion_skill_linkCreateWithoutCompanionInput, companion_skill_linkUncheckedCreateWithoutCompanionInput>
  }

  export type companion_skill_linkUpdateWithWhereUniqueWithoutCompanionInput = {
    where: companion_skill_linkWhereUniqueInput
    data: XOR<companion_skill_linkUpdateWithoutCompanionInput, companion_skill_linkUncheckedUpdateWithoutCompanionInput>
  }

  export type companion_skill_linkUpdateManyWithWhereWithoutCompanionInput = {
    where: companion_skill_linkScalarWhereInput
    data: XOR<companion_skill_linkUpdateManyMutationInput, companion_skill_linkUncheckedUpdateManyWithoutCompanion_skill_linkInput>
  }

  export type companion_skill_linkScalarWhereInput = {
    AND?: Enumerable<companion_skill_linkScalarWhereInput>
    OR?: Enumerable<companion_skill_linkScalarWhereInput>
    NOT?: Enumerable<companion_skill_linkScalarWhereInput>
    companion_id?: IntFilter | number
    companion_level?: IntFilter | number
    skill_id?: IntFilter | number
    skill_level?: IntFilter | number
  }

  export type companion_statUpsertWithWhereUniqueWithoutCompanionInput = {
    where: companion_statWhereUniqueInput
    update: XOR<companion_statUpdateWithoutCompanionInput, companion_statUncheckedUpdateWithoutCompanionInput>
    create: XOR<companion_statCreateWithoutCompanionInput, companion_statUncheckedCreateWithoutCompanionInput>
  }

  export type companion_statUpdateWithWhereUniqueWithoutCompanionInput = {
    where: companion_statWhereUniqueInput
    data: XOR<companion_statUpdateWithoutCompanionInput, companion_statUncheckedUpdateWithoutCompanionInput>
  }

  export type companion_statUpdateManyWithWhereWithoutCompanionInput = {
    where: companion_statScalarWhereInput
    data: XOR<companion_statUpdateManyMutationInput, companion_statUncheckedUpdateManyWithoutCompanion_statInput>
  }

  export type companion_statScalarWhereInput = {
    AND?: Enumerable<companion_statScalarWhereInput>
    OR?: Enumerable<companion_statScalarWhereInput>
    NOT?: Enumerable<companion_statScalarWhereInput>
    companion_id?: IntFilter | number
    level?: IntFilter | number
    atk?: IntFilter | number
    hp?: IntFilter | number
    vit?: IntFilter | number
  }

  export type companion_ability_linkCreateWithoutCompanion_abilityInput = {
    companion_level: number
    companion: companionCreateNestedOneWithoutCompanion_ability_linkInput
  }

  export type companion_ability_linkUncheckedCreateWithoutCompanion_abilityInput = {
    companion_id: number
    companion_level: number
  }

  export type companion_ability_linkCreateOrConnectWithoutCompanion_abilityInput = {
    where: companion_ability_linkWhereUniqueInput
    create: XOR<companion_ability_linkCreateWithoutCompanion_abilityInput, companion_ability_linkUncheckedCreateWithoutCompanion_abilityInput>
  }

  export type companion_ability_linkCreateManyCompanion_abilityInputEnvelope = {
    data: Enumerable<companion_ability_linkCreateManyCompanion_abilityInput>
    skipDuplicates?: boolean
  }

  export type companion_ability_linkUpsertWithWhereUniqueWithoutCompanion_abilityInput = {
    where: companion_ability_linkWhereUniqueInput
    update: XOR<companion_ability_linkUpdateWithoutCompanion_abilityInput, companion_ability_linkUncheckedUpdateWithoutCompanion_abilityInput>
    create: XOR<companion_ability_linkCreateWithoutCompanion_abilityInput, companion_ability_linkUncheckedCreateWithoutCompanion_abilityInput>
  }

  export type companion_ability_linkUpdateWithWhereUniqueWithoutCompanion_abilityInput = {
    where: companion_ability_linkWhereUniqueInput
    data: XOR<companion_ability_linkUpdateWithoutCompanion_abilityInput, companion_ability_linkUncheckedUpdateWithoutCompanion_abilityInput>
  }

  export type companion_ability_linkUpdateManyWithWhereWithoutCompanion_abilityInput = {
    where: companion_ability_linkScalarWhereInput
    data: XOR<companion_ability_linkUpdateManyMutationInput, companion_ability_linkUncheckedUpdateManyWithoutCompanion_ability_linkInput>
  }

  export type companion_abilityCreateWithoutCompanion_ability_linkInput = {
    ability_id: number
    ability_level: number
    name?: string | null
    description?: string | null
    image_path_base?: string | null
  }

  export type companion_abilityUncheckedCreateWithoutCompanion_ability_linkInput = {
    ability_id: number
    ability_level: number
    name?: string | null
    description?: string | null
    image_path_base?: string | null
  }

  export type companion_abilityCreateOrConnectWithoutCompanion_ability_linkInput = {
    where: companion_abilityWhereUniqueInput
    create: XOR<companion_abilityCreateWithoutCompanion_ability_linkInput, companion_abilityUncheckedCreateWithoutCompanion_ability_linkInput>
  }

  export type companionCreateWithoutCompanion_ability_linkInput = {
    attribute?: string | null
    type?: string | null
    release_time: Date | string
    name?: string | null
    story?: string | null
    image_path_base?: string | null
    companion_skill_link?: companion_skill_linkCreateNestedManyWithoutCompanionInput
    companion_stat?: companion_statCreateNestedManyWithoutCompanionInput
  }

  export type companionUncheckedCreateWithoutCompanion_ability_linkInput = {
    companion_id?: number
    attribute?: string | null
    type?: string | null
    release_time: Date | string
    name?: string | null
    story?: string | null
    image_path_base?: string | null
    companion_skill_link?: companion_skill_linkUncheckedCreateNestedManyWithoutCompanionInput
    companion_stat?: companion_statUncheckedCreateNestedManyWithoutCompanionInput
  }

  export type companionCreateOrConnectWithoutCompanion_ability_linkInput = {
    where: companionWhereUniqueInput
    create: XOR<companionCreateWithoutCompanion_ability_linkInput, companionUncheckedCreateWithoutCompanion_ability_linkInput>
  }

  export type companion_abilityUpsertWithoutCompanion_ability_linkInput = {
    update: XOR<companion_abilityUpdateWithoutCompanion_ability_linkInput, companion_abilityUncheckedUpdateWithoutCompanion_ability_linkInput>
    create: XOR<companion_abilityCreateWithoutCompanion_ability_linkInput, companion_abilityUncheckedCreateWithoutCompanion_ability_linkInput>
  }

  export type companion_abilityUpdateWithoutCompanion_ability_linkInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type companion_abilityUncheckedUpdateWithoutCompanion_ability_linkInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type companionUpsertWithoutCompanion_ability_linkInput = {
    update: XOR<companionUpdateWithoutCompanion_ability_linkInput, companionUncheckedUpdateWithoutCompanion_ability_linkInput>
    create: XOR<companionCreateWithoutCompanion_ability_linkInput, companionUncheckedCreateWithoutCompanion_ability_linkInput>
  }

  export type companionUpdateWithoutCompanion_ability_linkInput = {
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    companion_skill_link?: companion_skill_linkUpdateManyWithoutCompanionInput
    companion_stat?: companion_statUpdateManyWithoutCompanionInput
  }

  export type companionUncheckedUpdateWithoutCompanion_ability_linkInput = {
    companion_id?: IntFieldUpdateOperationsInput | number
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    companion_skill_link?: companion_skill_linkUncheckedUpdateManyWithoutCompanionInput
    companion_stat?: companion_statUncheckedUpdateManyWithoutCompanionInput
  }

  export type companion_skill_linkCreateWithoutCompanion_skillInput = {
    companion_level: number
    companion: companionCreateNestedOneWithoutCompanion_skill_linkInput
  }

  export type companion_skill_linkUncheckedCreateWithoutCompanion_skillInput = {
    companion_id: number
    companion_level: number
  }

  export type companion_skill_linkCreateOrConnectWithoutCompanion_skillInput = {
    where: companion_skill_linkWhereUniqueInput
    create: XOR<companion_skill_linkCreateWithoutCompanion_skillInput, companion_skill_linkUncheckedCreateWithoutCompanion_skillInput>
  }

  export type companion_skill_linkCreateManyCompanion_skillInputEnvelope = {
    data: Enumerable<companion_skill_linkCreateManyCompanion_skillInput>
    skipDuplicates?: boolean
  }

  export type companion_skill_linkUpsertWithWhereUniqueWithoutCompanion_skillInput = {
    where: companion_skill_linkWhereUniqueInput
    update: XOR<companion_skill_linkUpdateWithoutCompanion_skillInput, companion_skill_linkUncheckedUpdateWithoutCompanion_skillInput>
    create: XOR<companion_skill_linkCreateWithoutCompanion_skillInput, companion_skill_linkUncheckedCreateWithoutCompanion_skillInput>
  }

  export type companion_skill_linkUpdateWithWhereUniqueWithoutCompanion_skillInput = {
    where: companion_skill_linkWhereUniqueInput
    data: XOR<companion_skill_linkUpdateWithoutCompanion_skillInput, companion_skill_linkUncheckedUpdateWithoutCompanion_skillInput>
  }

  export type companion_skill_linkUpdateManyWithWhereWithoutCompanion_skillInput = {
    where: companion_skill_linkScalarWhereInput
    data: XOR<companion_skill_linkUpdateManyMutationInput, companion_skill_linkUncheckedUpdateManyWithoutCompanion_skill_linkInput>
  }

  export type companionCreateWithoutCompanion_skill_linkInput = {
    attribute?: string | null
    type?: string | null
    release_time: Date | string
    name?: string | null
    story?: string | null
    image_path_base?: string | null
    companion_ability_link?: companion_ability_linkCreateNestedManyWithoutCompanionInput
    companion_stat?: companion_statCreateNestedManyWithoutCompanionInput
  }

  export type companionUncheckedCreateWithoutCompanion_skill_linkInput = {
    companion_id?: number
    attribute?: string | null
    type?: string | null
    release_time: Date | string
    name?: string | null
    story?: string | null
    image_path_base?: string | null
    companion_ability_link?: companion_ability_linkUncheckedCreateNestedManyWithoutCompanionInput
    companion_stat?: companion_statUncheckedCreateNestedManyWithoutCompanionInput
  }

  export type companionCreateOrConnectWithoutCompanion_skill_linkInput = {
    where: companionWhereUniqueInput
    create: XOR<companionCreateWithoutCompanion_skill_linkInput, companionUncheckedCreateWithoutCompanion_skill_linkInput>
  }

  export type companion_skillCreateWithoutCompanion_skill_linkInput = {
    skill_id: number
    skill_level: number
    cooldown_time: number
    name?: string | null
    description?: string | null
    short_description?: string | null
    image_path?: string | null
  }

  export type companion_skillUncheckedCreateWithoutCompanion_skill_linkInput = {
    skill_id: number
    skill_level: number
    cooldown_time: number
    name?: string | null
    description?: string | null
    short_description?: string | null
    image_path?: string | null
  }

  export type companion_skillCreateOrConnectWithoutCompanion_skill_linkInput = {
    where: companion_skillWhereUniqueInput
    create: XOR<companion_skillCreateWithoutCompanion_skill_linkInput, companion_skillUncheckedCreateWithoutCompanion_skill_linkInput>
  }

  export type companionUpsertWithoutCompanion_skill_linkInput = {
    update: XOR<companionUpdateWithoutCompanion_skill_linkInput, companionUncheckedUpdateWithoutCompanion_skill_linkInput>
    create: XOR<companionCreateWithoutCompanion_skill_linkInput, companionUncheckedCreateWithoutCompanion_skill_linkInput>
  }

  export type companionUpdateWithoutCompanion_skill_linkInput = {
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    companion_ability_link?: companion_ability_linkUpdateManyWithoutCompanionInput
    companion_stat?: companion_statUpdateManyWithoutCompanionInput
  }

  export type companionUncheckedUpdateWithoutCompanion_skill_linkInput = {
    companion_id?: IntFieldUpdateOperationsInput | number
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    companion_ability_link?: companion_ability_linkUncheckedUpdateManyWithoutCompanionInput
    companion_stat?: companion_statUncheckedUpdateManyWithoutCompanionInput
  }

  export type companion_skillUpsertWithoutCompanion_skill_linkInput = {
    update: XOR<companion_skillUpdateWithoutCompanion_skill_linkInput, companion_skillUncheckedUpdateWithoutCompanion_skill_linkInput>
    create: XOR<companion_skillCreateWithoutCompanion_skill_linkInput, companion_skillUncheckedCreateWithoutCompanion_skill_linkInput>
  }

  export type companion_skillUpdateWithoutCompanion_skill_linkInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type companion_skillUncheckedUpdateWithoutCompanion_skill_linkInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type companionCreateWithoutCompanion_statInput = {
    attribute?: string | null
    type?: string | null
    release_time: Date | string
    name?: string | null
    story?: string | null
    image_path_base?: string | null
    companion_ability_link?: companion_ability_linkCreateNestedManyWithoutCompanionInput
    companion_skill_link?: companion_skill_linkCreateNestedManyWithoutCompanionInput
  }

  export type companionUncheckedCreateWithoutCompanion_statInput = {
    companion_id?: number
    attribute?: string | null
    type?: string | null
    release_time: Date | string
    name?: string | null
    story?: string | null
    image_path_base?: string | null
    companion_ability_link?: companion_ability_linkUncheckedCreateNestedManyWithoutCompanionInput
    companion_skill_link?: companion_skill_linkUncheckedCreateNestedManyWithoutCompanionInput
  }

  export type companionCreateOrConnectWithoutCompanion_statInput = {
    where: companionWhereUniqueInput
    create: XOR<companionCreateWithoutCompanion_statInput, companionUncheckedCreateWithoutCompanion_statInput>
  }

  export type companionUpsertWithoutCompanion_statInput = {
    update: XOR<companionUpdateWithoutCompanion_statInput, companionUncheckedUpdateWithoutCompanion_statInput>
    create: XOR<companionCreateWithoutCompanion_statInput, companionUncheckedCreateWithoutCompanion_statInput>
  }

  export type companionUpdateWithoutCompanion_statInput = {
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    companion_ability_link?: companion_ability_linkUpdateManyWithoutCompanionInput
    companion_skill_link?: companion_skill_linkUpdateManyWithoutCompanionInput
  }

  export type companionUncheckedUpdateWithoutCompanion_statInput = {
    companion_id?: IntFieldUpdateOperationsInput | number
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    companion_ability_link?: companion_ability_linkUncheckedUpdateManyWithoutCompanionInput
    companion_skill_link?: companion_skill_linkUncheckedUpdateManyWithoutCompanionInput
  }

  export type characterCreateWithoutCostumeInput = {
    slug?: string | null
    name?: string | null
    image_path?: string | null
    character_rank_bonus?: character_rank_bonusCreateNestedManyWithoutCharacterInput
  }

  export type characterUncheckedCreateWithoutCostumeInput = {
    character_id?: number
    slug?: string | null
    name?: string | null
    image_path?: string | null
    character_rank_bonus?: character_rank_bonusUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type characterCreateOrConnectWithoutCostumeInput = {
    where: characterWhereUniqueInput
    create: XOR<characterCreateWithoutCostumeInput, characterUncheckedCreateWithoutCostumeInput>
  }

  export type emblemCreateWithoutCostumeInput = {
    name?: string | null
    main_message?: string | null
    small_messages?: string | null
    image_path?: string | null
  }

  export type emblemUncheckedCreateWithoutCostumeInput = {
    emblem_id?: number
    name?: string | null
    main_message?: string | null
    small_messages?: string | null
    image_path?: string | null
  }

  export type emblemCreateOrConnectWithoutCostumeInput = {
    where: emblemWhereUniqueInput
    create: XOR<emblemCreateWithoutCostumeInput, emblemUncheckedCreateWithoutCostumeInput>
  }

  export type costume_ability_linkCreateWithoutCostumeInput = {
    ability_slot: number
    costume_ability: costume_abilityCreateNestedOneWithoutCostume_ability_linkInput
  }

  export type costume_ability_linkUncheckedCreateWithoutCostumeInput = {
    ability_slot: number
    ability_id: number
    ability_level: number
  }

  export type costume_ability_linkCreateOrConnectWithoutCostumeInput = {
    where: costume_ability_linkWhereUniqueInput
    create: XOR<costume_ability_linkCreateWithoutCostumeInput, costume_ability_linkUncheckedCreateWithoutCostumeInput>
  }

  export type costume_ability_linkCreateManyCostumeInputEnvelope = {
    data: Enumerable<costume_ability_linkCreateManyCostumeInput>
    skipDuplicates?: boolean
  }

  export type costume_skill_linkCreateWithoutCostumeInput = {
    costume_skill: costume_skillCreateNestedOneWithoutCostume_skill_linkInput
  }

  export type costume_skill_linkUncheckedCreateWithoutCostumeInput = {
    skill_id: number
    skill_level: number
  }

  export type costume_skill_linkCreateOrConnectWithoutCostumeInput = {
    where: costume_skill_linkWhereUniqueInput
    create: XOR<costume_skill_linkCreateWithoutCostumeInput, costume_skill_linkUncheckedCreateWithoutCostumeInput>
  }

  export type costume_skill_linkCreateManyCostumeInputEnvelope = {
    data: Enumerable<costume_skill_linkCreateManyCostumeInput>
    skipDuplicates?: boolean
  }

  export type costume_statCreateWithoutCostumeInput = {
    level: number
    agi: number
    atk: number
    crit_atk: number
    crit_rate: number
    eva_rate: number
    hp: number
    vit: number
  }

  export type costume_statUncheckedCreateWithoutCostumeInput = {
    level: number
    agi: number
    atk: number
    crit_atk: number
    crit_rate: number
    eva_rate: number
    hp: number
    vit: number
  }

  export type costume_statCreateOrConnectWithoutCostumeInput = {
    where: costume_statWhereUniqueInput
    create: XOR<costume_statCreateWithoutCostumeInput, costume_statUncheckedCreateWithoutCostumeInput>
  }

  export type costume_statCreateManyCostumeInputEnvelope = {
    data: Enumerable<costume_statCreateManyCostumeInput>
    skipDuplicates?: boolean
  }

  export type characterUpsertWithoutCostumeInput = {
    update: XOR<characterUpdateWithoutCostumeInput, characterUncheckedUpdateWithoutCostumeInput>
    create: XOR<characterCreateWithoutCostumeInput, characterUncheckedCreateWithoutCostumeInput>
  }

  export type characterUpdateWithoutCostumeInput = {
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    character_rank_bonus?: character_rank_bonusUpdateManyWithoutCharacterInput
  }

  export type characterUncheckedUpdateWithoutCostumeInput = {
    character_id?: IntFieldUpdateOperationsInput | number
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    character_rank_bonus?: character_rank_bonusUncheckedUpdateManyWithoutCharacterInput
  }

  export type emblemUpsertWithoutCostumeInput = {
    update: XOR<emblemUpdateWithoutCostumeInput, emblemUncheckedUpdateWithoutCostumeInput>
    create: XOR<emblemCreateWithoutCostumeInput, emblemUncheckedCreateWithoutCostumeInput>
  }

  export type emblemUpdateWithoutCostumeInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    main_message?: NullableStringFieldUpdateOperationsInput | string | null
    small_messages?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type emblemUncheckedUpdateWithoutCostumeInput = {
    emblem_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    main_message?: NullableStringFieldUpdateOperationsInput | string | null
    small_messages?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type costume_ability_linkUpsertWithWhereUniqueWithoutCostumeInput = {
    where: costume_ability_linkWhereUniqueInput
    update: XOR<costume_ability_linkUpdateWithoutCostumeInput, costume_ability_linkUncheckedUpdateWithoutCostumeInput>
    create: XOR<costume_ability_linkCreateWithoutCostumeInput, costume_ability_linkUncheckedCreateWithoutCostumeInput>
  }

  export type costume_ability_linkUpdateWithWhereUniqueWithoutCostumeInput = {
    where: costume_ability_linkWhereUniqueInput
    data: XOR<costume_ability_linkUpdateWithoutCostumeInput, costume_ability_linkUncheckedUpdateWithoutCostumeInput>
  }

  export type costume_ability_linkUpdateManyWithWhereWithoutCostumeInput = {
    where: costume_ability_linkScalarWhereInput
    data: XOR<costume_ability_linkUpdateManyMutationInput, costume_ability_linkUncheckedUpdateManyWithoutCostume_ability_linkInput>
  }

  export type costume_ability_linkScalarWhereInput = {
    AND?: Enumerable<costume_ability_linkScalarWhereInput>
    OR?: Enumerable<costume_ability_linkScalarWhereInput>
    NOT?: Enumerable<costume_ability_linkScalarWhereInput>
    costume_id?: IntFilter | number
    ability_slot?: IntFilter | number
    ability_id?: IntFilter | number
    ability_level?: IntFilter | number
  }

  export type costume_skill_linkUpsertWithWhereUniqueWithoutCostumeInput = {
    where: costume_skill_linkWhereUniqueInput
    update: XOR<costume_skill_linkUpdateWithoutCostumeInput, costume_skill_linkUncheckedUpdateWithoutCostumeInput>
    create: XOR<costume_skill_linkCreateWithoutCostumeInput, costume_skill_linkUncheckedCreateWithoutCostumeInput>
  }

  export type costume_skill_linkUpdateWithWhereUniqueWithoutCostumeInput = {
    where: costume_skill_linkWhereUniqueInput
    data: XOR<costume_skill_linkUpdateWithoutCostumeInput, costume_skill_linkUncheckedUpdateWithoutCostumeInput>
  }

  export type costume_skill_linkUpdateManyWithWhereWithoutCostumeInput = {
    where: costume_skill_linkScalarWhereInput
    data: XOR<costume_skill_linkUpdateManyMutationInput, costume_skill_linkUncheckedUpdateManyWithoutCostume_skill_linkInput>
  }

  export type costume_skill_linkScalarWhereInput = {
    AND?: Enumerable<costume_skill_linkScalarWhereInput>
    OR?: Enumerable<costume_skill_linkScalarWhereInput>
    NOT?: Enumerable<costume_skill_linkScalarWhereInput>
    costume_id?: IntFilter | number
    skill_id?: IntFilter | number
    skill_level?: IntFilter | number
  }

  export type costume_statUpsertWithWhereUniqueWithoutCostumeInput = {
    where: costume_statWhereUniqueInput
    update: XOR<costume_statUpdateWithoutCostumeInput, costume_statUncheckedUpdateWithoutCostumeInput>
    create: XOR<costume_statCreateWithoutCostumeInput, costume_statUncheckedCreateWithoutCostumeInput>
  }

  export type costume_statUpdateWithWhereUniqueWithoutCostumeInput = {
    where: costume_statWhereUniqueInput
    data: XOR<costume_statUpdateWithoutCostumeInput, costume_statUncheckedUpdateWithoutCostumeInput>
  }

  export type costume_statUpdateManyWithWhereWithoutCostumeInput = {
    where: costume_statScalarWhereInput
    data: XOR<costume_statUpdateManyMutationInput, costume_statUncheckedUpdateManyWithoutCostume_statInput>
  }

  export type costume_statScalarWhereInput = {
    AND?: Enumerable<costume_statScalarWhereInput>
    OR?: Enumerable<costume_statScalarWhereInput>
    NOT?: Enumerable<costume_statScalarWhereInput>
    costume_id?: IntFilter | number
    level?: IntFilter | number
    agi?: IntFilter | number
    atk?: IntFilter | number
    crit_atk?: IntFilter | number
    crit_rate?: IntFilter | number
    eva_rate?: IntFilter | number
    hp?: IntFilter | number
    vit?: IntFilter | number
  }

  export type costume_ability_linkCreateWithoutCostume_abilityInput = {
    ability_slot: number
    costume: costumeCreateNestedOneWithoutCostume_ability_linkInput
  }

  export type costume_ability_linkUncheckedCreateWithoutCostume_abilityInput = {
    costume_id: number
    ability_slot: number
  }

  export type costume_ability_linkCreateOrConnectWithoutCostume_abilityInput = {
    where: costume_ability_linkWhereUniqueInput
    create: XOR<costume_ability_linkCreateWithoutCostume_abilityInput, costume_ability_linkUncheckedCreateWithoutCostume_abilityInput>
  }

  export type costume_ability_linkCreateManyCostume_abilityInputEnvelope = {
    data: Enumerable<costume_ability_linkCreateManyCostume_abilityInput>
    skipDuplicates?: boolean
  }

  export type costume_ability_linkUpsertWithWhereUniqueWithoutCostume_abilityInput = {
    where: costume_ability_linkWhereUniqueInput
    update: XOR<costume_ability_linkUpdateWithoutCostume_abilityInput, costume_ability_linkUncheckedUpdateWithoutCostume_abilityInput>
    create: XOR<costume_ability_linkCreateWithoutCostume_abilityInput, costume_ability_linkUncheckedCreateWithoutCostume_abilityInput>
  }

  export type costume_ability_linkUpdateWithWhereUniqueWithoutCostume_abilityInput = {
    where: costume_ability_linkWhereUniqueInput
    data: XOR<costume_ability_linkUpdateWithoutCostume_abilityInput, costume_ability_linkUncheckedUpdateWithoutCostume_abilityInput>
  }

  export type costume_ability_linkUpdateManyWithWhereWithoutCostume_abilityInput = {
    where: costume_ability_linkScalarWhereInput
    data: XOR<costume_ability_linkUpdateManyMutationInput, costume_ability_linkUncheckedUpdateManyWithoutCostume_ability_linkInput>
  }

  export type costume_abilityCreateWithoutCostume_ability_linkInput = {
    ability_id: number
    ability_level: number
    name?: string | null
    description?: string | null
    image_path_base?: string | null
  }

  export type costume_abilityUncheckedCreateWithoutCostume_ability_linkInput = {
    ability_id: number
    ability_level: number
    name?: string | null
    description?: string | null
    image_path_base?: string | null
  }

  export type costume_abilityCreateOrConnectWithoutCostume_ability_linkInput = {
    where: costume_abilityWhereUniqueInput
    create: XOR<costume_abilityCreateWithoutCostume_ability_linkInput, costume_abilityUncheckedCreateWithoutCostume_ability_linkInput>
  }

  export type costumeCreateWithoutCostume_ability_linkInput = {
    weapon_type?: string | null
    rarity?: string | null
    release_time: Date | string
    is_ex_costume: boolean
    slug?: string | null
    title?: string | null
    description?: string | null
    image_path_base?: string | null
    character: characterCreateNestedOneWithoutCostumeInput
    emblem?: emblemCreateNestedOneWithoutCostumeInput
    costume_skill_link?: costume_skill_linkCreateNestedManyWithoutCostumeInput
    costume_stat?: costume_statCreateNestedManyWithoutCostumeInput
  }

  export type costumeUncheckedCreateWithoutCostume_ability_linkInput = {
    costume_id?: number
    character_id: number
    emblem_id?: number | null
    weapon_type?: string | null
    rarity?: string | null
    release_time: Date | string
    is_ex_costume: boolean
    slug?: string | null
    title?: string | null
    description?: string | null
    image_path_base?: string | null
    costume_skill_link?: costume_skill_linkUncheckedCreateNestedManyWithoutCostumeInput
    costume_stat?: costume_statUncheckedCreateNestedManyWithoutCostumeInput
  }

  export type costumeCreateOrConnectWithoutCostume_ability_linkInput = {
    where: costumeWhereUniqueInput
    create: XOR<costumeCreateWithoutCostume_ability_linkInput, costumeUncheckedCreateWithoutCostume_ability_linkInput>
  }

  export type costume_abilityUpsertWithoutCostume_ability_linkInput = {
    update: XOR<costume_abilityUpdateWithoutCostume_ability_linkInput, costume_abilityUncheckedUpdateWithoutCostume_ability_linkInput>
    create: XOR<costume_abilityCreateWithoutCostume_ability_linkInput, costume_abilityUncheckedCreateWithoutCostume_ability_linkInput>
  }

  export type costume_abilityUpdateWithoutCostume_ability_linkInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type costume_abilityUncheckedUpdateWithoutCostume_ability_linkInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type costumeUpsertWithoutCostume_ability_linkInput = {
    update: XOR<costumeUpdateWithoutCostume_ability_linkInput, costumeUncheckedUpdateWithoutCostume_ability_linkInput>
    create: XOR<costumeCreateWithoutCostume_ability_linkInput, costumeUncheckedCreateWithoutCostume_ability_linkInput>
  }

  export type costumeUpdateWithoutCostume_ability_linkInput = {
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_ex_costume?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    character?: characterUpdateOneRequiredWithoutCostumeInput
    emblem?: emblemUpdateOneWithoutCostumeInput
    costume_skill_link?: costume_skill_linkUpdateManyWithoutCostumeInput
    costume_stat?: costume_statUpdateManyWithoutCostumeInput
  }

  export type costumeUncheckedUpdateWithoutCostume_ability_linkInput = {
    costume_id?: IntFieldUpdateOperationsInput | number
    character_id?: IntFieldUpdateOperationsInput | number
    emblem_id?: NullableIntFieldUpdateOperationsInput | number | null
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_ex_costume?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    costume_skill_link?: costume_skill_linkUncheckedUpdateManyWithoutCostumeInput
    costume_stat?: costume_statUncheckedUpdateManyWithoutCostumeInput
  }

  export type costume_skill_linkCreateWithoutCostume_skillInput = {
    costume: costumeCreateNestedOneWithoutCostume_skill_linkInput
  }

  export type costume_skill_linkUncheckedCreateWithoutCostume_skillInput = {
    costume_id: number
  }

  export type costume_skill_linkCreateOrConnectWithoutCostume_skillInput = {
    where: costume_skill_linkWhereUniqueInput
    create: XOR<costume_skill_linkCreateWithoutCostume_skillInput, costume_skill_linkUncheckedCreateWithoutCostume_skillInput>
  }

  export type costume_skill_linkCreateManyCostume_skillInputEnvelope = {
    data: Enumerable<costume_skill_linkCreateManyCostume_skillInput>
    skipDuplicates?: boolean
  }

  export type costume_skill_linkUpsertWithWhereUniqueWithoutCostume_skillInput = {
    where: costume_skill_linkWhereUniqueInput
    update: XOR<costume_skill_linkUpdateWithoutCostume_skillInput, costume_skill_linkUncheckedUpdateWithoutCostume_skillInput>
    create: XOR<costume_skill_linkCreateWithoutCostume_skillInput, costume_skill_linkUncheckedCreateWithoutCostume_skillInput>
  }

  export type costume_skill_linkUpdateWithWhereUniqueWithoutCostume_skillInput = {
    where: costume_skill_linkWhereUniqueInput
    data: XOR<costume_skill_linkUpdateWithoutCostume_skillInput, costume_skill_linkUncheckedUpdateWithoutCostume_skillInput>
  }

  export type costume_skill_linkUpdateManyWithWhereWithoutCostume_skillInput = {
    where: costume_skill_linkScalarWhereInput
    data: XOR<costume_skill_linkUpdateManyMutationInput, costume_skill_linkUncheckedUpdateManyWithoutCostume_skill_linkInput>
  }

  export type costumeCreateWithoutCostume_skill_linkInput = {
    weapon_type?: string | null
    rarity?: string | null
    release_time: Date | string
    is_ex_costume: boolean
    slug?: string | null
    title?: string | null
    description?: string | null
    image_path_base?: string | null
    character: characterCreateNestedOneWithoutCostumeInput
    emblem?: emblemCreateNestedOneWithoutCostumeInput
    costume_ability_link?: costume_ability_linkCreateNestedManyWithoutCostumeInput
    costume_stat?: costume_statCreateNestedManyWithoutCostumeInput
  }

  export type costumeUncheckedCreateWithoutCostume_skill_linkInput = {
    costume_id?: number
    character_id: number
    emblem_id?: number | null
    weapon_type?: string | null
    rarity?: string | null
    release_time: Date | string
    is_ex_costume: boolean
    slug?: string | null
    title?: string | null
    description?: string | null
    image_path_base?: string | null
    costume_ability_link?: costume_ability_linkUncheckedCreateNestedManyWithoutCostumeInput
    costume_stat?: costume_statUncheckedCreateNestedManyWithoutCostumeInput
  }

  export type costumeCreateOrConnectWithoutCostume_skill_linkInput = {
    where: costumeWhereUniqueInput
    create: XOR<costumeCreateWithoutCostume_skill_linkInput, costumeUncheckedCreateWithoutCostume_skill_linkInput>
  }

  export type costume_skillCreateWithoutCostume_skill_linkInput = {
    skill_id: number
    skill_level: number
    gauge_rise_speed?: string | null
    cooldown_time: number
    name?: string | null
    description?: string | null
    short_description?: string | null
    image_path?: string | null
  }

  export type costume_skillUncheckedCreateWithoutCostume_skill_linkInput = {
    skill_id: number
    skill_level: number
    gauge_rise_speed?: string | null
    cooldown_time: number
    name?: string | null
    description?: string | null
    short_description?: string | null
    image_path?: string | null
  }

  export type costume_skillCreateOrConnectWithoutCostume_skill_linkInput = {
    where: costume_skillWhereUniqueInput
    create: XOR<costume_skillCreateWithoutCostume_skill_linkInput, costume_skillUncheckedCreateWithoutCostume_skill_linkInput>
  }

  export type costumeUpsertWithoutCostume_skill_linkInput = {
    update: XOR<costumeUpdateWithoutCostume_skill_linkInput, costumeUncheckedUpdateWithoutCostume_skill_linkInput>
    create: XOR<costumeCreateWithoutCostume_skill_linkInput, costumeUncheckedCreateWithoutCostume_skill_linkInput>
  }

  export type costumeUpdateWithoutCostume_skill_linkInput = {
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_ex_costume?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    character?: characterUpdateOneRequiredWithoutCostumeInput
    emblem?: emblemUpdateOneWithoutCostumeInput
    costume_ability_link?: costume_ability_linkUpdateManyWithoutCostumeInput
    costume_stat?: costume_statUpdateManyWithoutCostumeInput
  }

  export type costumeUncheckedUpdateWithoutCostume_skill_linkInput = {
    costume_id?: IntFieldUpdateOperationsInput | number
    character_id?: IntFieldUpdateOperationsInput | number
    emblem_id?: NullableIntFieldUpdateOperationsInput | number | null
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_ex_costume?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    costume_ability_link?: costume_ability_linkUncheckedUpdateManyWithoutCostumeInput
    costume_stat?: costume_statUncheckedUpdateManyWithoutCostumeInput
  }

  export type costume_skillUpsertWithoutCostume_skill_linkInput = {
    update: XOR<costume_skillUpdateWithoutCostume_skill_linkInput, costume_skillUncheckedUpdateWithoutCostume_skill_linkInput>
    create: XOR<costume_skillCreateWithoutCostume_skill_linkInput, costume_skillUncheckedCreateWithoutCostume_skill_linkInput>
  }

  export type costume_skillUpdateWithoutCostume_skill_linkInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    gauge_rise_speed?: NullableStringFieldUpdateOperationsInput | string | null
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type costume_skillUncheckedUpdateWithoutCostume_skill_linkInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    gauge_rise_speed?: NullableStringFieldUpdateOperationsInput | string | null
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type costumeCreateWithoutCostume_statInput = {
    weapon_type?: string | null
    rarity?: string | null
    release_time: Date | string
    is_ex_costume: boolean
    slug?: string | null
    title?: string | null
    description?: string | null
    image_path_base?: string | null
    character: characterCreateNestedOneWithoutCostumeInput
    emblem?: emblemCreateNestedOneWithoutCostumeInput
    costume_ability_link?: costume_ability_linkCreateNestedManyWithoutCostumeInput
    costume_skill_link?: costume_skill_linkCreateNestedManyWithoutCostumeInput
  }

  export type costumeUncheckedCreateWithoutCostume_statInput = {
    costume_id?: number
    character_id: number
    emblem_id?: number | null
    weapon_type?: string | null
    rarity?: string | null
    release_time: Date | string
    is_ex_costume: boolean
    slug?: string | null
    title?: string | null
    description?: string | null
    image_path_base?: string | null
    costume_ability_link?: costume_ability_linkUncheckedCreateNestedManyWithoutCostumeInput
    costume_skill_link?: costume_skill_linkUncheckedCreateNestedManyWithoutCostumeInput
  }

  export type costumeCreateOrConnectWithoutCostume_statInput = {
    where: costumeWhereUniqueInput
    create: XOR<costumeCreateWithoutCostume_statInput, costumeUncheckedCreateWithoutCostume_statInput>
  }

  export type costumeUpsertWithoutCostume_statInput = {
    update: XOR<costumeUpdateWithoutCostume_statInput, costumeUncheckedUpdateWithoutCostume_statInput>
    create: XOR<costumeCreateWithoutCostume_statInput, costumeUncheckedCreateWithoutCostume_statInput>
  }

  export type costumeUpdateWithoutCostume_statInput = {
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_ex_costume?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    character?: characterUpdateOneRequiredWithoutCostumeInput
    emblem?: emblemUpdateOneWithoutCostumeInput
    costume_ability_link?: costume_ability_linkUpdateManyWithoutCostumeInput
    costume_skill_link?: costume_skill_linkUpdateManyWithoutCostumeInput
  }

  export type costumeUncheckedUpdateWithoutCostume_statInput = {
    costume_id?: IntFieldUpdateOperationsInput | number
    character_id?: IntFieldUpdateOperationsInput | number
    emblem_id?: NullableIntFieldUpdateOperationsInput | number | null
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_ex_costume?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    costume_ability_link?: costume_ability_linkUncheckedUpdateManyWithoutCostumeInput
    costume_skill_link?: costume_skill_linkUncheckedUpdateManyWithoutCostumeInput
  }

  export type costumeCreateWithoutEmblemInput = {
    weapon_type?: string | null
    rarity?: string | null
    release_time: Date | string
    is_ex_costume: boolean
    slug?: string | null
    title?: string | null
    description?: string | null
    image_path_base?: string | null
    character: characterCreateNestedOneWithoutCostumeInput
    costume_ability_link?: costume_ability_linkCreateNestedManyWithoutCostumeInput
    costume_skill_link?: costume_skill_linkCreateNestedManyWithoutCostumeInput
    costume_stat?: costume_statCreateNestedManyWithoutCostumeInput
  }

  export type costumeUncheckedCreateWithoutEmblemInput = {
    costume_id?: number
    character_id: number
    weapon_type?: string | null
    rarity?: string | null
    release_time: Date | string
    is_ex_costume: boolean
    slug?: string | null
    title?: string | null
    description?: string | null
    image_path_base?: string | null
    costume_ability_link?: costume_ability_linkUncheckedCreateNestedManyWithoutCostumeInput
    costume_skill_link?: costume_skill_linkUncheckedCreateNestedManyWithoutCostumeInput
    costume_stat?: costume_statUncheckedCreateNestedManyWithoutCostumeInput
  }

  export type costumeCreateOrConnectWithoutEmblemInput = {
    where: costumeWhereUniqueInput
    create: XOR<costumeCreateWithoutEmblemInput, costumeUncheckedCreateWithoutEmblemInput>
  }

  export type costumeCreateManyEmblemInputEnvelope = {
    data: Enumerable<costumeCreateManyEmblemInput>
    skipDuplicates?: boolean
  }

  export type costumeUpsertWithWhereUniqueWithoutEmblemInput = {
    where: costumeWhereUniqueInput
    update: XOR<costumeUpdateWithoutEmblemInput, costumeUncheckedUpdateWithoutEmblemInput>
    create: XOR<costumeCreateWithoutEmblemInput, costumeUncheckedCreateWithoutEmblemInput>
  }

  export type costumeUpdateWithWhereUniqueWithoutEmblemInput = {
    where: costumeWhereUniqueInput
    data: XOR<costumeUpdateWithoutEmblemInput, costumeUncheckedUpdateWithoutEmblemInput>
  }

  export type costumeUpdateManyWithWhereWithoutEmblemInput = {
    where: costumeScalarWhereInput
    data: XOR<costumeUpdateManyMutationInput, costumeUncheckedUpdateManyWithoutCostumeInput>
  }

  export type memoir_seriesCreateWithoutMemoirInput = {
    name?: string | null
    small_set_description?: string | null
    large_set_description?: string | null
  }

  export type memoir_seriesUncheckedCreateWithoutMemoirInput = {
    memoir_series_id?: number
    name?: string | null
    small_set_description?: string | null
    large_set_description?: string | null
  }

  export type memoir_seriesCreateOrConnectWithoutMemoirInput = {
    where: memoir_seriesWhereUniqueInput
    create: XOR<memoir_seriesCreateWithoutMemoirInput, memoir_seriesUncheckedCreateWithoutMemoirInput>
  }

  export type memoir_seriesUpsertWithoutMemoirInput = {
    update: XOR<memoir_seriesUpdateWithoutMemoirInput, memoir_seriesUncheckedUpdateWithoutMemoirInput>
    create: XOR<memoir_seriesCreateWithoutMemoirInput, memoir_seriesUncheckedCreateWithoutMemoirInput>
  }

  export type memoir_seriesUpdateWithoutMemoirInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    small_set_description?: NullableStringFieldUpdateOperationsInput | string | null
    large_set_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type memoir_seriesUncheckedUpdateWithoutMemoirInput = {
    memoir_series_id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    small_set_description?: NullableStringFieldUpdateOperationsInput | string | null
    large_set_description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type memoirCreateWithoutMemoir_seriesInput = {
    memoir_id: number
    lottery_id: number
    rarity?: string | null
    release_time: Date | string
    name?: string | null
    story?: string | null
    image_path_base?: string | null
  }

  export type memoirUncheckedCreateWithoutMemoir_seriesInput = {
    memoir_id: number
    lottery_id: number
    rarity?: string | null
    release_time: Date | string
    name?: string | null
    story?: string | null
    image_path_base?: string | null
  }

  export type memoirCreateOrConnectWithoutMemoir_seriesInput = {
    where: memoirWhereUniqueInput
    create: XOR<memoirCreateWithoutMemoir_seriesInput, memoirUncheckedCreateWithoutMemoir_seriesInput>
  }

  export type memoirCreateManyMemoir_seriesInputEnvelope = {
    data: Enumerable<memoirCreateManyMemoir_seriesInput>
    skipDuplicates?: boolean
  }

  export type memoirUpsertWithWhereUniqueWithoutMemoir_seriesInput = {
    where: memoirWhereUniqueInput
    update: XOR<memoirUpdateWithoutMemoir_seriesInput, memoirUncheckedUpdateWithoutMemoir_seriesInput>
    create: XOR<memoirCreateWithoutMemoir_seriesInput, memoirUncheckedCreateWithoutMemoir_seriesInput>
  }

  export type memoirUpdateWithWhereUniqueWithoutMemoir_seriesInput = {
    where: memoirWhereUniqueInput
    data: XOR<memoirUpdateWithoutMemoir_seriesInput, memoirUncheckedUpdateWithoutMemoir_seriesInput>
  }

  export type memoirUpdateManyWithWhereWithoutMemoir_seriesInput = {
    where: memoirScalarWhereInput
    data: XOR<memoirUpdateManyMutationInput, memoirUncheckedUpdateManyWithoutMemoirInput>
  }

  export type memoirScalarWhereInput = {
    AND?: Enumerable<memoirScalarWhereInput>
    OR?: Enumerable<memoirScalarWhereInput>
    NOT?: Enumerable<memoirScalarWhereInput>
    memoir_id?: IntFilter | number
    lottery_id?: IntFilter | number
    rarity?: StringNullableFilter | string | null
    release_time?: DateTimeFilter | Date | string
    name?: StringNullableFilter | string | null
    story?: StringNullableFilter | string | null
    image_path_base?: StringNullableFilter | string | null
    memoir_series_id?: IntNullableFilter | number | null
  }

  export type weapon_ability_linkCreateWithoutWeaponInput = {
    slot_number: number
    weapon_ability: weapon_abilityCreateNestedOneWithoutWeapon_ability_linkInput
  }

  export type weapon_ability_linkUncheckedCreateWithoutWeaponInput = {
    slot_number: number
    ability_id: number
    ability_level: number
  }

  export type weapon_ability_linkCreateOrConnectWithoutWeaponInput = {
    where: weapon_ability_linkWhereUniqueInput
    create: XOR<weapon_ability_linkCreateWithoutWeaponInput, weapon_ability_linkUncheckedCreateWithoutWeaponInput>
  }

  export type weapon_ability_linkCreateManyWeaponInputEnvelope = {
    data: Enumerable<weapon_ability_linkCreateManyWeaponInput>
    skipDuplicates?: boolean
  }

  export type weapon_skill_linkCreateWithoutWeaponInput = {
    slot_number: number
    weapon_skill: weapon_skillCreateNestedOneWithoutWeapon_skill_linkInput
  }

  export type weapon_skill_linkUncheckedCreateWithoutWeaponInput = {
    slot_number: number
    skill_id: number
    skill_level: number
  }

  export type weapon_skill_linkCreateOrConnectWithoutWeaponInput = {
    where: weapon_skill_linkWhereUniqueInput
    create: XOR<weapon_skill_linkCreateWithoutWeaponInput, weapon_skill_linkUncheckedCreateWithoutWeaponInput>
  }

  export type weapon_skill_linkCreateManyWeaponInputEnvelope = {
    data: Enumerable<weapon_skill_linkCreateManyWeaponInput>
    skipDuplicates?: boolean
  }

  export type weapon_statCreateWithoutWeaponInput = {
    level: number
    atk: number
    hp: number
    vit: number
  }

  export type weapon_statUncheckedCreateWithoutWeaponInput = {
    level: number
    atk: number
    hp: number
    vit: number
  }

  export type weapon_statCreateOrConnectWithoutWeaponInput = {
    where: weapon_statWhereUniqueInput
    create: XOR<weapon_statCreateWithoutWeaponInput, weapon_statUncheckedCreateWithoutWeaponInput>
  }

  export type weapon_statCreateManyWeaponInputEnvelope = {
    data: Enumerable<weapon_statCreateManyWeaponInput>
    skipDuplicates?: boolean
  }

  export type weapon_story_linkCreateWithoutWeaponInput = {
    weapon_story: weapon_storyCreateNestedOneWithoutWeapon_story_linkInput
  }

  export type weapon_story_linkUncheckedCreateWithoutWeaponInput = {
    weapon_story_id: number
  }

  export type weapon_story_linkCreateOrConnectWithoutWeaponInput = {
    where: weapon_story_linkWhereUniqueInput
    create: XOR<weapon_story_linkCreateWithoutWeaponInput, weapon_story_linkUncheckedCreateWithoutWeaponInput>
  }

  export type weapon_story_linkCreateManyWeaponInputEnvelope = {
    data: Enumerable<weapon_story_linkCreateManyWeaponInput>
    skipDuplicates?: boolean
  }

  export type weapon_ability_linkUpsertWithWhereUniqueWithoutWeaponInput = {
    where: weapon_ability_linkWhereUniqueInput
    update: XOR<weapon_ability_linkUpdateWithoutWeaponInput, weapon_ability_linkUncheckedUpdateWithoutWeaponInput>
    create: XOR<weapon_ability_linkCreateWithoutWeaponInput, weapon_ability_linkUncheckedCreateWithoutWeaponInput>
  }

  export type weapon_ability_linkUpdateWithWhereUniqueWithoutWeaponInput = {
    where: weapon_ability_linkWhereUniqueInput
    data: XOR<weapon_ability_linkUpdateWithoutWeaponInput, weapon_ability_linkUncheckedUpdateWithoutWeaponInput>
  }

  export type weapon_ability_linkUpdateManyWithWhereWithoutWeaponInput = {
    where: weapon_ability_linkScalarWhereInput
    data: XOR<weapon_ability_linkUpdateManyMutationInput, weapon_ability_linkUncheckedUpdateManyWithoutWeapon_ability_linkInput>
  }

  export type weapon_ability_linkScalarWhereInput = {
    AND?: Enumerable<weapon_ability_linkScalarWhereInput>
    OR?: Enumerable<weapon_ability_linkScalarWhereInput>
    NOT?: Enumerable<weapon_ability_linkScalarWhereInput>
    weapon_id?: IntFilter | number
    slot_number?: IntFilter | number
    ability_id?: IntFilter | number
    ability_level?: IntFilter | number
  }

  export type weapon_skill_linkUpsertWithWhereUniqueWithoutWeaponInput = {
    where: weapon_skill_linkWhereUniqueInput
    update: XOR<weapon_skill_linkUpdateWithoutWeaponInput, weapon_skill_linkUncheckedUpdateWithoutWeaponInput>
    create: XOR<weapon_skill_linkCreateWithoutWeaponInput, weapon_skill_linkUncheckedCreateWithoutWeaponInput>
  }

  export type weapon_skill_linkUpdateWithWhereUniqueWithoutWeaponInput = {
    where: weapon_skill_linkWhereUniqueInput
    data: XOR<weapon_skill_linkUpdateWithoutWeaponInput, weapon_skill_linkUncheckedUpdateWithoutWeaponInput>
  }

  export type weapon_skill_linkUpdateManyWithWhereWithoutWeaponInput = {
    where: weapon_skill_linkScalarWhereInput
    data: XOR<weapon_skill_linkUpdateManyMutationInput, weapon_skill_linkUncheckedUpdateManyWithoutWeapon_skill_linkInput>
  }

  export type weapon_skill_linkScalarWhereInput = {
    AND?: Enumerable<weapon_skill_linkScalarWhereInput>
    OR?: Enumerable<weapon_skill_linkScalarWhereInput>
    NOT?: Enumerable<weapon_skill_linkScalarWhereInput>
    weapon_id?: IntFilter | number
    slot_number?: IntFilter | number
    skill_id?: IntFilter | number
    skill_level?: IntFilter | number
  }

  export type weapon_statUpsertWithWhereUniqueWithoutWeaponInput = {
    where: weapon_statWhereUniqueInput
    update: XOR<weapon_statUpdateWithoutWeaponInput, weapon_statUncheckedUpdateWithoutWeaponInput>
    create: XOR<weapon_statCreateWithoutWeaponInput, weapon_statUncheckedCreateWithoutWeaponInput>
  }

  export type weapon_statUpdateWithWhereUniqueWithoutWeaponInput = {
    where: weapon_statWhereUniqueInput
    data: XOR<weapon_statUpdateWithoutWeaponInput, weapon_statUncheckedUpdateWithoutWeaponInput>
  }

  export type weapon_statUpdateManyWithWhereWithoutWeaponInput = {
    where: weapon_statScalarWhereInput
    data: XOR<weapon_statUpdateManyMutationInput, weapon_statUncheckedUpdateManyWithoutWeapon_statInput>
  }

  export type weapon_statScalarWhereInput = {
    AND?: Enumerable<weapon_statScalarWhereInput>
    OR?: Enumerable<weapon_statScalarWhereInput>
    NOT?: Enumerable<weapon_statScalarWhereInput>
    weapon_id?: IntFilter | number
    level?: IntFilter | number
    atk?: IntFilter | number
    hp?: IntFilter | number
    vit?: IntFilter | number
  }

  export type weapon_story_linkUpsertWithWhereUniqueWithoutWeaponInput = {
    where: weapon_story_linkWhereUniqueInput
    update: XOR<weapon_story_linkUpdateWithoutWeaponInput, weapon_story_linkUncheckedUpdateWithoutWeaponInput>
    create: XOR<weapon_story_linkCreateWithoutWeaponInput, weapon_story_linkUncheckedCreateWithoutWeaponInput>
  }

  export type weapon_story_linkUpdateWithWhereUniqueWithoutWeaponInput = {
    where: weapon_story_linkWhereUniqueInput
    data: XOR<weapon_story_linkUpdateWithoutWeaponInput, weapon_story_linkUncheckedUpdateWithoutWeaponInput>
  }

  export type weapon_story_linkUpdateManyWithWhereWithoutWeaponInput = {
    where: weapon_story_linkScalarWhereInput
    data: XOR<weapon_story_linkUpdateManyMutationInput, weapon_story_linkUncheckedUpdateManyWithoutWeapon_story_linkInput>
  }

  export type weapon_story_linkScalarWhereInput = {
    AND?: Enumerable<weapon_story_linkScalarWhereInput>
    OR?: Enumerable<weapon_story_linkScalarWhereInput>
    NOT?: Enumerable<weapon_story_linkScalarWhereInput>
    weapon_id?: IntFilter | number
    weapon_story_id?: IntFilter | number
  }

  export type weapon_ability_linkCreateWithoutWeapon_abilityInput = {
    slot_number: number
    weapon: weaponCreateNestedOneWithoutWeapon_ability_linkInput
  }

  export type weapon_ability_linkUncheckedCreateWithoutWeapon_abilityInput = {
    weapon_id: number
    slot_number: number
  }

  export type weapon_ability_linkCreateOrConnectWithoutWeapon_abilityInput = {
    where: weapon_ability_linkWhereUniqueInput
    create: XOR<weapon_ability_linkCreateWithoutWeapon_abilityInput, weapon_ability_linkUncheckedCreateWithoutWeapon_abilityInput>
  }

  export type weapon_ability_linkCreateManyWeapon_abilityInputEnvelope = {
    data: Enumerable<weapon_ability_linkCreateManyWeapon_abilityInput>
    skipDuplicates?: boolean
  }

  export type weapon_ability_linkUpsertWithWhereUniqueWithoutWeapon_abilityInput = {
    where: weapon_ability_linkWhereUniqueInput
    update: XOR<weapon_ability_linkUpdateWithoutWeapon_abilityInput, weapon_ability_linkUncheckedUpdateWithoutWeapon_abilityInput>
    create: XOR<weapon_ability_linkCreateWithoutWeapon_abilityInput, weapon_ability_linkUncheckedCreateWithoutWeapon_abilityInput>
  }

  export type weapon_ability_linkUpdateWithWhereUniqueWithoutWeapon_abilityInput = {
    where: weapon_ability_linkWhereUniqueInput
    data: XOR<weapon_ability_linkUpdateWithoutWeapon_abilityInput, weapon_ability_linkUncheckedUpdateWithoutWeapon_abilityInput>
  }

  export type weapon_ability_linkUpdateManyWithWhereWithoutWeapon_abilityInput = {
    where: weapon_ability_linkScalarWhereInput
    data: XOR<weapon_ability_linkUpdateManyMutationInput, weapon_ability_linkUncheckedUpdateManyWithoutWeapon_ability_linkInput>
  }

  export type weapon_abilityCreateWithoutWeapon_ability_linkInput = {
    ability_id: number
    ability_level: number
    name?: string | null
    description?: string | null
    image_path_base?: string | null
  }

  export type weapon_abilityUncheckedCreateWithoutWeapon_ability_linkInput = {
    ability_id: number
    ability_level: number
    name?: string | null
    description?: string | null
    image_path_base?: string | null
  }

  export type weapon_abilityCreateOrConnectWithoutWeapon_ability_linkInput = {
    where: weapon_abilityWhereUniqueInput
    create: XOR<weapon_abilityCreateWithoutWeapon_ability_linkInput, weapon_abilityUncheckedCreateWithoutWeapon_ability_linkInput>
  }

  export type weaponCreateWithoutWeapon_ability_linkInput = {
    evolution_group_id: number
    evolution_order: number
    weapon_type?: string | null
    rarity?: string | null
    attribute?: string | null
    is_ex_weapon: boolean
    release_time?: Date | string | null
    slug?: string | null
    name?: string | null
    image_path?: string | null
    weapon_skill_link?: weapon_skill_linkCreateNestedManyWithoutWeaponInput
    weapon_stat?: weapon_statCreateNestedManyWithoutWeaponInput
    weapon_story_link?: weapon_story_linkCreateNestedManyWithoutWeaponInput
  }

  export type weaponUncheckedCreateWithoutWeapon_ability_linkInput = {
    weapon_id?: number
    evolution_group_id: number
    evolution_order: number
    weapon_type?: string | null
    rarity?: string | null
    attribute?: string | null
    is_ex_weapon: boolean
    release_time?: Date | string | null
    slug?: string | null
    name?: string | null
    image_path?: string | null
    weapon_skill_link?: weapon_skill_linkUncheckedCreateNestedManyWithoutWeaponInput
    weapon_stat?: weapon_statUncheckedCreateNestedManyWithoutWeaponInput
    weapon_story_link?: weapon_story_linkUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type weaponCreateOrConnectWithoutWeapon_ability_linkInput = {
    where: weaponWhereUniqueInput
    create: XOR<weaponCreateWithoutWeapon_ability_linkInput, weaponUncheckedCreateWithoutWeapon_ability_linkInput>
  }

  export type weapon_abilityUpsertWithoutWeapon_ability_linkInput = {
    update: XOR<weapon_abilityUpdateWithoutWeapon_ability_linkInput, weapon_abilityUncheckedUpdateWithoutWeapon_ability_linkInput>
    create: XOR<weapon_abilityCreateWithoutWeapon_ability_linkInput, weapon_abilityUncheckedCreateWithoutWeapon_ability_linkInput>
  }

  export type weapon_abilityUpdateWithoutWeapon_ability_linkInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type weapon_abilityUncheckedUpdateWithoutWeapon_ability_linkInput = {
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type weaponUpsertWithoutWeapon_ability_linkInput = {
    update: XOR<weaponUpdateWithoutWeapon_ability_linkInput, weaponUncheckedUpdateWithoutWeapon_ability_linkInput>
    create: XOR<weaponCreateWithoutWeapon_ability_linkInput, weaponUncheckedCreateWithoutWeapon_ability_linkInput>
  }

  export type weaponUpdateWithoutWeapon_ability_linkInput = {
    evolution_group_id?: IntFieldUpdateOperationsInput | number
    evolution_order?: IntFieldUpdateOperationsInput | number
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    is_ex_weapon?: BoolFieldUpdateOperationsInput | boolean
    release_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    weapon_skill_link?: weapon_skill_linkUpdateManyWithoutWeaponInput
    weapon_stat?: weapon_statUpdateManyWithoutWeaponInput
    weapon_story_link?: weapon_story_linkUpdateManyWithoutWeaponInput
  }

  export type weaponUncheckedUpdateWithoutWeapon_ability_linkInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
    evolution_group_id?: IntFieldUpdateOperationsInput | number
    evolution_order?: IntFieldUpdateOperationsInput | number
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    is_ex_weapon?: BoolFieldUpdateOperationsInput | boolean
    release_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    weapon_skill_link?: weapon_skill_linkUncheckedUpdateManyWithoutWeaponInput
    weapon_stat?: weapon_statUncheckedUpdateManyWithoutWeaponInput
    weapon_story_link?: weapon_story_linkUncheckedUpdateManyWithoutWeaponInput
  }

  export type weapon_skill_linkCreateWithoutWeapon_skillInput = {
    slot_number: number
    weapon: weaponCreateNestedOneWithoutWeapon_skill_linkInput
  }

  export type weapon_skill_linkUncheckedCreateWithoutWeapon_skillInput = {
    weapon_id: number
    slot_number: number
  }

  export type weapon_skill_linkCreateOrConnectWithoutWeapon_skillInput = {
    where: weapon_skill_linkWhereUniqueInput
    create: XOR<weapon_skill_linkCreateWithoutWeapon_skillInput, weapon_skill_linkUncheckedCreateWithoutWeapon_skillInput>
  }

  export type weapon_skill_linkCreateManyWeapon_skillInputEnvelope = {
    data: Enumerable<weapon_skill_linkCreateManyWeapon_skillInput>
    skipDuplicates?: boolean
  }

  export type weapon_skill_linkUpsertWithWhereUniqueWithoutWeapon_skillInput = {
    where: weapon_skill_linkWhereUniqueInput
    update: XOR<weapon_skill_linkUpdateWithoutWeapon_skillInput, weapon_skill_linkUncheckedUpdateWithoutWeapon_skillInput>
    create: XOR<weapon_skill_linkCreateWithoutWeapon_skillInput, weapon_skill_linkUncheckedCreateWithoutWeapon_skillInput>
  }

  export type weapon_skill_linkUpdateWithWhereUniqueWithoutWeapon_skillInput = {
    where: weapon_skill_linkWhereUniqueInput
    data: XOR<weapon_skill_linkUpdateWithoutWeapon_skillInput, weapon_skill_linkUncheckedUpdateWithoutWeapon_skillInput>
  }

  export type weapon_skill_linkUpdateManyWithWhereWithoutWeapon_skillInput = {
    where: weapon_skill_linkScalarWhereInput
    data: XOR<weapon_skill_linkUpdateManyMutationInput, weapon_skill_linkUncheckedUpdateManyWithoutWeapon_skill_linkInput>
  }

  export type weapon_skillCreateWithoutWeapon_skill_linkInput = {
    skill_id: number
    skill_level: number
    cooldown_time: number
    name?: string | null
    description?: string | null
    short_description?: string | null
    image_path?: string | null
  }

  export type weapon_skillUncheckedCreateWithoutWeapon_skill_linkInput = {
    skill_id: number
    skill_level: number
    cooldown_time: number
    name?: string | null
    description?: string | null
    short_description?: string | null
    image_path?: string | null
  }

  export type weapon_skillCreateOrConnectWithoutWeapon_skill_linkInput = {
    where: weapon_skillWhereUniqueInput
    create: XOR<weapon_skillCreateWithoutWeapon_skill_linkInput, weapon_skillUncheckedCreateWithoutWeapon_skill_linkInput>
  }

  export type weaponCreateWithoutWeapon_skill_linkInput = {
    evolution_group_id: number
    evolution_order: number
    weapon_type?: string | null
    rarity?: string | null
    attribute?: string | null
    is_ex_weapon: boolean
    release_time?: Date | string | null
    slug?: string | null
    name?: string | null
    image_path?: string | null
    weapon_ability_link?: weapon_ability_linkCreateNestedManyWithoutWeaponInput
    weapon_stat?: weapon_statCreateNestedManyWithoutWeaponInput
    weapon_story_link?: weapon_story_linkCreateNestedManyWithoutWeaponInput
  }

  export type weaponUncheckedCreateWithoutWeapon_skill_linkInput = {
    weapon_id?: number
    evolution_group_id: number
    evolution_order: number
    weapon_type?: string | null
    rarity?: string | null
    attribute?: string | null
    is_ex_weapon: boolean
    release_time?: Date | string | null
    slug?: string | null
    name?: string | null
    image_path?: string | null
    weapon_ability_link?: weapon_ability_linkUncheckedCreateNestedManyWithoutWeaponInput
    weapon_stat?: weapon_statUncheckedCreateNestedManyWithoutWeaponInput
    weapon_story_link?: weapon_story_linkUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type weaponCreateOrConnectWithoutWeapon_skill_linkInput = {
    where: weaponWhereUniqueInput
    create: XOR<weaponCreateWithoutWeapon_skill_linkInput, weaponUncheckedCreateWithoutWeapon_skill_linkInput>
  }

  export type weapon_skillUpsertWithoutWeapon_skill_linkInput = {
    update: XOR<weapon_skillUpdateWithoutWeapon_skill_linkInput, weapon_skillUncheckedUpdateWithoutWeapon_skill_linkInput>
    create: XOR<weapon_skillCreateWithoutWeapon_skill_linkInput, weapon_skillUncheckedCreateWithoutWeapon_skill_linkInput>
  }

  export type weapon_skillUpdateWithoutWeapon_skill_linkInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type weapon_skillUncheckedUpdateWithoutWeapon_skill_linkInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
    cooldown_time?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    short_description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type weaponUpsertWithoutWeapon_skill_linkInput = {
    update: XOR<weaponUpdateWithoutWeapon_skill_linkInput, weaponUncheckedUpdateWithoutWeapon_skill_linkInput>
    create: XOR<weaponCreateWithoutWeapon_skill_linkInput, weaponUncheckedCreateWithoutWeapon_skill_linkInput>
  }

  export type weaponUpdateWithoutWeapon_skill_linkInput = {
    evolution_group_id?: IntFieldUpdateOperationsInput | number
    evolution_order?: IntFieldUpdateOperationsInput | number
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    is_ex_weapon?: BoolFieldUpdateOperationsInput | boolean
    release_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    weapon_ability_link?: weapon_ability_linkUpdateManyWithoutWeaponInput
    weapon_stat?: weapon_statUpdateManyWithoutWeaponInput
    weapon_story_link?: weapon_story_linkUpdateManyWithoutWeaponInput
  }

  export type weaponUncheckedUpdateWithoutWeapon_skill_linkInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
    evolution_group_id?: IntFieldUpdateOperationsInput | number
    evolution_order?: IntFieldUpdateOperationsInput | number
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    is_ex_weapon?: BoolFieldUpdateOperationsInput | boolean
    release_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    weapon_ability_link?: weapon_ability_linkUncheckedUpdateManyWithoutWeaponInput
    weapon_stat?: weapon_statUncheckedUpdateManyWithoutWeaponInput
    weapon_story_link?: weapon_story_linkUncheckedUpdateManyWithoutWeaponInput
  }

  export type weaponCreateWithoutWeapon_statInput = {
    evolution_group_id: number
    evolution_order: number
    weapon_type?: string | null
    rarity?: string | null
    attribute?: string | null
    is_ex_weapon: boolean
    release_time?: Date | string | null
    slug?: string | null
    name?: string | null
    image_path?: string | null
    weapon_ability_link?: weapon_ability_linkCreateNestedManyWithoutWeaponInput
    weapon_skill_link?: weapon_skill_linkCreateNestedManyWithoutWeaponInput
    weapon_story_link?: weapon_story_linkCreateNestedManyWithoutWeaponInput
  }

  export type weaponUncheckedCreateWithoutWeapon_statInput = {
    weapon_id?: number
    evolution_group_id: number
    evolution_order: number
    weapon_type?: string | null
    rarity?: string | null
    attribute?: string | null
    is_ex_weapon: boolean
    release_time?: Date | string | null
    slug?: string | null
    name?: string | null
    image_path?: string | null
    weapon_ability_link?: weapon_ability_linkUncheckedCreateNestedManyWithoutWeaponInput
    weapon_skill_link?: weapon_skill_linkUncheckedCreateNestedManyWithoutWeaponInput
    weapon_story_link?: weapon_story_linkUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type weaponCreateOrConnectWithoutWeapon_statInput = {
    where: weaponWhereUniqueInput
    create: XOR<weaponCreateWithoutWeapon_statInput, weaponUncheckedCreateWithoutWeapon_statInput>
  }

  export type weaponUpsertWithoutWeapon_statInput = {
    update: XOR<weaponUpdateWithoutWeapon_statInput, weaponUncheckedUpdateWithoutWeapon_statInput>
    create: XOR<weaponCreateWithoutWeapon_statInput, weaponUncheckedCreateWithoutWeapon_statInput>
  }

  export type weaponUpdateWithoutWeapon_statInput = {
    evolution_group_id?: IntFieldUpdateOperationsInput | number
    evolution_order?: IntFieldUpdateOperationsInput | number
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    is_ex_weapon?: BoolFieldUpdateOperationsInput | boolean
    release_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    weapon_ability_link?: weapon_ability_linkUpdateManyWithoutWeaponInput
    weapon_skill_link?: weapon_skill_linkUpdateManyWithoutWeaponInput
    weapon_story_link?: weapon_story_linkUpdateManyWithoutWeaponInput
  }

  export type weaponUncheckedUpdateWithoutWeapon_statInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
    evolution_group_id?: IntFieldUpdateOperationsInput | number
    evolution_order?: IntFieldUpdateOperationsInput | number
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    is_ex_weapon?: BoolFieldUpdateOperationsInput | boolean
    release_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    weapon_ability_link?: weapon_ability_linkUncheckedUpdateManyWithoutWeaponInput
    weapon_skill_link?: weapon_skill_linkUncheckedUpdateManyWithoutWeaponInput
    weapon_story_link?: weapon_story_linkUncheckedUpdateManyWithoutWeaponInput
  }

  export type weapon_story_linkCreateWithoutWeapon_storyInput = {
    weapon: weaponCreateNestedOneWithoutWeapon_story_linkInput
  }

  export type weapon_story_linkUncheckedCreateWithoutWeapon_storyInput = {
    weapon_id: number
  }

  export type weapon_story_linkCreateOrConnectWithoutWeapon_storyInput = {
    where: weapon_story_linkWhereUniqueInput
    create: XOR<weapon_story_linkCreateWithoutWeapon_storyInput, weapon_story_linkUncheckedCreateWithoutWeapon_storyInput>
  }

  export type weapon_story_linkCreateManyWeapon_storyInputEnvelope = {
    data: Enumerable<weapon_story_linkCreateManyWeapon_storyInput>
    skipDuplicates?: boolean
  }

  export type weapon_story_linkUpsertWithWhereUniqueWithoutWeapon_storyInput = {
    where: weapon_story_linkWhereUniqueInput
    update: XOR<weapon_story_linkUpdateWithoutWeapon_storyInput, weapon_story_linkUncheckedUpdateWithoutWeapon_storyInput>
    create: XOR<weapon_story_linkCreateWithoutWeapon_storyInput, weapon_story_linkUncheckedCreateWithoutWeapon_storyInput>
  }

  export type weapon_story_linkUpdateWithWhereUniqueWithoutWeapon_storyInput = {
    where: weapon_story_linkWhereUniqueInput
    data: XOR<weapon_story_linkUpdateWithoutWeapon_storyInput, weapon_story_linkUncheckedUpdateWithoutWeapon_storyInput>
  }

  export type weapon_story_linkUpdateManyWithWhereWithoutWeapon_storyInput = {
    where: weapon_story_linkScalarWhereInput
    data: XOR<weapon_story_linkUpdateManyMutationInput, weapon_story_linkUncheckedUpdateManyWithoutWeapon_story_linkInput>
  }

  export type weaponCreateWithoutWeapon_story_linkInput = {
    evolution_group_id: number
    evolution_order: number
    weapon_type?: string | null
    rarity?: string | null
    attribute?: string | null
    is_ex_weapon: boolean
    release_time?: Date | string | null
    slug?: string | null
    name?: string | null
    image_path?: string | null
    weapon_ability_link?: weapon_ability_linkCreateNestedManyWithoutWeaponInput
    weapon_skill_link?: weapon_skill_linkCreateNestedManyWithoutWeaponInput
    weapon_stat?: weapon_statCreateNestedManyWithoutWeaponInput
  }

  export type weaponUncheckedCreateWithoutWeapon_story_linkInput = {
    weapon_id?: number
    evolution_group_id: number
    evolution_order: number
    weapon_type?: string | null
    rarity?: string | null
    attribute?: string | null
    is_ex_weapon: boolean
    release_time?: Date | string | null
    slug?: string | null
    name?: string | null
    image_path?: string | null
    weapon_ability_link?: weapon_ability_linkUncheckedCreateNestedManyWithoutWeaponInput
    weapon_skill_link?: weapon_skill_linkUncheckedCreateNestedManyWithoutWeaponInput
    weapon_stat?: weapon_statUncheckedCreateNestedManyWithoutWeaponInput
  }

  export type weaponCreateOrConnectWithoutWeapon_story_linkInput = {
    where: weaponWhereUniqueInput
    create: XOR<weaponCreateWithoutWeapon_story_linkInput, weaponUncheckedCreateWithoutWeapon_story_linkInput>
  }

  export type weapon_storyCreateWithoutWeapon_story_linkInput = {
    story?: string | null
  }

  export type weapon_storyUncheckedCreateWithoutWeapon_story_linkInput = {
    id?: number
    story?: string | null
  }

  export type weapon_storyCreateOrConnectWithoutWeapon_story_linkInput = {
    where: weapon_storyWhereUniqueInput
    create: XOR<weapon_storyCreateWithoutWeapon_story_linkInput, weapon_storyUncheckedCreateWithoutWeapon_story_linkInput>
  }

  export type weaponUpsertWithoutWeapon_story_linkInput = {
    update: XOR<weaponUpdateWithoutWeapon_story_linkInput, weaponUncheckedUpdateWithoutWeapon_story_linkInput>
    create: XOR<weaponCreateWithoutWeapon_story_linkInput, weaponUncheckedCreateWithoutWeapon_story_linkInput>
  }

  export type weaponUpdateWithoutWeapon_story_linkInput = {
    evolution_group_id?: IntFieldUpdateOperationsInput | number
    evolution_order?: IntFieldUpdateOperationsInput | number
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    is_ex_weapon?: BoolFieldUpdateOperationsInput | boolean
    release_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    weapon_ability_link?: weapon_ability_linkUpdateManyWithoutWeaponInput
    weapon_skill_link?: weapon_skill_linkUpdateManyWithoutWeaponInput
    weapon_stat?: weapon_statUpdateManyWithoutWeaponInput
  }

  export type weaponUncheckedUpdateWithoutWeapon_story_linkInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
    evolution_group_id?: IntFieldUpdateOperationsInput | number
    evolution_order?: IntFieldUpdateOperationsInput | number
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    attribute?: NullableStringFieldUpdateOperationsInput | string | null
    is_ex_weapon?: BoolFieldUpdateOperationsInput | boolean
    release_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image_path?: NullableStringFieldUpdateOperationsInput | string | null
    weapon_ability_link?: weapon_ability_linkUncheckedUpdateManyWithoutWeaponInput
    weapon_skill_link?: weapon_skill_linkUncheckedUpdateManyWithoutWeaponInput
    weapon_stat?: weapon_statUncheckedUpdateManyWithoutWeaponInput
  }

  export type weapon_storyUpsertWithoutWeapon_story_linkInput = {
    update: XOR<weapon_storyUpdateWithoutWeapon_story_linkInput, weapon_storyUncheckedUpdateWithoutWeapon_story_linkInput>
    create: XOR<weapon_storyCreateWithoutWeapon_story_linkInput, weapon_storyUncheckedCreateWithoutWeapon_story_linkInput>
  }

  export type weapon_storyUpdateWithoutWeapon_story_linkInput = {
    story?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type weapon_storyUncheckedUpdateWithoutWeapon_story_linkInput = {
    id?: IntFieldUpdateOperationsInput | number
    story?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type character_rank_bonusCreateManyCharacterInput = {
    rank_bonus_id: number
    rank_bonus_level: number
    description?: string | null
    stat?: string | null
    type?: string | null
    amount: number
  }

  export type costumeCreateManyCharacterInput = {
    costume_id?: number
    emblem_id?: number | null
    weapon_type?: string | null
    rarity?: string | null
    release_time: Date | string
    is_ex_costume: boolean
    slug?: string | null
    title?: string | null
    description?: string | null
    image_path_base?: string | null
  }

  export type character_rank_bonusUpdateWithoutCharacterInput = {
    rank_bonus_id?: IntFieldUpdateOperationsInput | number
    rank_bonus_level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type character_rank_bonusUncheckedUpdateWithoutCharacterInput = {
    rank_bonus_id?: IntFieldUpdateOperationsInput | number
    rank_bonus_level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type character_rank_bonusUncheckedUpdateManyWithoutCharacter_rank_bonusInput = {
    rank_bonus_id?: IntFieldUpdateOperationsInput | number
    rank_bonus_level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    stat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: IntFieldUpdateOperationsInput | number
  }

  export type costumeUpdateWithoutCharacterInput = {
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_ex_costume?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    emblem?: emblemUpdateOneWithoutCostumeInput
    costume_ability_link?: costume_ability_linkUpdateManyWithoutCostumeInput
    costume_skill_link?: costume_skill_linkUpdateManyWithoutCostumeInput
    costume_stat?: costume_statUpdateManyWithoutCostumeInput
  }

  export type costumeUncheckedUpdateWithoutCharacterInput = {
    costume_id?: IntFieldUpdateOperationsInput | number
    emblem_id?: NullableIntFieldUpdateOperationsInput | number | null
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_ex_costume?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    costume_ability_link?: costume_ability_linkUncheckedUpdateManyWithoutCostumeInput
    costume_skill_link?: costume_skill_linkUncheckedUpdateManyWithoutCostumeInput
    costume_stat?: costume_statUncheckedUpdateManyWithoutCostumeInput
  }

  export type costumeUncheckedUpdateManyWithoutCostumeInput = {
    costume_id?: IntFieldUpdateOperationsInput | number
    emblem_id?: NullableIntFieldUpdateOperationsInput | number | null
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_ex_costume?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type companion_ability_linkCreateManyCompanionInput = {
    companion_level: number
    ability_id: number
    ability_level: number
  }

  export type companion_skill_linkCreateManyCompanionInput = {
    companion_level: number
    skill_id: number
    skill_level: number
  }

  export type companion_statCreateManyCompanionInput = {
    level: number
    atk: number
    hp: number
    vit: number
  }

  export type companion_ability_linkUpdateWithoutCompanionInput = {
    companion_level?: IntFieldUpdateOperationsInput | number
    companion_ability?: companion_abilityUpdateOneRequiredWithoutCompanion_ability_linkInput
  }

  export type companion_ability_linkUncheckedUpdateWithoutCompanionInput = {
    companion_level?: IntFieldUpdateOperationsInput | number
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
  }

  export type companion_ability_linkUncheckedUpdateManyWithoutCompanion_ability_linkInput = {
    companion_level?: IntFieldUpdateOperationsInput | number
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
  }

  export type companion_skill_linkUpdateWithoutCompanionInput = {
    companion_level?: IntFieldUpdateOperationsInput | number
    companion_skill?: companion_skillUpdateOneRequiredWithoutCompanion_skill_linkInput
  }

  export type companion_skill_linkUncheckedUpdateWithoutCompanionInput = {
    companion_level?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
  }

  export type companion_skill_linkUncheckedUpdateManyWithoutCompanion_skill_linkInput = {
    companion_level?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
  }

  export type companion_statUpdateWithoutCompanionInput = {
    level?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type companion_statUncheckedUpdateWithoutCompanionInput = {
    level?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type companion_statUncheckedUpdateManyWithoutCompanion_statInput = {
    level?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type companion_ability_linkCreateManyCompanion_abilityInput = {
    companion_id: number
    companion_level: number
  }

  export type companion_ability_linkUpdateWithoutCompanion_abilityInput = {
    companion_level?: IntFieldUpdateOperationsInput | number
    companion?: companionUpdateOneRequiredWithoutCompanion_ability_linkInput
  }

  export type companion_ability_linkUncheckedUpdateWithoutCompanion_abilityInput = {
    companion_id?: IntFieldUpdateOperationsInput | number
    companion_level?: IntFieldUpdateOperationsInput | number
  }

  export type companion_skill_linkCreateManyCompanion_skillInput = {
    companion_id: number
    companion_level: number
  }

  export type companion_skill_linkUpdateWithoutCompanion_skillInput = {
    companion_level?: IntFieldUpdateOperationsInput | number
    companion?: companionUpdateOneRequiredWithoutCompanion_skill_linkInput
  }

  export type companion_skill_linkUncheckedUpdateWithoutCompanion_skillInput = {
    companion_id?: IntFieldUpdateOperationsInput | number
    companion_level?: IntFieldUpdateOperationsInput | number
  }

  export type costume_ability_linkCreateManyCostumeInput = {
    ability_slot: number
    ability_id: number
    ability_level: number
  }

  export type costume_skill_linkCreateManyCostumeInput = {
    skill_id: number
    skill_level: number
  }

  export type costume_statCreateManyCostumeInput = {
    level: number
    agi: number
    atk: number
    crit_atk: number
    crit_rate: number
    eva_rate: number
    hp: number
    vit: number
  }

  export type costume_ability_linkUpdateWithoutCostumeInput = {
    ability_slot?: IntFieldUpdateOperationsInput | number
    costume_ability?: costume_abilityUpdateOneRequiredWithoutCostume_ability_linkInput
  }

  export type costume_ability_linkUncheckedUpdateWithoutCostumeInput = {
    ability_slot?: IntFieldUpdateOperationsInput | number
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
  }

  export type costume_ability_linkUncheckedUpdateManyWithoutCostume_ability_linkInput = {
    ability_slot?: IntFieldUpdateOperationsInput | number
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
  }

  export type costume_skill_linkUpdateWithoutCostumeInput = {
    costume_skill?: costume_skillUpdateOneRequiredWithoutCostume_skill_linkInput
  }

  export type costume_skill_linkUncheckedUpdateWithoutCostumeInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
  }

  export type costume_skill_linkUncheckedUpdateManyWithoutCostume_skill_linkInput = {
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
  }

  export type costume_statUpdateWithoutCostumeInput = {
    level?: IntFieldUpdateOperationsInput | number
    agi?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    crit_atk?: IntFieldUpdateOperationsInput | number
    crit_rate?: IntFieldUpdateOperationsInput | number
    eva_rate?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type costume_statUncheckedUpdateWithoutCostumeInput = {
    level?: IntFieldUpdateOperationsInput | number
    agi?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    crit_atk?: IntFieldUpdateOperationsInput | number
    crit_rate?: IntFieldUpdateOperationsInput | number
    eva_rate?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type costume_statUncheckedUpdateManyWithoutCostume_statInput = {
    level?: IntFieldUpdateOperationsInput | number
    agi?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    crit_atk?: IntFieldUpdateOperationsInput | number
    crit_rate?: IntFieldUpdateOperationsInput | number
    eva_rate?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type costume_ability_linkCreateManyCostume_abilityInput = {
    costume_id: number
    ability_slot: number
  }

  export type costume_ability_linkUpdateWithoutCostume_abilityInput = {
    ability_slot?: IntFieldUpdateOperationsInput | number
    costume?: costumeUpdateOneRequiredWithoutCostume_ability_linkInput
  }

  export type costume_ability_linkUncheckedUpdateWithoutCostume_abilityInput = {
    costume_id?: IntFieldUpdateOperationsInput | number
    ability_slot?: IntFieldUpdateOperationsInput | number
  }

  export type costume_skill_linkCreateManyCostume_skillInput = {
    costume_id: number
  }

  export type costume_skill_linkUpdateWithoutCostume_skillInput = {
    costume?: costumeUpdateOneRequiredWithoutCostume_skill_linkInput
  }

  export type costume_skill_linkUncheckedUpdateWithoutCostume_skillInput = {
    costume_id?: IntFieldUpdateOperationsInput | number
  }

  export type costumeCreateManyEmblemInput = {
    costume_id?: number
    character_id: number
    weapon_type?: string | null
    rarity?: string | null
    release_time: Date | string
    is_ex_costume: boolean
    slug?: string | null
    title?: string | null
    description?: string | null
    image_path_base?: string | null
  }

  export type costumeUpdateWithoutEmblemInput = {
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_ex_costume?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    character?: characterUpdateOneRequiredWithoutCostumeInput
    costume_ability_link?: costume_ability_linkUpdateManyWithoutCostumeInput
    costume_skill_link?: costume_skill_linkUpdateManyWithoutCostumeInput
    costume_stat?: costume_statUpdateManyWithoutCostumeInput
  }

  export type costumeUncheckedUpdateWithoutEmblemInput = {
    costume_id?: IntFieldUpdateOperationsInput | number
    character_id?: IntFieldUpdateOperationsInput | number
    weapon_type?: NullableStringFieldUpdateOperationsInput | string | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    is_ex_costume?: BoolFieldUpdateOperationsInput | boolean
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
    costume_ability_link?: costume_ability_linkUncheckedUpdateManyWithoutCostumeInput
    costume_skill_link?: costume_skill_linkUncheckedUpdateManyWithoutCostumeInput
    costume_stat?: costume_statUncheckedUpdateManyWithoutCostumeInput
  }

  export type memoirCreateManyMemoir_seriesInput = {
    memoir_id: number
    lottery_id: number
    rarity?: string | null
    release_time: Date | string
    name?: string | null
    story?: string | null
    image_path_base?: string | null
  }

  export type memoirUpdateWithoutMemoir_seriesInput = {
    memoir_id?: IntFieldUpdateOperationsInput | number
    lottery_id?: IntFieldUpdateOperationsInput | number
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type memoirUncheckedUpdateWithoutMemoir_seriesInput = {
    memoir_id?: IntFieldUpdateOperationsInput | number
    lottery_id?: IntFieldUpdateOperationsInput | number
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type memoirUncheckedUpdateManyWithoutMemoirInput = {
    memoir_id?: IntFieldUpdateOperationsInput | number
    lottery_id?: IntFieldUpdateOperationsInput | number
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    release_time?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    story?: NullableStringFieldUpdateOperationsInput | string | null
    image_path_base?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type weapon_ability_linkCreateManyWeaponInput = {
    slot_number: number
    ability_id: number
    ability_level: number
  }

  export type weapon_skill_linkCreateManyWeaponInput = {
    slot_number: number
    skill_id: number
    skill_level: number
  }

  export type weapon_statCreateManyWeaponInput = {
    level: number
    atk: number
    hp: number
    vit: number
  }

  export type weapon_story_linkCreateManyWeaponInput = {
    weapon_story_id: number
  }

  export type weapon_ability_linkUpdateWithoutWeaponInput = {
    slot_number?: IntFieldUpdateOperationsInput | number
    weapon_ability?: weapon_abilityUpdateOneRequiredWithoutWeapon_ability_linkInput
  }

  export type weapon_ability_linkUncheckedUpdateWithoutWeaponInput = {
    slot_number?: IntFieldUpdateOperationsInput | number
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_ability_linkUncheckedUpdateManyWithoutWeapon_ability_linkInput = {
    slot_number?: IntFieldUpdateOperationsInput | number
    ability_id?: IntFieldUpdateOperationsInput | number
    ability_level?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_skill_linkUpdateWithoutWeaponInput = {
    slot_number?: IntFieldUpdateOperationsInput | number
    weapon_skill?: weapon_skillUpdateOneRequiredWithoutWeapon_skill_linkInput
  }

  export type weapon_skill_linkUncheckedUpdateWithoutWeaponInput = {
    slot_number?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_skill_linkUncheckedUpdateManyWithoutWeapon_skill_linkInput = {
    slot_number?: IntFieldUpdateOperationsInput | number
    skill_id?: IntFieldUpdateOperationsInput | number
    skill_level?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_statUpdateWithoutWeaponInput = {
    level?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_statUncheckedUpdateWithoutWeaponInput = {
    level?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_statUncheckedUpdateManyWithoutWeapon_statInput = {
    level?: IntFieldUpdateOperationsInput | number
    atk?: IntFieldUpdateOperationsInput | number
    hp?: IntFieldUpdateOperationsInput | number
    vit?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_story_linkUpdateWithoutWeaponInput = {
    weapon_story?: weapon_storyUpdateOneRequiredWithoutWeapon_story_linkInput
  }

  export type weapon_story_linkUncheckedUpdateWithoutWeaponInput = {
    weapon_story_id?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_story_linkUncheckedUpdateManyWithoutWeapon_story_linkInput = {
    weapon_story_id?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_ability_linkCreateManyWeapon_abilityInput = {
    weapon_id: number
    slot_number: number
  }

  export type weapon_ability_linkUpdateWithoutWeapon_abilityInput = {
    slot_number?: IntFieldUpdateOperationsInput | number
    weapon?: weaponUpdateOneRequiredWithoutWeapon_ability_linkInput
  }

  export type weapon_ability_linkUncheckedUpdateWithoutWeapon_abilityInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
    slot_number?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_skill_linkCreateManyWeapon_skillInput = {
    weapon_id: number
    slot_number: number
  }

  export type weapon_skill_linkUpdateWithoutWeapon_skillInput = {
    slot_number?: IntFieldUpdateOperationsInput | number
    weapon?: weaponUpdateOneRequiredWithoutWeapon_skill_linkInput
  }

  export type weapon_skill_linkUncheckedUpdateWithoutWeapon_skillInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
    slot_number?: IntFieldUpdateOperationsInput | number
  }

  export type weapon_story_linkCreateManyWeapon_storyInput = {
    weapon_id: number
  }

  export type weapon_story_linkUpdateWithoutWeapon_storyInput = {
    weapon?: weaponUpdateOneRequiredWithoutWeapon_story_linkInput
  }

  export type weapon_story_linkUncheckedUpdateWithoutWeapon_storyInput = {
    weapon_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}